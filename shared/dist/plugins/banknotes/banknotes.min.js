/*! ecb - v2.0.0 - European Central Bank */

function unique(t) {
    var e = {};
    return t.filter(function(t) {
        return !e.hasOwnProperty(t) && (e[t] = !0)
    })
}
function spinnyer(P, N, O, I, B, U, D) {
    var F, z, H = !1;
    if (!function() {
        try {
            var t = document.createElement("canvas");
            return !(!window.WebGLRenderingContext || !t.getContext("webgl") && !t.getContext("experimental-webgl"))
        } catch (t) {
            return !1
        }
    }())
        return !1;
    Array.isArray(O) || ("function" == typeof O && (D = O),
    O = []);
    var G, k = P.querySelector(".spinny-image");
    k.classList.remove("spinny-nojs"),
    P.querySelector(".spinny-flip") && (G = P.querySelectorAll("label[for=" + P.querySelector(".spinny-flip").getAttribute("id") + "]")),
    ECB.renderer = ECB.renderer || new THREE.WebGLRenderer({
        alpha: !0,
        antialias: !0,
        autoclear: !1
    });
    var V = ECB.renderer;
    V.setPixelRatio(2),
    k.appendChild(V.domElement);
    var j = new THREE.Scene
      , W = new THREE.PerspectiveCamera(40,1.5,.1,1e3);
    W.position.z = 2.3;
    for (var X = V.capabilities.getMaxAnisotropy(), a = new THREE.TextureLoader, t = {
        load: function(n, i) {
            for (var n = unique(n), r = 0, o = {}, t = 0; t < n.length; t++) {
                var e = n[t];
                !function(t, e) {
                    var n = new XMLHttpRequest;
                    n.onload = function() {
                        var t = new FileReader;
                        t.onloadend = function() {
                            e(t.result)
                        }
                        ,
                        t.readAsDataURL(n.response)
                    }
                    ,
                    n.open("GET", t),
                    n.responseType = "blob",
                    n.send()
                }(e, function(e) {
                    return function(t) {
                        r++;
                        t = a.load(t);
                        o[e] = t,
                        r == n.length && i(o)
                    }
                }(e))
            }
        }
    }, e = [N.noteFront, N.noteBack, N.foil, N.metal], n = 0; n < Object.keys(N.masksFr).length; n++) {
        var i = Object.keys(N.masksFr)[n];
        e.push(N.masksFr[i])
    }
    for (n = 0; n < Object.keys(N.masksBa).length; n++) {
        i = Object.keys(N.masksBa)[n];
        e.push(N.masksBa[i])
    }
    return t.load(e, function(t) {
        var e = t[N.noteFront]
          , n = t[N.noteBack];
        e.anisotropy = X,
        n.anisotropy = X,
        e.premultiplyAlpha = !0,
        n.premultiplyAlpha = !0,
        e.magFilter = THREE.LinearFilter,
        n.magFilter = THREE.LinearFilter,
        e.minFilter = THREE.NearestMipMapLinearFilter,
        n.minFilter = THREE.NearestMipMapLinearFilter;
        for (var i = [], r = 0; r < Object.keys(N.masksFr).length; r++)
            i[o = Object.keys(N.masksFr)[r]] = t[N.masksFr[o]],
            i[o].anisotropy = 1,
            i[o].magFilter = THREE.LinearFilter,
            i[o].minFilter = THREE.NearestMipMapLinearFilter;
        for (var o, a = [], r = 0; r < Object.keys(N.masksBa).length; r++)
            a[o = Object.keys(N.masksBa)[r]] = t[N.masksBa[o]],
            a[o].anisotropy = 1,
            a[o].magFilter = THREE.LinearFilter,
            a[o].minFilter = THREE.NearestMipMapLinearFilter;
        var l = t[N.foil]
          , u = t[N.metal]
          , s = new THREE.Vector3(-.6,.1,1.8).normalize()
          , d = new THREE.Color(16777215)
          , c = new THREE.PlaneBufferGeometry(I.aspectRatio,1,20,10)
          , h = new THREE.PlaneBufferGeometry(I.aspectRatio,1,20,10);
        function p(t, e, n, i, r, o) {
            var a = new THREE.Matrix4;
            Array.isArray(n) && (a = a.fromArray(n));
            for (var n = o ? U : B, o = window.ECB || {}, s = {
                uniforms: {
                    uDisp: {
                        type: "f",
                        value: 0
                    },
                    uRot: {
                        type: "f",
                        value: 0
                    },
                    uTilt: {
                        type: "f",
                        value: 0
                    },
                    uEmerald: {
                        type: "f",
                        value: 0
                    },
                    uTex: {
                        type: "t",
                        value: t
                    },
                    uMod: {
                        type: "m4",
                        value: a
                    },
                    uData: {
                        type: "fv1",
                        value: Object.values(r)
                    },
                    specularMap: {
                        type: "t",
                        value: l
                    },
                    metalMap: {
                        type: "t",
                        value: u
                    },
                    colorMod: {
                        type: "c",
                        value: new THREE.Color(4938849)
                    },
                    ambientColor: {
                        type: "c",
                        value: new THREE.Color(1052688)
                    },
                    directionalLightColor: {
                        type: "c",
                        value: d
                    },
                    directionalLightDirection: {
                        type: "v3",
                        value: i
                    }
                },
                transparent: !0,
                vertexShader: document.getElementById("vertexShader").textContent,
                fragmentShader: o.shaderCache[n]
            }, c = 0; c < Object.keys(e).length; c++) {
                var h = Object.keys(e)[c];
                s.uniforms[h] = {
                    type: "t",
                    value: e[h]
                }
            }
            return new THREE.ShaderMaterial(s)
        }
        h.applyMatrix((new THREE.Matrix4).makeRotationY(Math.PI));
        var f = new THREE.Mesh(c,p(e, i, O[0], s, I, !1))
          , m = new THREE.Mesh(h,p(n, a, O[1], s, I, !0));
        function g() {
            F = k.clientWidth,
            z = F / 1.5,
            V.setSize(F, z)
        }
        f.rotation.order = "YXZ",
        f.add(m),
        j.add(f),
        g(),
        window.addEventListener("resize", g);
        var v = 1e3
          , y = .1
          , x = 20
          , b = null
          , _ = null
          , w = 0
          , E = !1
          , M = 50
          , T = null
          , S = null
          , A = 0
          , R = 30
          , L = 60;
        function C(t, e, n) {
            for (var i = e.split(" "), r = 0; r < i.length; r++)
                t.addEventListener(i[r], n)
        }
        C(k, "mousedown touchstart", function(t) {
            t.preventDefault(),
            null === b && (b = _ = t.pageX || t.targetTouches[0].pageX,
            M *= .3,
            T = S = t.pageY || t.targetTouches[0].pageY,
            R *= .3)
        }),
        C(P, "mousemove touchmove", function(t) {
            null !== b && (t.preventDefault(),
            _ = t.pageX || t.targetTouches[0].pageX,
            S = t.pageY || t.targetTouches[0].pageY)
        }),
        C(P, "mouseup mouseleave touchend touchcancel", function(t) {
            null !== b && (t.preventDefault(),
            M += (w = _ - b) / 2,
            b = _ = null,
            R += (A = T - S) / 2,
            T = S = null)
        }),
        k.addEventListener("contextmenu", function() {
            return !1
        }),
        G && (console.log("I'm here to FLIP YOUUUUUUUUU"),
        s = "ontouchstart"in document.documentElement ? "touchstart" : "mousedown",
        G.addEventListener(s, function() {
            M = 90 < x ? 220 - x : x - 180
        })),
        function t() {
            var e, n, i;
            null !== b ? (w = (_ - b) / k.clientWidth * v,
            b = _,
            M += w / 2,
            A = (180 < (540 - x % 360) % 360 ? -1 : 1) * (T - S) / k.clientHeight * v / 2,
            T = S,
            R += A / 2) : (.5 < Math.abs(w) ? M += (w *= .75) / 2 : w = 0,
            e = (0 == (e = x) ? 1 : Math.sign(e)) * (80 - Math.abs((x + M) % 180)) * .01,
            w += e),
            0 == M.toFixed(0) && 0 == R.toFixed(0) || (e = M * y,
            i = R * y,
            R && L && Math.sign(R) == Math.sign(L - 90) && (i *= 1 - Math.min(1, Math.abs(L - 90) / 20)),
            M -= e,
            R -= i,
            n = (x += e) - 90 + 180 * E,
            i = (L += i) - 90 + 180 * E,
            f.rotation.y = n / 180 * Math.PI,
            f.rotation.x = (E ? 1 : -1) * i / 180 * Math.PI,
            f.material.uniforms.uDisp.value = m.material.uniforms.uDisp.value = -e / 120 * Math.PI * 2,
            f.material.uniforms.uRot.value = m.material.uniforms.uRot.value = x / 180 * Math.PI,
            f.material.uniforms.uTilt.value = m.material.uniforms.uTilt.value = -i / 180 * Math.PI,
            f.material.uniforms.uEmerald.value = m.material.uniforms.uEmerald.value = I.emeraldNumb),
            D && D(i, n),
            V.render(j, W),
            document.querySelector("div.spinny-image").setAttribute("data-rotation", Math.round(x)),
            H || requestAnimationFrame(t)
        }()
    }),
    {
        destroy: function() {
            H = !0
        }
    }
}
!function() {
    "use strict";
    if ("undefined" != typeof window) {
        var i = -1 !== window.navigator.userAgent.indexOf("Edge/16.");
        if ("objectFit"in document.documentElement.style != 0 && !i)
            return window.objectFitPolyfill = function() {
                return !1
            }
            ;
        var r = function(t) {
            var e, n, i, r, o = t.parentNode;
            e = o,
            n = window.getComputedStyle(e, null),
            i = n.getPropertyValue("position"),
            r = n.getPropertyValue("overflow"),
            n = n.getPropertyValue("display"),
            i && "static" !== i || (e.style.position = "relative"),
            "hidden" !== r && (e.style.overflow = "hidden"),
            n && "inline" !== n || (e.style.display = "block"),
            0 === e.clientHeight && (e.style.height = "100%"),
            -1 === e.className.indexOf("object-fit-polyfill") && (e.className = e.className + " object-fit-polyfill"),
            function(t) {
                var e, n = window.getComputedStyle(t, null), i = {
                    "max-width": "none",
                    "max-height": "none",
                    "min-width": "0px",
                    "min-height": "0px",
                    top: "auto",
                    right: "auto",
                    bottom: "auto",
                    left: "auto",
                    "margin-top": "0px",
                    "margin-right": "0px",
                    "margin-bottom": "0px",
                    "margin-left": "0px"
                };
                for (e in i)
                    n.getPropertyValue(e) !== i[e] && (t.style[e] = i[e])
            }(t),
            t.style.position = "absolute",
            t.style.height = "100%",
            t.style.width = "auto",
            t.clientWidth > o.clientWidth ? (t.style.top = "0",
            t.style.marginTop = "0",
            t.style.left = "50%",
            t.style.marginLeft = t.clientWidth / -2 + "px") : (t.style.width = "100%",
            t.style.height = "auto",
            t.style.left = "0",
            t.style.marginLeft = "0",
            t.style.top = "50%",
            t.style.marginTop = t.clientHeight / -2 + "px")
        }
          , t = function(t) {
            if (void 0 === t)
                t = document.querySelectorAll("[data-object-fit]");
            else if (t && t.nodeName)
                t = [t];
            else if ("object" != typeof t || !t.length || !t[0].nodeName)
                return !1;
            for (var e, n = 0; n < t.length; n++)
                t[n].nodeName && ("img" !== (e = t[n].nodeName.toLowerCase()) || i ? "video" === e && (0 < t[n].readyState ? r(t[n]) : t[n].addEventListener("loadedmetadata", function() {
                    r(this)
                })) : t[n].complete ? r(t[n]) : t[n].addEventListener("load", function() {
                    r(this)
                }));
            return !0
        };
        document.addEventListener("DOMContentLoaded", function() {
            t()
        }),
        window.addEventListener("resize", function() {
            t()
        }),
        window.objectFitPolyfill = t
    }
}(),
Object.values || (Object.values = function(t) {
    for (var e = [], n = Object.keys(t), i = 0; i < n.length; i++)
        e.push(t[n[i]]);
    return e
}
),
String.prototype.startsWith || (String.prototype.startsWith = function(t) {
    return this.substr(0, 1) == t
}
),
function(t, e) {
    "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e(t.THREE = {})
}(this, function(t) {
    function e() {}
    function W(t, e) {
        this.x = t || 0,
        this.y = e || 0
    }
    function _t() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }
    function V(t, e, n, i) {
        this._x = t || 0,
        this._y = e || 0,
        this._z = n || 0,
        this._w = void 0 !== i ? i : 1
    }
    function wt(t, e, n) {
        this.x = t || 0,
        this.y = e || 0,
        this.z = n || 0
    }
    function g() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }
    function d(t, e, n, i, r, o, a, s, c, h) {
        Object.defineProperty(this, "id", {
            value: Uo++
        }),
        this.uuid = io.generateUUID(),
        this.name = "",
        this.image = void 0 !== t ? t : d.DEFAULT_IMAGE,
        this.mipmaps = [],
        this.mapping = void 0 !== e ? e : d.DEFAULT_MAPPING,
        this.wrapS = void 0 !== n ? n : 1001,
        this.wrapT = void 0 !== i ? i : 1001,
        this.magFilter = void 0 !== r ? r : 1006,
        this.minFilter = void 0 !== o ? o : 1008,
        this.anisotropy = void 0 !== c ? c : 1,
        this.format = void 0 !== a ? a : 1023,
        this.type = void 0 !== s ? s : 1009,
        this.offset = new W(0,0),
        this.repeat = new W(1,1),
        this.center = new W(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new g,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.encoding = void 0 !== h ? h : 3e3,
        this.version = 0,
        this.onUpdate = null
    }
    function Et(t, e, n, i) {
        this.x = t || 0,
        this.y = e || 0,
        this.z = n || 0,
        this.w = void 0 !== i ? i : 1
    }
    function S(t, e, n) {
        this.width = t,
        this.height = e,
        this.scissor = new Et(0,0,t,e),
        this.scissorTest = !1,
        this.viewport = new Et(0,0,t,e),
        void 0 === (n = n || {}).minFilter && (n.minFilter = 1006),
        this.texture = new d(void 0,void 0,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),
        this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer,
        this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer,
        this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
    }
    function i(t, e, n) {
        S.call(this, t, e, n),
        this.activeMipMapLevel = this.activeCubeFace = 0
    }
    function Mt(t, e, n, i, r, o, a, s, c, h, l, u) {
        d.call(this, null, o, a, s, c, h, i, r, l, u),
        this.image = {
            data: t,
            width: e,
            height: n
        },
        this.magFilter = void 0 !== c ? c : 1003,
        this.minFilter = void 0 !== h ? h : 1003,
        this.flipY = this.generateMipmaps = !1,
        this.unpackAlignment = 1
    }
    function n(t, e) {
        this.min = void 0 !== t ? t : new wt(1 / 0,1 / 0,1 / 0),
        this.max = void 0 !== e ? e : new wt(-1 / 0,-1 / 0,-1 / 0)
    }
    function a(t, e) {
        this.center = void 0 !== t ? t : new wt,
        this.radius = void 0 !== e ? e : 0
    }
    function v(t, e) {
        this.normal = void 0 !== t ? t : new wt(1,0,0),
        this.constant = void 0 !== e ? e : 0
    }
    function Tt(t, e, n, i, r, o) {
        this.planes = [void 0 !== t ? t : new v, void 0 !== e ? e : new v, void 0 !== n ? n : new v, void 0 !== i ? i : new v, void 0 !== r ? r : new v, void 0 !== o ? o : new v]
    }
    function w(t, e, n) {
        return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
    }
    function St(c) {
        var h = new WeakMap;
        return {
            get: function(t) {
                return t.isInterleavedBufferAttribute && (t = t.data),
                h.get(t)
            },
            remove: function(t) {
                t.isInterleavedBufferAttribute && (t = t.data);
                var e = h.get(t);
                e && (c.deleteBuffer(e.buffer),
                h.delete(t))
            },
            update: function(t, e) {
                t.isInterleavedBufferAttribute && (t = t.data);
                var n, i, r, o, a, s = h.get(t);
                void 0 === s ? h.set(t, (i = e,
                r = (n = t).array,
                o = n.dynamic ? c.DYNAMIC_DRAW : c.STATIC_DRAW,
                a = c.createBuffer(),
                c.bindBuffer(i, a),
                c.bufferData(i, r, o),
                n.onUploadCallback(),
                i = c.FLOAT,
                r instanceof Float32Array ? i = c.FLOAT : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? i = c.UNSIGNED_SHORT : r instanceof Int16Array ? i = c.SHORT : r instanceof Uint32Array ? i = c.UNSIGNED_INT : r instanceof Int32Array ? i = c.INT : r instanceof Int8Array ? i = c.BYTE : r instanceof Uint8Array && (i = c.UNSIGNED_BYTE),
                {
                    buffer: a,
                    type: i,
                    bytesPerElement: r.BYTES_PER_ELEMENT,
                    version: n.version
                })) : s.version < t.version && (r = (i = t).array,
                n = i.updateRange,
                c.bindBuffer(e, s.buffer),
                !1 === i.dynamic ? c.bufferData(e, r, c.STATIC_DRAW) : -1 === n.count ? c.bufferSubData(e, 0, r) : 0 === n.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (c.bufferSubData(e, n.offset * r.BYTES_PER_ELEMENT, r.subarray(n.offset, n.offset + n.count)),
                n.count = -1),
                s.version = t.version)
            }
        }
    }
    function r(t, e, n, i) {
        this._x = t || 0,
        this._y = e || 0,
        this._z = n || 0,
        this._order = i || r.DefaultOrder
    }
    function o() {
        this.mask = 1
    }
    function l() {
        Object.defineProperty(this, "id", {
            value: da++
        }),
        this.uuid = io.generateUUID(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = l.DefaultUp.clone();
        var t = new wt
          , e = new r
          , n = new V
          , i = new wt(1,1,1);
        e.onChange(function() {
            n.setFromEuler(e, !1)
        }),
        n.onChange(function() {
            e.setFromQuaternion(n, void 0, !1)
        }),
        Object.defineProperties(this, {
            position: {
                enumerable: !0,
                value: t
            },
            rotation: {
                enumerable: !0,
                value: e
            },
            quaternion: {
                enumerable: !0,
                value: n
            },
            scale: {
                enumerable: !0,
                value: i
            },
            modelViewMatrix: {
                value: new _t
            },
            normalMatrix: {
                value: new g
            }
        }),
        this.matrix = new _t,
        this.matrixWorld = new _t,
        this.matrixAutoUpdate = l.DefaultMatrixAutoUpdate,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new o,
        this.visible = !0,
        this.receiveShadow = this.castShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.userData = {}
    }
    function s() {
        l.call(this),
        this.type = "Camera",
        this.matrixWorldInverse = new _t,
        this.projectionMatrix = new _t
    }
    function p(t, e, n, i, r, o) {
        s.call(this),
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = t,
        this.right = e,
        this.top = n,
        this.bottom = i,
        this.near = void 0 !== r ? r : .1,
        this.far = void 0 !== o ? o : 2e3,
        this.updateProjectionMatrix()
    }
    function E(t, e, n, i, r, o) {
        this.a = t,
        this.b = e,
        this.c = n,
        this.normal = i && i.isVector3 ? i : new wt,
        this.vertexNormals = Array.isArray(i) ? i : [],
        this.color = r && r.isColor ? r : new w,
        this.vertexColors = Array.isArray(r) ? r : [],
        this.materialIndex = void 0 !== o ? o : 0
    }
    function M() {
        Object.defineProperty(this, "id", {
            value: ba += 2
        }),
        this.uuid = io.generateUUID(),
        this.name = "",
        this.type = "Geometry",
        this.vertices = [],
        this.colors = [],
        this.faces = [],
        this.faceVertexUvs = [[]],
        this.morphTargets = [],
        this.morphNormals = [],
        this.skinWeights = [],
        this.skinIndices = [],
        this.lineDistances = [],
        this.boundingSphere = this.boundingBox = null,
        this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1
    }
    function y(t, e, n) {
        if (Array.isArray(t))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "",
        this.array = t,
        this.itemSize = e,
        this.count = void 0 !== t ? t.length / e : 0,
        this.normalized = !0 === n,
        this.dynamic = !1,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0
    }
    function c(t, e, n) {
        y.call(this, new Int8Array(t), e, n)
    }
    function h(t, e, n) {
        y.call(this, new Uint8Array(t), e, n)
    }
    function u(t, e, n) {
        y.call(this, new Uint8ClampedArray(t), e, n)
    }
    function f(t, e, n) {
        y.call(this, new Int16Array(t), e, n)
    }
    function m(t, e, n) {
        y.call(this, new Uint16Array(t), e, n)
    }
    function x(t, e, n) {
        y.call(this, new Int32Array(t), e, n)
    }
    function b(t, e, n) {
        y.call(this, new Uint32Array(t), e, n)
    }
    function L(t, e, n) {
        y.call(this, new Float32Array(t), e, n)
    }
    function _(t, e, n) {
        y.call(this, new Float64Array(t), e, n)
    }
    function T() {
        this.vertices = [],
        this.normals = [],
        this.colors = [],
        this.uvs = [],
        this.uvs2 = [],
        this.groups = [],
        this.morphTargets = {},
        this.skinWeights = [],
        this.skinIndices = [],
        this.boundingSphere = this.boundingBox = null,
        this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1
    }
    function A(t) {
        if (0 === t.length)
            return -1 / 0;
        for (var e = t[0], n = 1, i = t.length; n < i; ++n)
            t[n] > e && (e = t[n]);
        return e
    }
    function C() {
        Object.defineProperty(this, "id", {
            value: Pa += 2
        }),
        this.uuid = io.generateUUID(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingSphere = this.boundingBox = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        }
    }
    function R(t, e, n, i, r, o) {
        M.call(this),
        this.type = "BoxGeometry",
        this.parameters = {
            width: t,
            height: e,
            depth: n,
            widthSegments: i,
            heightSegments: r,
            depthSegments: o
        },
        this.fromBufferGeometry(new P(t,e,n,i,r,o)),
        this.mergeVertices()
    }
    function P(t, e, n, i, r, o) {
        function a(t, e, n, i, r, o, a, s, c, h, l) {
            var u = o / c
              , d = a / h
              , p = o / 2
              , f = a / 2
              , m = s / 2;
            a = c + 1;
            for (var g = h + 1, v = o = 0, y = new wt, x = 0; x < g; x++)
                for (var b = x * d - f, _ = 0; _ < a; _++)
                    y[t] = (_ * u - p) * i,
                    y[e] = b * r,
                    y[n] = m,
                    M.push(y.x, y.y, y.z),
                    y[t] = 0,
                    y[e] = 0,
                    y[n] = 0 < s ? 1 : -1,
                    T.push(y.x, y.y, y.z),
                    S.push(_ / c),
                    S.push(1 - x / h),
                    o += 1;
            for (x = 0; x < h; x++)
                for (_ = 0; _ < c; _++)
                    t = A + _ + a * (x + 1),
                    e = A + (_ + 1) + a * (x + 1),
                    n = A + (_ + 1) + a * x,
                    E.push(A + _ + a * x, t, n),
                    E.push(t, e, n),
                    v += 6;
            w.addGroup(R, v, l),
            R += v,
            A += o
        }
        C.call(this),
        this.type = "BoxBufferGeometry",
        this.parameters = {
            width: t,
            height: e,
            depth: n,
            widthSegments: i,
            heightSegments: r,
            depthSegments: o
        };
        var w = this;
        t = t || 1,
        e = e || 1,
        n = n || 1,
        i = Math.floor(i) || 1,
        r = Math.floor(r) || 1,
        o = Math.floor(o) || 1;
        var E = []
          , M = []
          , T = []
          , S = []
          , A = 0
          , R = 0;
        a("z", "y", "x", -1, -1, n, e, t, o, r, 0),
        a("z", "y", "x", 1, -1, n, e, -t, o, r, 1),
        a("x", "z", "y", 1, 1, t, n, e, i, o, 2),
        a("x", "z", "y", 1, -1, t, n, -e, i, o, 3),
        a("x", "y", "z", 1, -1, t, e, n, i, r, 4),
        a("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
        this.setIndex(E),
        this.addAttribute("position", new L(M,3)),
        this.addAttribute("normal", new L(T,3)),
        this.addAttribute("uv", new L(S,2))
    }
    function N(t, e, n, i) {
        M.call(this),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: t,
            height: e,
            widthSegments: n,
            heightSegments: i
        },
        this.fromBufferGeometry(new O(t,e,n,i)),
        this.mergeVertices()
    }
    function O(t, e, n, i) {
        C.call(this),
        this.type = "PlaneBufferGeometry",
        this.parameters = {
            width: t,
            height: e,
            widthSegments: n,
            heightSegments: i
        };
        var r = (t = t || 1) / 2
          , o = (e = e || 1) / 2
          , a = (n = Math.floor(n) || 1) + 1
          , s = (i = Math.floor(i) || 1) + 1
          , c = t / n
          , h = e / i
          , l = []
          , u = []
          , d = []
          , p = [];
        for (t = 0; t < s; t++) {
            var f = t * h - o;
            for (e = 0; e < a; e++)
                u.push(e * c - r, -f, 0),
                d.push(0, 0, 1),
                p.push(e / n),
                p.push(1 - t / i)
        }
        for (t = 0; t < i; t++)
            for (e = 0; e < n; e++)
                o = e + 1 + a * (t + 1),
                l.push(e + a * t, r = e + a * (t + 1), s = e + 1 + a * t),
                l.push(r, o, s);
        this.setIndex(l),
        this.addAttribute("position", new L(u,3)),
        this.addAttribute("normal", new L(d,3)),
        this.addAttribute("uv", new L(p,2))
    }
    function I() {
        Object.defineProperty(this, "id", {
            value: vs++
        }),
        this.uuid = io.generateUUID(),
        this.name = "",
        this.type = "Material",
        this.lights = this.fog = !0,
        this.blending = 1,
        this.side = 0,
        this.flatShading = !1,
        this.vertexColors = 0,
        this.opacity = 1,
        this.transparent = !1,
        this.blendSrc = 204,
        this.blendDst = 205,
        this.blendEquation = 100,
        this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null,
        this.depthFunc = 3,
        this.depthWrite = this.depthTest = !0,
        this.clippingPlanes = null,
        this.clipShadows = this.clipIntersection = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetUnits = this.polygonOffsetFactor = 0,
        this.dithering = !1,
        this.alphaTest = 0,
        this.premultipliedAlpha = !1,
        this.overdraw = 0,
        this.visible = !0,
        this.userData = {},
        this.needsUpdate = !0
    }
    function B(t) {
        I.call(this),
        this.type = "MeshBasicMaterial",
        this.color = new w(16777215),
        this.lightMap = this.map = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.envMap = this.alphaMap = this.specularMap = null,
        this.combine = 0,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinejoin = this.wireframeLinecap = "round",
        this.lights = this.morphTargets = this.skinning = !1,
        this.setValues(t)
    }
    function U(t) {
        I.call(this),
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1,
        this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),
        this.setValues(t))
    }
    function D(t, e) {
        this.origin = void 0 !== t ? t : new wt,
        this.direction = void 0 !== e ? e : new wt
    }
    function F(t, e) {
        this.start = void 0 !== t ? t : new wt,
        this.end = void 0 !== e ? e : new wt
    }
    function z(t, e, n) {
        this.a = void 0 !== t ? t : new wt,
        this.b = void 0 !== e ? e : new wt,
        this.c = void 0 !== n ? n : new wt
    }
    function H(t, e) {
        l.call(this),
        this.type = "Mesh",
        this.geometry = void 0 !== t ? t : new C,
        this.material = void 0 !== e ? e : new B({
            color: 16777215 * Math.random()
        }),
        this.drawMode = 0,
        this.updateMorphTargets()
    }
    function At(r, n, o, i) {
        function a(t, e) {
            n.buffers.color.setClear(t.r, t.g, t.b, e, i)
        }
        var s, c, h, l = new w(0), u = 0;
        return {
            getClearColor: function() {
                return l
            },
            setClearColor: function(t, e) {
                l.set(t),
                a(l, u = void 0 !== e ? e : 1)
            },
            getClearAlpha: function() {
                return u
            },
            setClearAlpha: function(t) {
                a(l, u = t)
            },
            render: function(t, e, n, i) {
                null === (e = e.background) ? a(l, u) : e && e.isColor && (a(e, 1),
                i = !0),
                (r.autoClear || i) && r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil),
                e && e.isCubeTexture ? (void 0 === h && ((h = new H(new P(1,1,1),new U({
                    uniforms: qo.cube.uniforms,
                    vertexShader: qo.cube.vertexShader,
                    fragmentShader: qo.cube.fragmentShader,
                    side: 1,
                    depthTest: !0,
                    depthWrite: !1,
                    fog: !1
                }))).geometry.removeAttribute("normal"),
                h.geometry.removeAttribute("uv"),
                h.onBeforeRender = function(t, e, n) {
                    this.matrixWorld.copyPosition(n.matrixWorld)
                }
                ,
                o.update(h.geometry)),
                h.material.uniforms.tCube.value = e,
                t.push(h, h.geometry, h.material, 0, null)) : e && e.isTexture && (void 0 === s && (s = new p(-1,1,1,-1,0,1),
                c = new H(new O(2,2),new B({
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })),
                o.update(c.geometry)),
                c.material.map = e,
                r.renderBufferDirect(s, null, c.geometry, c.material, c, null))
            }
        }
    }
    function Rt(n, o, a) {
        var s;
        this.setMode = function(t) {
            s = t
        }
        ,
        this.render = function(t, e) {
            n.drawArrays(s, t, e),
            a.update(e, s)
        }
        ,
        this.renderInstances = function(t, e, n) {
            var i, r = o.get("ANGLE_instanced_arrays");
            null === r ? console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") : ((i = t.attributes.position).isInterleavedBufferAttribute ? (n = i.data.count,
            r.drawArraysInstancedANGLE(s, 0, n, t.maxInstancedCount)) : r.drawArraysInstancedANGLE(s, e, n, t.maxInstancedCount),
            a.update(n, s, t.maxInstancedCount))
        }
    }
    function Lt(e, n, t) {
        function i(t) {
            if ("highp" === t) {
                if (0 < e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision && 0 < e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision)
                    return "highp";
                t = "mediump"
            }
            return "mediump" === t && 0 < e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision && 0 < e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision ? "mediump" : "lowp"
        }
        var r, o = void 0 !== t.precision ? t.precision : "highp";
        (a = i(o)) !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", a, "instead."),
        o = a),
        t = !0 === t.logarithmicDepthBuffer;
        var a = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)
          , s = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
          , c = e.getParameter(e.MAX_TEXTURE_SIZE)
          , h = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE)
          , l = e.getParameter(e.MAX_VERTEX_ATTRIBS)
          , u = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS)
          , d = e.getParameter(e.MAX_VARYING_VECTORS)
          , p = e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS)
          , f = 0 < s
          , m = !!n.get("OES_texture_float");
        return {
            getMaxAnisotropy: function() {
                if (void 0 !== r)
                    return r;
                var t = n.get("EXT_texture_filter_anisotropic");
                return r = null !== t ? e.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
            },
            getMaxPrecision: i,
            precision: o,
            logarithmicDepthBuffer: t,
            maxTextures: a,
            maxVertexTextures: s,
            maxTextureSize: c,
            maxCubemapSize: h,
            maxAttributes: l,
            maxVertexUniforms: u,
            maxVaryings: d,
            maxFragmentUniforms: p,
            vertexTextures: f,
            floatFragmentTextures: m,
            floatVertexTextures: f && m
        }
    }
    function Ct() {
        function c() {
            m.value !== l && (m.value = l,
            m.needsUpdate = 0 < u),
            a.numPlanes = u,
            a.numIntersection = 0
        }
        function h(t, e, n, i) {
            var r = null !== t ? t.length : 0
              , o = null;
            if (0 !== r) {
                if (o = m.value,
                !0 !== i || null === o)
                    for (i = n + 4 * r,
                    e = e.matrixWorldInverse,
                    f.getNormalMatrix(e),
                    (null === o || o.length < i) && (o = new Float32Array(i)),
                    i = 0; i !== r; ++i,
                    n += 4)
                        s.copy(t[i]).applyMatrix4(e, f),
                        s.normal.toArray(o, n),
                        o[n + 3] = s.constant;
                m.value = o,
                m.needsUpdate = !0
            }
            return a.numPlanes = r,
            o
        }
        var a = this
          , l = null
          , u = 0
          , d = !1
          , p = !1
          , s = new v
          , f = new g
          , m = {
            value: null,
            needsUpdate: !1
        };
        this.uniform = m,
        this.numIntersection = this.numPlanes = 0,
        this.init = function(t, e, n) {
            var i = 0 !== t.length || e || 0 !== u || d;
            return d = e,
            l = h(t, n, 0),
            u = t.length,
            i
        }
        ,
        this.beginShadows = function() {
            p = !0,
            h(null)
        }
        ,
        this.endShadows = function() {
            p = !1,
            c()
        }
        ,
        this.setState = function(t, e, n, i, r, o) {
            if (!d || null === t || 0 === t.length || p && !n)
                p ? h(null) : c();
            else {
                var a = 4 * (n = p ? 0 : u)
                  , s = r.clippingState || null;
                for (m.value = s,
                s = h(t, i, a, o),
                t = 0; t !== a; ++t)
                    s[t] = l[t];
                r.clippingState = s,
                this.numIntersection = e ? this.numPlanes : 0,
                this.numPlanes += n
            }
        }
    }
    function Pt(n) {
        var i = {};
        return {
            get: function(t) {
                if (void 0 !== i[t])
                    return i[t];
                switch (t) {
                case "WEBGL_depth_texture":
                    var e = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    e = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    e = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    e = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    e = n.getExtension(t)
                }
                return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."),
                i[t] = e
            }
        }
    }
    function Nt(c, h, i) {
        function r(t) {
            t = t.target;
            var e, n = o[t.id];
            for (e in null !== n.index && h.remove(n.index),
            n.attributes)
                h.remove(n.attributes[e]);
            t.removeEventListener("dispose", r),
            delete o[t.id],
            (e = l[t.id]) && (h.remove(e),
            delete l[t.id]),
            (e = l[n.id]) && (h.remove(e),
            delete l[n.id]),
            i.memory.geometries--
        }
        var o = {}
          , l = {};
        return {
            get: function(t, e) {
                var n = o[e.id];
                return n || (e.addEventListener("dispose", r),
                e.isBufferGeometry ? n = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new C).setFromObject(t)),
                n = e._bufferGeometry),
                o[e.id] = n,
                i.memory.geometries++,
                n)
            },
            update: function(t) {
                var e, n = t.index, i = t.attributes;
                for (e in null !== n && h.update(n, c.ELEMENT_ARRAY_BUFFER),
                i)
                    h.update(i[e], c.ARRAY_BUFFER);
                for (e in t = t.morphAttributes)
                    for (var i = 0, r = (n = t[e]).length; i < r; i++)
                        h.update(n[i], c.ARRAY_BUFFER)
            },
            getWireframeAttribute: function(t) {
                if (e = l[t.id])
                    return e;
                var e = []
                  , n = t.index
                  , i = t.attributes;
                if (null !== n)
                    for (var i = 0, r = (n = n.array).length; i < r; i += 3) {
                        var o = n[i + 0]
                          , a = n[i + 1]
                          , s = n[i + 2];
                        e.push(o, a, a, s, s, o)
                    }
                else
                    for (n = i.position.array,
                    i = 0,
                    r = n.length / 3 - 1; i < r; i += 3)
                        e.push(o = i + 0, a = i + 1, a, s = i + 2, s, o);
                return e = new (65535 < A(e) ? b : m)(e,1),
                h.update(e, c.ELEMENT_ARRAY_BUFFER),
                l[t.id] = e
            }
        }
    }
    function Ot(n, r, o) {
        var a, s, c;
        this.setMode = function(t) {
            a = t
        }
        ,
        this.setIndex = function(t) {
            s = t.type,
            c = t.bytesPerElement
        }
        ,
        this.render = function(t, e) {
            n.drawElements(a, e, s, t * c),
            o.update(e, a)
        }
        ,
        this.renderInstances = function(t, e, n) {
            var i = r.get("ANGLE_instanced_arrays");
            null === i ? console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") : (i.drawElementsInstancedANGLE(a, n, s, e * c, t.maxInstancedCount),
            o.update(n, a, t.maxInstancedCount))
        }
    }
    function It(i) {
        var r = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        return {
            memory: {
                geometries: 0,
                textures: 0
            },
            render: r,
            programs: null,
            autoReset: !0,
            reset: function() {
                r.frame++,
                r.calls = 0,
                r.triangles = 0,
                r.points = 0,
                r.lines = 0
            },
            update: function(t, e, n) {
                switch (n = n || 1,
                r.calls++,
                e) {
                case i.TRIANGLES:
                    r.triangles += t / 3 * n;
                    break;
                case i.TRIANGLE_STRIP:
                case i.TRIANGLE_FAN:
                    r.triangles += n * (t - 2);
                    break;
                case i.LINES:
                    r.lines += t / 2 * n;
                    break;
                case i.LINE_STRIP:
                    r.lines += n * (t - 1);
                    break;
                case i.LINE_LOOP:
                    r.lines += n * t;
                    break;
                case i.POINTS:
                    r.points += n * t;
                    break;
                default:
                    console.error("THREE.WebGLInfo: Unknown draw mode:", e)
                }
            }
        }
    }
    function G(t, e) {
        return Math.abs(e[1]) - Math.abs(t[1])
    }
    function Bt(h) {
        var l = {}
          , u = new Float32Array(8);
        return {
            update: function(t, e, n, i) {
                var r = t.morphTargetInfluences
                  , o = r.length;
                if (void 0 === (t = l[e.id])) {
                    t = [];
                    for (var a = 0; a < o; a++)
                        t[a] = [a, 0];
                    l[e.id] = t
                }
                var s = n.morphTargets && e.morphAttributes.position;
                for (n = n.morphNormals && e.morphAttributes.normal,
                a = 0; a < o; a++) {
                    var c = t[a];
                    0 !== c[1] && (s && e.removeAttribute("morphTarget" + a),
                    n && e.removeAttribute("morphNormal" + a))
                }
                for (a = 0; a < o; a++)
                    (c = t[a])[0] = a,
                    c[1] = r[a];
                for (t.sort(G),
                a = 0; a < 8; a++)
                    (c = t[a]) && (r = c[0],
                    o = c[1]) ? (s && e.addAttribute("morphTarget" + a, s[r]),
                    n && e.addAttribute("morphNormal" + a, n[r]),
                    u[a] = o) : u[a] = 0;
                i.getUniforms().setValue(h, "morphTargetInfluences", u)
            }
        }
    }
    function Ut(r, o) {
        var a = {};
        return {
            update: function(t) {
                var e = o.render.frame
                  , n = t.geometry
                  , i = r.get(t, n);
                return a[i.id] !== e && (n.isGeometry && i.updateFromObject(t),
                r.update(i),
                a[i.id] = e),
                i
            },
            dispose: function() {
                a = {}
            }
        }
    }
    function k(t, e, n, i, r, o, a, s, c, h) {
        d.call(this, t = void 0 !== t ? t : [], void 0 !== e ? e : 301, n, i, r, o, a, s, c, h),
        this.flipY = !1
    }
    function j(t, e, n) {
        var i = t[0];
        if (i <= 0 || 0 < i)
            return t;
        var r = e * n
          , o = Es[r];
        if (void 0 === o && (o = new Float32Array(r),
        Es[r] = o),
        0 !== e)
            for (i.toArray(o, 0),
            i = 1,
            r = 0; i !== e; ++i)
                t[i].toArray(o, r += n);
        return o
    }
    function X(t, e) {
        var n = Ms[e];
        void 0 === n && (n = new Int32Array(e),
        Ms[e] = n);
        for (var i = 0; i !== e; ++i)
            n[i] = t.allocTextureUnit();
        return n
    }
    function q(t, e) {
        t.uniform1f(this.addr, e)
    }
    function Y(t, e) {
        t.uniform1i(this.addr, e)
    }
    function Z(t, e) {
        void 0 === e.x ? t.uniform2fv(this.addr, e) : t.uniform2f(this.addr, e.x, e.y)
    }
    function J(t, e) {
        void 0 !== e.x ? t.uniform3f(this.addr, e.x, e.y, e.z) : void 0 !== e.r ? t.uniform3f(this.addr, e.r, e.g, e.b) : t.uniform3fv(this.addr, e)
    }
    function Q(t, e) {
        void 0 === e.x ? t.uniform4fv(this.addr, e) : t.uniform4f(this.addr, e.x, e.y, e.z, e.w)
    }
    function K(t, e) {
        t.uniformMatrix2fv(this.addr, !1, e.elements || e)
    }
    function $(t, e) {
        void 0 === e.elements ? t.uniformMatrix3fv(this.addr, !1, e) : (Ss.set(e.elements),
        t.uniformMatrix3fv(this.addr, !1, Ss))
    }
    function tt(t, e) {
        void 0 === e.elements ? t.uniformMatrix4fv(this.addr, !1, e) : (Ts.set(e.elements),
        t.uniformMatrix4fv(this.addr, !1, Ts))
    }
    function et(t, e, n) {
        var i = n.allocTextureUnit();
        t.uniform1i(this.addr, i),
        n.setTexture2D(e || _s, i)
    }
    function nt(t, e, n) {
        var i = n.allocTextureUnit();
        t.uniform1i(this.addr, i),
        n.setTextureCube(e || ws, i)
    }
    function it(t, e) {
        t.uniform2iv(this.addr, e)
    }
    function rt(t, e) {
        t.uniform3iv(this.addr, e)
    }
    function ot(t, e) {
        t.uniform4iv(this.addr, e)
    }
    function at(t, e) {
        t.uniform1fv(this.addr, e)
    }
    function st(t, e) {
        t.uniform1iv(this.addr, e)
    }
    function ct(t, e) {
        t.uniform2fv(this.addr, j(e, this.size, 2))
    }
    function ht(t, e) {
        t.uniform3fv(this.addr, j(e, this.size, 3))
    }
    function lt(t, e) {
        t.uniform4fv(this.addr, j(e, this.size, 4))
    }
    function ut(t, e) {
        t.uniformMatrix2fv(this.addr, !1, j(e, this.size, 4))
    }
    function dt(t, e) {
        t.uniformMatrix3fv(this.addr, !1, j(e, this.size, 9))
    }
    function pt(t, e) {
        t.uniformMatrix4fv(this.addr, !1, j(e, this.size, 16))
    }
    function ft(t, e, n) {
        var i = e.length
          , r = X(n, i);
        for (t.uniform1iv(this.addr, r),
        t = 0; t !== i; ++t)
            n.setTexture2D(e[t] || _s, r[t])
    }
    function mt(t, e, n) {
        var i = e.length
          , r = X(n, i);
        for (t.uniform1iv(this.addr, r),
        t = 0; t !== i; ++t)
            n.setTextureCube(e[t] || ws, r[t])
    }
    function gt(t, e, n) {
        this.id = t,
        this.addr = n,
        this.setValue = function(t) {
            switch (t) {
            case 5126:
                return q;
            case 35664:
                return Z;
            case 35665:
                return J;
            case 35666:
                return Q;
            case 35674:
                return K;
            case 35675:
                return $;
            case 35676:
                return tt;
            case 35678:
            case 36198:
                return et;
            case 35680:
                return nt;
            case 5124:
            case 35670:
                return Y;
            case 35667:
            case 35671:
                return it;
            case 35668:
            case 35672:
                return rt;
            case 35669:
            case 35673:
                return ot
            }
        }(e.type)
    }
    function vt(t, e, n) {
        this.id = t,
        this.addr = n,
        this.size = e.size,
        this.setValue = function(t) {
            switch (t) {
            case 5126:
                return at;
            case 35664:
                return ct;
            case 35665:
                return ht;
            case 35666:
                return lt;
            case 35674:
                return ut;
            case 35675:
                return dt;
            case 35676:
                return pt;
            case 35678:
                return ft;
            case 35680:
                return mt;
            case 5124:
            case 35670:
                return st;
            case 35667:
            case 35671:
                return it;
            case 35668:
            case 35672:
                return rt;
            case 35669:
            case 35673:
                return ot
            }
        }(e.type)
    }
    function yt(t) {
        this.id = t,
        this.seq = [],
        this.map = {}
    }
    function Dt(t, e, n) {
        this.seq = [],
        this.map = {},
        this.renderer = n,
        n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
        for (var i = 0; i < n; ++i) {
            var r = t.getActiveUniform(e, i)
              , o = t.getUniformLocation(e, r.name)
              , a = this
              , s = r.name
              , c = s.length;
            for (As.lastIndex = 0; ; ) {
                var h = As.exec(s)
                  , l = As.lastIndex
                  , u = h[1]
                  , d = h[3];
                if ("]" === h[2] && (u |= 0),
                void 0 === d || "[" === d && l + 2 === c) {
                    s = a,
                    r = new (void 0 === d ? gt : vt)(u,r,o),
                    s.seq.push(r),
                    s.map[r.id] = r;
                    break
                }
                void 0 === (d = a.map[u]) && (d = new yt(u),
                u = a,
                a = d,
                u.seq.push(a),
                u.map[a.id] = a),
                a = d
            }
        }
    }
    function xt(t, e, n) {
        var i = t.createShader(e);
        return t.shaderSource(i, n),
        t.compileShader(i),
        !1 === t.getShaderParameter(i, t.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."),
        "" !== t.getShaderInfoLog(i) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", e === t.VERTEX_SHADER ? "vertex" : "fragment", t.getShaderInfoLog(i), function(t) {
            t = t.split("\n");
            for (var e = 0; e < t.length; e++)
                t[e] = e + 1 + ": " + t[e];
            return t.join("\n")
        }(n)),
        i
    }
    function bt(t) {
        switch (t) {
        case 3e3:
            return ["Linear", "( value )"];
        case 3001:
            return ["sRGB", "( value )"];
        case 3002:
            return ["RGBE", "( value )"];
        case 3004:
            return ["RGBM", "( value, 7.0 )"];
        case 3005:
            return ["RGBM", "( value, 16.0 )"];
        case 3006:
            return ["RGBD", "( value, 256.0 )"];
        case 3007:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        default:
            throw Error("unsupported encoding: " + t)
        }
    }
    function Ft(t, e) {
        return "vec4 " + t + "( vec4 value ) { return " + (e = bt(e))[0] + "ToLinear" + e[1] + "; }"
    }
    function zt(t) {
        return "" !== t
    }
    function Ht(t, e) {
        return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    }
    function Gt(t, e) {
        return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
    }
    function kt(t) {
        return t.replace(/^[ \t]*#include +<([\w\d.]+)>/gm, function(t, e) {
            if (void 0 === (t = Ho[e]))
                throw Error("Can not resolve #include <" + e + ">");
            return kt(t)
        })
    }
    function Vt(t) {
        return t.replace(/#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(t, e, n, i) {
            for (t = "",
            e = parseInt(e); e < parseInt(n); e++)
                t += i.replace(/\[ i \]/g, "[ " + e + " ]");
            return t
        })
    }
    function jt(t, e, n, i, r, o) {
        var a = t.context
          , s = i.defines
          , c = r.vertexShader
          , h = r.fragmentShader
          , l = "SHADOWMAP_TYPE_BASIC";
        1 === o.shadowMapType ? l = "SHADOWMAP_TYPE_PCF" : 2 === o.shadowMapType && (l = "SHADOWMAP_TYPE_PCF_SOFT");
        var u = "ENVMAP_TYPE_CUBE"
          , d = "ENVMAP_MODE_REFLECTION"
          , p = "ENVMAP_BLENDING_MULTIPLY";
        if (o.envMap) {
            switch (i.envMap.mapping) {
            case 301:
            case 302:
                u = "ENVMAP_TYPE_CUBE";
                break;
            case 306:
            case 307:
                u = "ENVMAP_TYPE_CUBE_UV";
                break;
            case 303:
            case 304:
                u = "ENVMAP_TYPE_EQUIREC";
                break;
            case 305:
                u = "ENVMAP_TYPE_SPHERE"
            }
            switch (i.envMap.mapping) {
            case 302:
            case 304:
                d = "ENVMAP_MODE_REFRACTION"
            }
            switch (i.combine) {
            case 0:
                p = "ENVMAP_BLENDING_MULTIPLY";
                break;
            case 1:
                p = "ENVMAP_BLENDING_MIX";
                break;
            case 2:
                p = "ENVMAP_BLENDING_ADD"
            }
        }
        var f, m, g, v, y, x = 0 < t.gammaFactor ? t.gammaFactor : 1, m = (f = i.extensions,
        m = o,
        g = e,
        [(f = f || {}).derivatives || m.envMapCubeUV || m.bumpMap || m.normalMap || m.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (f.fragDepth || m.logarithmicDepthBuffer) && g.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", f.drawBuffers && g.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (f.shaderTextureLOD || m.envMap) && g.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(zt).join("\n")), g = function(t) {
            var e, n = [];
            for (e in t) {
                var i = t[e];
                !1 !== i && n.push("#define " + e + " " + i)
            }
            return n.join("\n")
        }(s), b = a.createProgram();
        return i.isRawShaderMaterial ? (0 < (s = [g].filter(zt).join("\n")).length && (s += "\n"),
        0 < (e = [m, g].filter(zt).join("\n")).length && (e += "\n")) : (s = ["precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + r.name, g, o.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + x, "#define MAX_BONES " + o.maxBones, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + d : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.displacementMap && o.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexColors ? "#define USE_COLOR" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.skinning ? "#define USE_SKINNING" : "", o.useVertexTexture ? "#define BONE_TEXTURE" : "", o.morphTargets ? "#define USE_MORPHTARGETS" : "", o.morphNormals && !1 === o.flatShading ? "#define USE_MORPHNORMALS" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + l : "", o.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && e.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(zt).join("\n"),
        e = [m, "precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + r.name, g, o.alphaTest ? "#define ALPHATEST " + o.alphaTest : "", "#define GAMMA_FACTOR " + x, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + u : "", o.envMap ? "#define " + d : "", o.envMap ? "#define " + p : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexColors ? "#define USE_COLOR" : "", o.gradientMap ? "#define USE_GRADIENTMAP" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + l : "", o.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", o.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && e.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", o.envMap && e.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== o.toneMapping ? "#define TONE_MAPPING" : "", 0 !== o.toneMapping ? Ho.tonemapping_pars_fragment : "", 0 !== o.toneMapping ? function(t, e) {
            switch (e) {
            case 1:
                e = "Linear";
                break;
            case 2:
                e = "Reinhard";
                break;
            case 3:
                e = "Uncharted2";
                break;
            case 4:
                e = "OptimizedCineon";
                break;
            default:
                throw Error("unsupported toneMapping: " + e)
            }
            return "vec3 " + t + "( vec3 color ) { return " + e + "ToneMapping( color ); }"
        }("toneMapping", o.toneMapping) : "", o.dithering ? "#define DITHERING" : "", o.outputEncoding || o.mapEncoding || o.envMapEncoding || o.emissiveMapEncoding ? Ho.encodings_pars_fragment : "", o.mapEncoding ? Ft("mapTexelToLinear", o.mapEncoding) : "", o.envMapEncoding ? Ft("envMapTexelToLinear", o.envMapEncoding) : "", o.emissiveMapEncoding ? Ft("emissiveMapTexelToLinear", o.emissiveMapEncoding) : "", o.outputEncoding ? (g = "linearToOutputTexel",
        x = o.outputEncoding,
        "vec4 " + g + "( vec4 value ) { return LinearTo" + (x = bt(x))[0] + x[1] + "; }") : "", o.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(zt).join("\n")),
        c = Gt(Ht(kt(c), o), o),
        h = Gt(Ht(kt(h), o), o),
        c = Vt(c),
        h = e + Vt(h),
        c = xt(a, a.VERTEX_SHADER, s + c),
        h = xt(a, a.FRAGMENT_SHADER, h),
        a.attachShader(b, c),
        a.attachShader(b, h),
        void 0 !== i.index0AttributeName ? a.bindAttribLocation(b, 0, i.index0AttributeName) : !0 === o.morphTargets && a.bindAttribLocation(b, 0, "position"),
        a.linkProgram(b),
        o = a.getProgramInfoLog(b).trim(),
        l = a.getShaderInfoLog(c).trim(),
        u = a.getShaderInfoLog(h).trim(),
        !(p = d = !0) === a.getProgramParameter(b, a.LINK_STATUS) ? (d = !1,
        console.error("THREE.WebGLProgram: shader error: ", a.getError(), "gl.VALIDATE_STATUS", a.getProgramParameter(b, a.VALIDATE_STATUS), "gl.getProgramInfoLog", o, l, u)) : "" !== o ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", o) : "" !== l && "" !== u || (p = !1),
        p && (this.diagnostics = {
            runnable: d,
            material: i,
            programLog: o,
            vertexShader: {
                log: l,
                prefix: s
            },
            fragmentShader: {
                log: u,
                prefix: e
            }
        }),
        a.deleteShader(c),
        a.deleteShader(h),
        this.getUniforms = function() {
            return v = void 0 === v ? new Dt(a,b,t) : v
        }
        ,
        this.getAttributes = function() {
            if (void 0 === y) {
                for (var t = {}, e = a.getProgramParameter(b, a.ACTIVE_ATTRIBUTES), n = 0; n < e; n++) {
                    var i = a.getActiveAttrib(b, n).name;
                    t[i] = a.getAttribLocation(b, i)
                }
                y = t
            }
            return y
        }
        ,
        this.destroy = function() {
            a.deleteProgram(b),
            this.program = void 0
        }
        ,
        Object.defineProperties(this, {
            uniforms: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."),
                    this.getUniforms()
                }
            },
            attributes: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."),
                    this.getAttributes()
                }
            }
        }),
        this.name = r.name,
        this.id = Xs++,
        this.code = n,
        this.usedTimes = 1,
        this.program = b,
        this.vertexShader = c,
        this.fragmentShader = h,
        this
    }
    function Wt(u, c, d) {
        function p(t, e) {
            var n;
            return t ? t.isTexture ? n = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),
            n = t.texture.encoding) : n = 3e3,
            n = 3e3 === n && e ? 3007 : n
        }
        var h = []
          , f = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "phong",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow"
        }
          , r = "precision supportsVertexTextures map mapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering".split(" ");
        this.getParameters = function(t, e, n, i, r, o, a) {
            var s, c, h = f[t.type];
            c = a.isSkinnedMesh ? (c = a.skeleton.bones,
            d.floatVertexTextures ? 1024 : (s = Math.min(Math.floor((d.maxVertexUniforms - 20) / 4), c.length)) < c.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + c.length + " bones. This GPU supports " + s + "."),
            0) : s) : 0,
            s = d.precision,
            null === t.precision || (s = d.getMaxPrecision(t.precision)) !== t.precision && console.warn("THREE.WebGLProgram.getParameters:", t.precision, "not supported, using", s, "instead.");
            var l = u.getRenderTarget();
            return {
                shaderID: h,
                precision: s,
                supportsVertexTextures: d.vertexTextures,
                outputEncoding: p(l ? l.texture : null, u.gammaOutput),
                map: !!t.map,
                mapEncoding: p(t.map, u.gammaInput),
                envMap: !!t.envMap,
                envMapMode: t.envMap && t.envMap.mapping,
                envMapEncoding: p(t.envMap, u.gammaInput),
                envMapCubeUV: !!t.envMap && (306 === t.envMap.mapping || 307 === t.envMap.mapping),
                lightMap: !!t.lightMap,
                aoMap: !!t.aoMap,
                emissiveMap: !!t.emissiveMap,
                emissiveMapEncoding: p(t.emissiveMap, u.gammaInput),
                bumpMap: !!t.bumpMap,
                normalMap: !!t.normalMap,
                displacementMap: !!t.displacementMap,
                roughnessMap: !!t.roughnessMap,
                metalnessMap: !!t.metalnessMap,
                specularMap: !!t.specularMap,
                alphaMap: !!t.alphaMap,
                gradientMap: !!t.gradientMap,
                combine: t.combine,
                vertexColors: t.vertexColors,
                fog: !!i,
                useFog: t.fog,
                fogExp: i && i.isFogExp2,
                flatShading: t.flatShading,
                sizeAttenuation: t.sizeAttenuation,
                logarithmicDepthBuffer: d.logarithmicDepthBuffer,
                skinning: t.skinning && 0 < c,
                maxBones: c,
                useVertexTexture: d.floatVertexTextures,
                morphTargets: t.morphTargets,
                morphNormals: t.morphNormals,
                maxMorphTargets: u.maxMorphTargets,
                maxMorphNormals: u.maxMorphNormals,
                numDirLights: e.directional.length,
                numPointLights: e.point.length,
                numSpotLights: e.spot.length,
                numRectAreaLights: e.rectArea.length,
                numHemiLights: e.hemi.length,
                numClippingPlanes: r,
                numClipIntersection: o,
                dithering: t.dithering,
                shadowMapEnabled: u.shadowMap.enabled && a.receiveShadow && 0 < n.length,
                shadowMapType: u.shadowMap.type,
                toneMapping: u.toneMapping,
                physicallyCorrectLights: u.physicallyCorrectLights,
                premultipliedAlpha: t.premultipliedAlpha,
                alphaTest: t.alphaTest,
                doubleSided: 2 === t.side,
                flipSided: 1 === t.side,
                depthPacking: void 0 !== t.depthPacking && t.depthPacking
            }
        }
        ,
        this.getProgramCode = function(t, e) {
            var n = [];
            if (e.shaderID ? n.push(e.shaderID) : (n.push(t.fragmentShader),
            n.push(t.vertexShader)),
            void 0 !== t.defines)
                for (var i in t.defines)
                    n.push(i),
                    n.push(t.defines[i]);
            for (i = 0; i < r.length; i++)
                n.push(e[r[i]]);
            return n.push(t.onBeforeCompile.toString()),
            n.push(u.gammaOutput),
            n.join()
        }
        ,
        this.acquireProgram = function(t, e, n, i) {
            for (var r, o = 0, a = h.length; o < a; o++) {
                var s = h[o];
                if (s.code === i) {
                    ++(r = s).usedTimes;
                    break
                }
            }
            return void 0 === r && (r = new jt(u,c,i,t,e,n),
            h.push(r)),
            r
        }
        ,
        this.releaseProgram = function(t) {
            var e;
            0 == --t.usedTimes && (e = h.indexOf(t),
            h[e] = h[h.length - 1],
            h.pop(),
            t.destroy())
        }
        ,
        this.programs = h
    }
    function Xt() {
        var i = new WeakMap;
        return {
            get: function(t) {
                var e = i.get(t);
                return void 0 === e && i.set(t, e = {}),
                e
            },
            remove: function(t) {
                i.delete(t)
            },
            update: function(t, e, n) {
                i.get(t)[e] = n
            },
            dispose: function() {
                i = new WeakMap
            }
        }
    }
    function qt(t, e) {
        return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program && e.program && t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
    }
    function Yt(t, e) {
        return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
    }
    function Zt() {
        var a = []
          , s = 0
          , c = []
          , h = [];
        return {
            opaque: c,
            transparent: h,
            init: function() {
                s = 0,
                c.length = 0,
                h.length = 0
            },
            push: function(t, e, n, i, r) {
                var o = a[s];
                void 0 === o ? (o = {
                    id: t.id,
                    object: t,
                    geometry: e,
                    material: n,
                    program: n.program,
                    renderOrder: t.renderOrder,
                    z: i,
                    group: r
                },
                a[s] = o) : (o.id = t.id,
                o.object = t,
                o.geometry = e,
                o.material = n,
                o.program = n.program,
                o.renderOrder = t.renderOrder,
                o.z = i,
                o.group = r),
                (!0 === n.transparent ? h : c).push(o),
                s++
            },
            sort: function() {
                1 < c.length && c.sort(qt),
                1 < h.length && h.sort(Yt)
            }
        }
    }
    function Jt() {
        var n = {};
        return {
            get: function(t, e) {
                return t = t.id + "," + e.id,
                void 0 === (e = n[t]) && (e = new Zt,
                n[t] = e),
                e
            },
            dispose: function() {
                n = {}
            }
        }
    }
    function Qt() {
        var n = {};
        return {
            get: function(t) {
                if (void 0 !== n[t.id])
                    return n[t.id];
                switch (t.type) {
                case "DirectionalLight":
                    var e = {
                        direction: new wt,
                        color: new w,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new W
                    };
                    break;
                case "SpotLight":
                    e = {
                        position: new wt,
                        direction: new wt,
                        color: new w,
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new W
                    };
                    break;
                case "PointLight":
                    e = {
                        position: new wt,
                        color: new w,
                        distance: 0,
                        decay: 0,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new W,
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3
                    };
                    break;
                case "HemisphereLight":
                    e = {
                        direction: new wt,
                        skyColor: new w,
                        groundColor: new w
                    };
                    break;
                case "RectAreaLight":
                    e = {
                        color: new w,
                        position: new wt,
                        halfWidth: new wt,
                        halfHeight: new wt
                    }
                }
                return n[t.id] = e
            }
        }
    }
    function Kt() {
        var x = new Qt
          , b = {
            id: qs++,
            hash: "",
            ambient: [0, 0, 0],
            directional: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            point: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: []
        }
          , _ = new wt
          , w = new _t
          , E = new _t;
        return {
            setup: function(t, e, n) {
                var i = 0
                  , r = 0
                  , o = 0
                  , a = 0
                  , s = 0
                  , c = 0
                  , h = 0
                  , l = 0;
                n = n.matrixWorldInverse;
                for (var u = 0, d = t.length; u < d; u++) {
                    var p, f = t[u], m = f.color, g = f.intensity, v = f.distance, y = f.shadow && f.shadow.map ? f.shadow.map.texture : null;
                    f.isAmbientLight ? (i += m.r * g,
                    r += m.g * g,
                    o += m.b * g) : f.isDirectionalLight ? ((p = x.get(f)).color.copy(f.color).multiplyScalar(f.intensity),
                    p.direction.setFromMatrixPosition(f.matrixWorld),
                    _.setFromMatrixPosition(f.target.matrixWorld),
                    p.direction.sub(_),
                    p.direction.transformDirection(n),
                    (p.shadow = f.castShadow) && (m = f.shadow,
                    p.shadowBias = m.bias,
                    p.shadowRadius = m.radius,
                    p.shadowMapSize = m.mapSize),
                    b.directionalShadowMap[a] = y,
                    b.directionalShadowMatrix[a] = f.shadow.matrix,
                    b.directional[a] = p,
                    a++) : f.isSpotLight ? ((p = x.get(f)).position.setFromMatrixPosition(f.matrixWorld),
                    p.position.applyMatrix4(n),
                    p.color.copy(m).multiplyScalar(g),
                    p.distance = v,
                    p.direction.setFromMatrixPosition(f.matrixWorld),
                    _.setFromMatrixPosition(f.target.matrixWorld),
                    p.direction.sub(_),
                    p.direction.transformDirection(n),
                    p.coneCos = Math.cos(f.angle),
                    p.penumbraCos = Math.cos(f.angle * (1 - f.penumbra)),
                    p.decay = 0 === f.distance ? 0 : f.decay,
                    (p.shadow = f.castShadow) && (m = f.shadow,
                    p.shadowBias = m.bias,
                    p.shadowRadius = m.radius,
                    p.shadowMapSize = m.mapSize),
                    b.spotShadowMap[c] = y,
                    b.spotShadowMatrix[c] = f.shadow.matrix,
                    b.spot[c] = p,
                    c++) : f.isRectAreaLight ? ((p = x.get(f)).color.copy(m).multiplyScalar(g),
                    p.position.setFromMatrixPosition(f.matrixWorld),
                    p.position.applyMatrix4(n),
                    E.identity(),
                    w.copy(f.matrixWorld),
                    w.premultiply(n),
                    E.extractRotation(w),
                    p.halfWidth.set(.5 * f.width, 0, 0),
                    p.halfHeight.set(0, .5 * f.height, 0),
                    p.halfWidth.applyMatrix4(E),
                    p.halfHeight.applyMatrix4(E),
                    b.rectArea[h] = p,
                    h++) : f.isPointLight ? ((p = x.get(f)).position.setFromMatrixPosition(f.matrixWorld),
                    p.position.applyMatrix4(n),
                    p.color.copy(f.color).multiplyScalar(f.intensity),
                    p.distance = f.distance,
                    p.decay = 0 === f.distance ? 0 : f.decay,
                    (p.shadow = f.castShadow) && (m = f.shadow,
                    p.shadowBias = m.bias,
                    p.shadowRadius = m.radius,
                    p.shadowMapSize = m.mapSize,
                    p.shadowCameraNear = m.camera.near,
                    p.shadowCameraFar = m.camera.far),
                    b.pointShadowMap[s] = y,
                    b.pointShadowMatrix[s] = f.shadow.matrix,
                    b.point[s] = p,
                    s++) : f.isHemisphereLight && ((p = x.get(f)).direction.setFromMatrixPosition(f.matrixWorld),
                    p.direction.transformDirection(n),
                    p.direction.normalize(),
                    p.skyColor.copy(f.color).multiplyScalar(g),
                    p.groundColor.copy(f.groundColor).multiplyScalar(g),
                    b.hemi[l] = p,
                    l++)
                }
                b.ambient[0] = i,
                b.ambient[1] = r,
                b.ambient[2] = o,
                b.directional.length = a,
                b.spot.length = c,
                b.rectArea.length = h,
                b.point.length = s,
                b.hemi.length = l,
                b.hash = b.id + "," + a + "," + s + "," + c + "," + h + "," + l + "," + e.length
            },
            state: b
        }
    }
    function $t() {
        var e = new Kt
          , n = []
          , i = []
          , r = [];
        return {
            init: function() {
                n.length = 0,
                i.length = 0,
                r.length = 0
            },
            state: {
                lightsArray: n,
                shadowsArray: i,
                spritesArray: r,
                lights: e
            },
            setupLights: function(t) {
                e.setup(n, i, t)
            },
            pushLight: function(t) {
                n.push(t)
            },
            pushShadow: function(t) {
                i.push(t)
            },
            pushSprite: function(t) {
                r.push(t)
            }
        }
    }
    function te() {
        var n = {};
        return {
            get: function(t, e) {
                return t = t.id + "," + e.id,
                void 0 === (e = n[t]) && (e = new $t,
                n[t] = e),
                e
            },
            dispose: function() {
                n = {}
            }
        }
    }
    function ee(t) {
        I.call(this),
        this.type = "MeshDepthMaterial",
        this.depthPacking = 3200,
        this.morphTargets = this.skinning = !1,
        this.displacementMap = this.alphaMap = this.map = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.lights = this.fog = !1,
        this.setValues(t)
    }
    function ne(t) {
        I.call(this),
        this.type = "MeshDistanceMaterial",
        this.referencePosition = new wt,
        this.nearDistance = 1,
        this.farDistance = 1e3,
        this.morphTargets = this.skinning = !1,
        this.displacementMap = this.alphaMap = this.map = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.lights = this.fog = !1,
        this.setValues(t)
    }
    function ie(d, p, t) {
        function f(t, e, n, i, r, o) {
            var a = t.geometry
              , s = h
              , c = t.customDepthMaterial;
            return n && (s = l,
            c = t.customDistanceMaterial),
            s = c || (c = !1,
            e.morphTargets && (a && a.isBufferGeometry ? c = a.morphAttributes && a.morphAttributes.position && 0 < a.morphAttributes.position.length : a && a.isGeometry && (c = a.morphTargets && 0 < a.morphTargets.length)),
            t.isSkinnedMesh && !1 === e.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", t),
            a = 0,
            c && (a |= 1),
            (t = t.isSkinnedMesh && e.skinning) && (a |= 2),
            s[a]),
            d.localClippingEnabled && !0 === e.clipShadows && 0 !== e.clippingPlanes.length && (a = s.uuid,
            c = e.uuid,
            void 0 === (t = u[a]) && (u[a] = t = {}),
            void 0 === (a = t[c]) && (a = s.clone(),
            t[c] = a),
            s = a),
            s.visible = e.visible,
            s.wireframe = e.wireframe,
            s.side = null != e.shadowSide ? e.shadowSide : _[e.side],
            s.clipShadows = e.clipShadows,
            s.clippingPlanes = e.clippingPlanes,
            s.clipIntersection = e.clipIntersection,
            s.wireframeLinewidth = e.wireframeLinewidth,
            s.linewidth = e.linewidth,
            n && s.isMeshDistanceMaterial && (s.referencePosition.copy(i),
            s.nearDistance = r,
            s.farDistance = o),
            s
        }
        var m = new Tt
          , g = new _t
          , v = new W
          , y = new W(t,t)
          , x = new wt
          , b = new wt
          , h = Array(4)
          , l = Array(4)
          , u = {}
          , _ = {
            0: 1,
            1: 0,
            2: 2
        }
          , w = [new wt(1,0,0), new wt(-1,0,0), new wt(0,0,1), new wt(0,0,-1), new wt(0,1,0), new wt(0,-1,0)]
          , E = [new wt(0,1,0), new wt(0,1,0), new wt(0,1,0), new wt(0,1,0), new wt(0,0,1), new wt(0,0,-1)]
          , M = [new Et, new Et, new Et, new Et, new Et, new Et];
        for (t = 0; 4 !== t; ++t) {
            var e = 0 != (1 & t)
              , n = 0 != (2 & t)
              , i = new ee({
                depthPacking: 3201,
                morphTargets: e,
                skinning: n
            });
            h[t] = i,
            e = new ne({
                morphTargets: e,
                skinning: n
            }),
            l[t] = e
        }
        var T = this;
        this.enabled = !1,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this.type = 1,
        this.render = function(t, e, n) {
            if (!1 !== T.enabled && (!1 !== T.autoUpdate || !1 !== T.needsUpdate) && 0 !== t.length) {
                var i = d.state;
                i.disable(d.context.BLEND),
                i.buffers.color.setClear(1, 1, 1, 1),
                i.buffers.depth.setTest(!0),
                i.setScissorTest(!1);
                for (var r = 0, o = t.length; r < o; r++) {
                    var a = t[r]
                      , s = a.shadow
                      , c = a && a.isPointLight;
                    if (void 0 === s)
                        console.warn("THREE.WebGLShadowMap:", a, "has no shadow.");
                    else {
                        var h, l, u = s.camera;
                        for (v.copy(s.mapSize),
                        v.min(y),
                        c && (h = v.x,
                        l = v.y,
                        M[0].set(2 * h, l, h, l),
                        M[1].set(0, l, h, l),
                        M[2].set(3 * h, l, h, l),
                        M[3].set(h, l, h, l),
                        M[4].set(3 * h, 0, h, l),
                        M[5].set(h, 0, h, l),
                        v.x *= 4,
                        v.y *= 2),
                        null === s.map && (s.map = new S(v.x,v.y,{
                            minFilter: 1003,
                            magFilter: 1003,
                            format: 1023
                        }),
                        s.map.texture.name = a.name + ".shadowMap",
                        u.updateProjectionMatrix()),
                        s.isSpotLightShadow && s.update(a),
                        h = s.map,
                        l = s.matrix,
                        b.setFromMatrixPosition(a.matrixWorld),
                        u.position.copy(b),
                        c ? (s = 6,
                        l.makeTranslation(-b.x, -b.y, -b.z)) : (s = 1,
                        x.setFromMatrixPosition(a.target.matrixWorld),
                        u.lookAt(x),
                        u.updateMatrixWorld(),
                        l.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                        l.multiply(u.projectionMatrix),
                        l.multiply(u.matrixWorldInverse)),
                        d.setRenderTarget(h),
                        d.clear(),
                        a = 0; a < s; a++)
                            c && (x.copy(u.position),
                            x.add(w[a]),
                            u.up.copy(E[a]),
                            u.lookAt(x),
                            u.updateMatrixWorld(),
                            i.viewport(M[a])),
                            g.multiplyMatrices(u.projectionMatrix, u.matrixWorldInverse),
                            m.setFromMatrix(g),
                            function t(e, n, i, r) {
                                if (!1 !== e.visible) {
                                    if (e.layers.test(n.layers) && (e.isMesh || e.isLine || e.isPoints) && e.castShadow && (!e.frustumCulled || m.intersectsObject(e))) {
                                        e.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, e.matrixWorld);
                                        var o = p.update(e)
                                          , a = e.material;
                                        if (Array.isArray(a))
                                            for (var s = o.groups, c = 0, h = s.length; c < h; c++) {
                                                var l = s[c]
                                                  , u = a[l.materialIndex];
                                                u && u.visible && (u = f(e, u, r, b, i.near, i.far),
                                                d.renderBufferDirect(i, null, o, u, e, l))
                                            }
                                        else
                                            a.visible && (u = f(e, a, r, b, i.near, i.far),
                                            d.renderBufferDirect(i, null, o, u, e, null))
                                    }
                                    for (o = 0,
                                    a = (e = e.children).length; o < a; o++)
                                        t(e[o], n, i, r)
                                }
                            }(e, n, u, c)
                    }
                }
                T.needsUpdate = !1
            }
        }
    }
    function re(t, e, n, i, r, o, a, s, c) {
        d.call(this, t, e, n, i, r, o, a, s, c),
        this.needsUpdate = !0
    }
    function oe(d, p, f, m, g) {
        var v, y, x, b, _, w, E, M, T, S, A, R, L, C, P, N, O, I;
        function B(t, e) {
            return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : e.id - t.id
        }
        var U, D, F, z, H = new wt, G = new V, k = new wt;
        this.render = function(t, e, n) {
            if (0 !== t.length) {
                var i, r;
                void 0 === F && (i = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]),
                r = new Uint16Array([0, 1, 2, 0, 2, 3]),
                U = p.createBuffer(),
                D = p.createBuffer(),
                p.bindBuffer(p.ARRAY_BUFFER, U),
                p.bufferData(p.ARRAY_BUFFER, i, p.STATIC_DRAW),
                p.bindBuffer(p.ELEMENT_ARRAY_BUFFER, D),
                p.bufferData(p.ELEMENT_ARRAY_BUFFER, r, p.STATIC_DRAW),
                i = p.createProgram(),
                r = p.createShader(p.VERTEX_SHADER),
                o = p.createShader(p.FRAGMENT_SHADER),
                p.shaderSource(r, ["precision " + g.precision + " float;", "#define SHADER_NAME SpriteMaterial\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 center;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float fogDepth;\nvoid main() {\n\tvUV = uvOffset + uv * uvScale;\n\tvec2 alignedPosition = ( position - center ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tvec4 mvPosition;\n\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\tfogDepth = - mvPosition.z;\n}"].join("\n")),
                p.shaderSource(o, ["precision " + g.precision + " float;", "#define SHADER_NAME SpriteMaterial\nuniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvarying float fogDepth;\nvoid main() {\n\tvec4 texture = texture2D( map, vUV );\n\tgl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\n\tif ( gl_FragColor.a < alphaTest ) discard;\n\tif ( fogType > 0 ) {\n\t\tfloat fogFactor = 0.0;\n\t\tif ( fogType == 1 ) {\n\t\t\tfogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t\t} else {\n\t\t\tconst float LOG2 = 1.442695;\n\t\t\tfogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );\n\t\t\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n\t\t}\n\t\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\t}\n}"].join("\n")),
                p.compileShader(r),
                p.compileShader(o),
                p.attachShader(i, r),
                p.attachShader(i, o),
                p.linkProgram(i),
                F = i,
                O = p.getAttribLocation(F, "position"),
                I = p.getAttribLocation(F, "uv"),
                v = p.getUniformLocation(F, "uvOffset"),
                y = p.getUniformLocation(F, "uvScale"),
                x = p.getUniformLocation(F, "rotation"),
                b = p.getUniformLocation(F, "center"),
                _ = p.getUniformLocation(F, "scale"),
                w = p.getUniformLocation(F, "color"),
                E = p.getUniformLocation(F, "map"),
                M = p.getUniformLocation(F, "opacity"),
                T = p.getUniformLocation(F, "modelViewMatrix"),
                S = p.getUniformLocation(F, "projectionMatrix"),
                A = p.getUniformLocation(F, "fogType"),
                R = p.getUniformLocation(F, "fogDensity"),
                L = p.getUniformLocation(F, "fogNear"),
                C = p.getUniformLocation(F, "fogFar"),
                P = p.getUniformLocation(F, "fogColor"),
                p.getUniformLocation(F, "fogDepth"),
                N = p.getUniformLocation(F, "alphaTest"),
                (i = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")).width = 8,
                i.height = 8,
                (r = i.getContext("2d")).fillStyle = "white",
                r.fillRect(0, 0, 8, 8),
                z = new re(i)),
                f.useProgram(F),
                f.initAttributes(),
                f.enableAttribute(O),
                f.enableAttribute(I),
                f.disableUnusedAttributes(),
                f.disable(p.CULL_FACE),
                f.enable(p.BLEND),
                p.bindBuffer(p.ARRAY_BUFFER, U),
                p.vertexAttribPointer(O, 2, p.FLOAT, !1, 16, 0),
                p.vertexAttribPointer(I, 2, p.FLOAT, !1, 16, 8),
                p.bindBuffer(p.ELEMENT_ARRAY_BUFFER, D),
                p.uniformMatrix4fv(S, !1, n.projectionMatrix.elements),
                f.activeTexture(p.TEXTURE0),
                p.uniform1i(E, 0),
                r = i = 0,
                (o = e.fog) ? (p.uniform3f(P, o.color.r, o.color.g, o.color.b),
                o.isFog ? (p.uniform1f(L, o.near),
                p.uniform1f(C, o.far),
                p.uniform1i(A, 1),
                r = i = 1) : o.isFogExp2 && (p.uniform1f(R, o.density),
                p.uniform1i(A, 2),
                r = i = 2)) : (p.uniform1i(A, 0),
                r = i = 0);
                for (var o = 0, a = t.length; o < a; o++) {
                    var s = t[o];
                    s.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, s.matrixWorld),
                    s.z = -s.modelViewMatrix.elements[14]
                }
                t.sort(B);
                var c = []
                  , h = [];
                for (o = 0,
                a = t.length; o < a; o++) {
                    var l, u = (s = t[o]).material;
                    !1 !== u.visible && (s.onBeforeRender(d, e, n, void 0, u, void 0),
                    p.uniform1f(N, u.alphaTest),
                    p.uniformMatrix4fv(T, !1, s.modelViewMatrix.elements),
                    s.matrixWorld.decompose(H, G, k),
                    c[0] = k.x,
                    c[1] = k.y,
                    h[0] = s.center.x - .5,
                    h[1] = s.center.y - .5,
                    l = 0,
                    i !== (l = e.fog && u.fog ? r : l) && (p.uniform1i(A, l),
                    i = l),
                    null !== u.map ? (p.uniform2f(v, u.map.offset.x, u.map.offset.y),
                    p.uniform2f(y, u.map.repeat.x, u.map.repeat.y)) : (p.uniform2f(v, 0, 0),
                    p.uniform2f(y, 1, 1)),
                    p.uniform1f(M, u.opacity),
                    p.uniform3f(w, u.color.r, u.color.g, u.color.b),
                    p.uniform1f(x, u.rotation),
                    p.uniform2fv(b, h),
                    p.uniform2fv(_, c),
                    f.setBlending(u.blending, u.blendEquation, u.blendSrc, u.blendDst, u.blendEquationAlpha, u.blendSrcAlpha, u.blendDstAlpha, u.premultipliedAlpha),
                    f.buffers.depth.setTest(u.depthTest),
                    f.buffers.depth.setMask(u.depthWrite),
                    f.buffers.color.setMask(u.colorWrite),
                    m.setTexture2D(u.map || z, 0),
                    p.drawElements(p.TRIANGLES, 6, p.UNSIGNED_SHORT, 0),
                    s.onAfterRender(d, e, n, void 0, u, void 0))
                }
                f.enable(p.CULL_FACE),
                f.reset()
            }
        }
    }
    function ae(l, n, c) {
        function t(t, e, n) {
            var i = new Uint8Array(4)
              , r = l.createTexture();
            for (l.bindTexture(t, r),
            l.texParameteri(t, l.TEXTURE_MIN_FILTER, l.NEAREST),
            l.texParameteri(t, l.TEXTURE_MAG_FILTER, l.NEAREST),
            t = 0; t < n; t++)
                l.texImage2D(e + t, 0, l.RGBA, 1, 1, 0, l.RGBA, l.UNSIGNED_BYTE, i);
            return r
        }
        function u(t) {
            !0 !== y[t] && (l.enable(t),
            y[t] = !0)
        }
        function d(t) {
            !1 !== y[t] && (l.disable(t),
            y[t] = !1)
        }
        function i(t, e, n, i, r, o, a, s) {
            if ((0 !== t ? u : d)(l.BLEND),
            5 !== t) {
                if (t !== _ || s !== R)
                    switch (t) {
                    case 2:
                        s ? (l.blendEquationSeparate(l.FUNC_ADD, l.FUNC_ADD),
                        l.blendFuncSeparate(l.ONE, l.ONE, l.ONE, l.ONE)) : (l.blendEquation(l.FUNC_ADD),
                        l.blendFunc(l.SRC_ALPHA, l.ONE));
                        break;
                    case 3:
                        s ? (l.blendEquationSeparate(l.FUNC_ADD, l.FUNC_ADD),
                        l.blendFuncSeparate(l.ZERO, l.ZERO, l.ONE_MINUS_SRC_COLOR, l.ONE_MINUS_SRC_ALPHA)) : (l.blendEquation(l.FUNC_ADD),
                        l.blendFunc(l.ZERO, l.ONE_MINUS_SRC_COLOR));
                        break;
                    case 4:
                        s ? (l.blendEquationSeparate(l.FUNC_ADD, l.FUNC_ADD),
                        l.blendFuncSeparate(l.ZERO, l.SRC_COLOR, l.ZERO, l.SRC_ALPHA)) : (l.blendEquation(l.FUNC_ADD),
                        l.blendFunc(l.ZERO, l.SRC_COLOR));
                        break;
                    default:
                        s ? (l.blendEquationSeparate(l.FUNC_ADD, l.FUNC_ADD),
                        l.blendFuncSeparate(l.ONE, l.ONE_MINUS_SRC_ALPHA, l.ONE, l.ONE_MINUS_SRC_ALPHA)) : (l.blendEquationSeparate(l.FUNC_ADD, l.FUNC_ADD),
                        l.blendFuncSeparate(l.SRC_ALPHA, l.ONE_MINUS_SRC_ALPHA, l.ONE, l.ONE_MINUS_SRC_ALPHA))
                    }
                A = S = T = M = E = w = null
            } else
                r = r || e,
                o = o || n,
                a = a || i,
                e === w && r === T || (l.blendEquationSeparate(c.convert(e), c.convert(r)),
                w = e,
                T = r),
                n === E && i === M && o === S && a === A || (l.blendFuncSeparate(c.convert(n), c.convert(i), c.convert(o), c.convert(a)),
                E = n,
                M = i,
                S = o,
                A = a);
            _ = t,
            R = s
        }
        function r(t) {
            L !== t && (t ? l.frontFace(l.CW) : l.frontFace(l.CCW),
            L = t)
        }
        function e(t) {
            0 !== t ? (u(l.CULL_FACE),
            t !== C && (1 === t ? l.cullFace(l.BACK) : 2 === t ? l.cullFace(l.FRONT) : l.cullFace(l.FRONT_AND_BACK))) : d(l.CULL_FACE),
            C = t
        }
        function o(t, e, n) {
            t ? (u(l.POLYGON_OFFSET_FILL),
            N === e && O === n || (l.polygonOffset(e, n),
            N = e,
            O = n)) : d(l.POLYGON_OFFSET_FILL)
        }
        function a(t) {
            void 0 === t && (t = l.TEXTURE0 + I - 1),
            U !== t && (l.activeTexture(t),
            U = t)
        }
        var s = new function() {
            var e = !1
              , o = new Et
              , n = null
              , a = new Et(0,0,0,0);
            return {
                setMask: function(t) {
                    n === t || e || (l.colorMask(t, t, t, t),
                    n = t)
                },
                setLocked: function(t) {
                    e = t
                },
                setClear: function(t, e, n, i, r) {
                    !0 === r && (t *= i,
                    e *= i,
                    n *= i),
                    o.set(t, e, n, i),
                    !1 === a.equals(o) && (l.clearColor(t, e, n, i),
                    a.copy(o))
                },
                reset: function() {
                    e = !1,
                    n = null,
                    a.set(-1, 0, 0, 0)
                }
            }
        }
          , h = new function() {
            var e = !1
              , n = null
              , i = null
              , r = null;
            return {
                setTest: function(t) {
                    (t ? u : d)(l.DEPTH_TEST)
                },
                setMask: function(t) {
                    n === t || e || (l.depthMask(t),
                    n = t)
                },
                setFunc: function(t) {
                    if (i !== t) {
                        if (t)
                            switch (t) {
                            case 0:
                                l.depthFunc(l.NEVER);
                                break;
                            case 1:
                                l.depthFunc(l.ALWAYS);
                                break;
                            case 2:
                                l.depthFunc(l.LESS);
                                break;
                            case 3:
                                l.depthFunc(l.LEQUAL);
                                break;
                            case 4:
                                l.depthFunc(l.EQUAL);
                                break;
                            case 5:
                                l.depthFunc(l.GEQUAL);
                                break;
                            case 6:
                                l.depthFunc(l.GREATER);
                                break;
                            case 7:
                                l.depthFunc(l.NOTEQUAL);
                                break;
                            default:
                                l.depthFunc(l.LEQUAL)
                            }
                        else
                            l.depthFunc(l.LEQUAL);
                        i = t
                    }
                },
                setLocked: function(t) {
                    e = t
                },
                setClear: function(t) {
                    r !== t && (l.clearDepth(t),
                    r = t)
                },
                reset: function() {
                    e = !1,
                    r = i = n = null
                }
            }
        }
          , p = new function() {
            var e = !1
              , n = null
              , i = null
              , r = null
              , o = null
              , a = null
              , s = null
              , c = null
              , h = null;
            return {
                setTest: function(t) {
                    (t ? u : d)(l.STENCIL_TEST)
                },
                setMask: function(t) {
                    n === t || e || (l.stencilMask(t),
                    n = t)
                },
                setFunc: function(t, e, n) {
                    i === t && r === e && o === n || (l.stencilFunc(t, e, n),
                    i = t,
                    r = e,
                    o = n)
                },
                setOp: function(t, e, n) {
                    a === t && s === e && c === n || (l.stencilOp(t, e, n),
                    a = t,
                    s = e,
                    c = n)
                },
                setLocked: function(t) {
                    e = t
                },
                setClear: function(t) {
                    h !== t && (l.clearStencil(t),
                    h = t)
                },
                reset: function() {
                    e = !1,
                    h = c = s = a = o = r = i = n = null
                }
            }
        }
          , f = l.getParameter(l.MAX_VERTEX_ATTRIBS)
          , m = new Uint8Array(f)
          , g = new Uint8Array(f)
          , v = new Uint8Array(f)
          , y = {}
          , x = null
          , b = null
          , _ = null
          , w = null
          , E = null
          , M = null
          , T = null
          , S = null
          , A = null
          , R = !1
          , L = null
          , C = null
          , P = null
          , N = null
          , O = null
          , I = l.getParameter(l.MAX_COMBINED_TEXTURE_IMAGE_UNITS)
          , B = !1
          , f = 0;
        -1 !== (f = l.getParameter(l.VERSION)).indexOf("WebGL") ? (f = parseFloat(/^WebGL ([0-9])/.exec(f)[1]),
        B = 1 <= f) : -1 !== f.indexOf("OpenGL ES") && (f = parseFloat(/^OpenGL ES ([0-9])/.exec(f)[1]),
        B = 2 <= f);
        var U = null
          , D = {}
          , F = new Et
          , z = new Et
          , H = {};
        return H[l.TEXTURE_2D] = t(l.TEXTURE_2D, l.TEXTURE_2D, 1),
        H[l.TEXTURE_CUBE_MAP] = t(l.TEXTURE_CUBE_MAP, l.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
        s.setClear(0, 0, 0, 1),
        h.setClear(1),
        p.setClear(0),
        u(l.DEPTH_TEST),
        h.setFunc(3),
        r(!1),
        e(1),
        u(l.CULL_FACE),
        u(l.BLEND),
        i(1),
        {
            buffers: {
                color: s,
                depth: h,
                stencil: p
            },
            initAttributes: function() {
                for (var t = 0, e = m.length; t < e; t++)
                    m[t] = 0
            },
            enableAttribute: function(t) {
                m[t] = 1,
                0 === g[t] && (l.enableVertexAttribArray(t),
                g[t] = 1),
                0 !== v[t] && (n.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(t, 0),
                v[t] = 0)
            },
            enableAttributeAndDivisor: function(t, e) {
                m[t] = 1,
                0 === g[t] && (l.enableVertexAttribArray(t),
                g[t] = 1),
                v[t] !== e && (n.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(t, e),
                v[t] = e)
            },
            disableUnusedAttributes: function() {
                for (var t = 0, e = g.length; t !== e; ++t)
                    g[t] !== m[t] && (l.disableVertexAttribArray(t),
                    g[t] = 0)
            },
            enable: u,
            disable: d,
            getCompressedTextureFormats: function() {
                if (null === x && (x = [],
                n.get("WEBGL_compressed_texture_pvrtc") || n.get("WEBGL_compressed_texture_s3tc") || n.get("WEBGL_compressed_texture_etc1") || n.get("WEBGL_compressed_texture_astc")))
                    for (var t = l.getParameter(l.COMPRESSED_TEXTURE_FORMATS), e = 0; e < t.length; e++)
                        x.push(t[e]);
                return x
            },
            useProgram: function(t) {
                return b !== t && (l.useProgram(t),
                b = t,
                !0)
            },
            setBlending: i,
            setMaterial: function(t, e) {
                (2 === t.side ? d : u)(l.CULL_FACE);
                var n = 1 === t.side;
                r(n = e ? !n : n),
                !0 === t.transparent ? i(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha) : i(0),
                h.setFunc(t.depthFunc),
                h.setTest(t.depthTest),
                h.setMask(t.depthWrite),
                s.setMask(t.colorWrite),
                o(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
            },
            setFlipSided: r,
            setCullFace: e,
            setLineWidth: function(t) {
                t !== P && (B && l.lineWidth(t),
                P = t)
            },
            setPolygonOffset: o,
            setScissorTest: function(t) {
                (t ? u : d)(l.SCISSOR_TEST)
            },
            activeTexture: a,
            bindTexture: function(t, e) {
                null === U && a();
                var n = D[U];
                void 0 === n && (D[U] = n = {
                    type: void 0,
                    texture: void 0
                }),
                n.type === t && n.texture === e || (l.bindTexture(t, e || H[t]),
                n.type = t,
                n.texture = e)
            },
            compressedTexImage2D: function() {
                try {
                    l.compressedTexImage2D.apply(l, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            texImage2D: function() {
                try {
                    l.texImage2D.apply(l, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            scissor: function(t) {
                !1 === F.equals(t) && (l.scissor(t.x, t.y, t.z, t.w),
                F.copy(t))
            },
            viewport: function(t) {
                !1 === z.equals(t) && (l.viewport(t.x, t.y, t.z, t.w),
                z.copy(t))
            },
            reset: function() {
                for (var t = 0; t < g.length; t++)
                    1 === g[t] && (l.disableVertexAttribArray(t),
                    g[t] = 0);
                y = {},
                U = x = null,
                D = {},
                C = L = _ = b = null,
                s.reset(),
                h.reset(),
                p.reset()
            }
        }
    }
    function se(f, i, m, g, v, y, x) {
        function b(t, e) {
            if (t.width > e || t.height > e) {
                if ("data"in t)
                    return void console.warn("THREE.WebGLRenderer: image in DataTexture is too big (" + t.width + "x" + t.height + ").");
                e /= Math.max(t.width, t.height);
                var n = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                return n.width = Math.floor(t.width * e),
                n.height = Math.floor(t.height * e),
                n.getContext("2d").drawImage(t, 0, 0, t.width, t.height, 0, 0, n.width, n.height),
                console.warn("THREE.WebGLRenderer: image is too big (" + t.width + "x" + t.height + "). Resized to " + n.width + "x" + n.height, t),
                n
            }
            return t
        }
        function _(t) {
            return io.isPowerOfTwo(t.width) && io.isPowerOfTwo(t.height)
        }
        function w(t, e) {
            return t.generateMipmaps && e && 1003 !== t.minFilter && 1006 !== t.minFilter
        }
        function E(t, e, n, i) {
            f.generateMipmap(t),
            g.get(e).__maxMipLevel = Math.log(Math.max(n, i)) * Math.LOG2E
        }
        function r(t) {
            return 1003 === t || 1004 === t || 1005 === t ? f.NEAREST : f.LINEAR
        }
        function M(t) {
            (t = t.target).removeEventListener("dispose", M);
            t: {
                var e = g.get(t);
                if (t.image && e.__image__webglTextureCube)
                    f.deleteTexture(e.__image__webglTextureCube);
                else {
                    if (void 0 === e.__webglInit)
                        break t;
                    f.deleteTexture(e.__webglTexture)
                }
                g.remove(t)
            }
            t.isVideoTexture && delete d[t.id],
            x.memory.textures--
        }
        function a(t) {
            (t = t.target).removeEventListener("dispose", a);
            var e = g.get(t)
              , n = g.get(t.texture);
            if (t) {
                if (void 0 !== n.__webglTexture && f.deleteTexture(n.__webglTexture),
                t.depthTexture && t.depthTexture.dispose(),
                t.isWebGLRenderTargetCube)
                    for (n = 0; n < 6; n++)
                        f.deleteFramebuffer(e.__webglFramebuffer[n]),
                        e.__webglDepthbuffer && f.deleteRenderbuffer(e.__webglDepthbuffer[n]);
                else
                    f.deleteFramebuffer(e.__webglFramebuffer),
                    e.__webglDepthbuffer && f.deleteRenderbuffer(e.__webglDepthbuffer);
                g.remove(t.texture),
                g.remove(t)
            }
            x.memory.textures--
        }
        function s(t, e) {
            var n = g.get(t);
            if (t.isVideoTexture && (i = t.id,
            r = x.render.frame,
            d[i] !== r && (d[i] = r,
            t.update())),
            0 < t.version && n.__version !== t.version)
                if (void 0 === (i = t.image))
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", t);
                else {
                    if (!1 !== i.complete) {
                        void 0 === n.__webglInit && (n.__webglInit = !0,
                        t.addEventListener("dispose", M),
                        n.__webglTexture = f.createTexture(),
                        x.memory.textures++),
                        m.activeTexture(f.TEXTURE0 + e),
                        m.bindTexture(f.TEXTURE_2D, n.__webglTexture),
                        f.pixelStorei(f.UNPACK_FLIP_Y_WEBGL, t.flipY),
                        f.pixelStorei(f.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha),
                        f.pixelStorei(f.UNPACK_ALIGNMENT, t.unpackAlignment),
                        e = b(t.image, v.maxTextureSize),
                        (1001 !== t.wrapS || 1001 !== t.wrapT || 1003 !== t.minFilter && 1006 !== t.minFilter) && !1 === _(e) && (e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof ImageBitmap) && ((l = void 0 === l ? document.createElementNS("http://www.w3.org/1999/xhtml", "canvas") : l).width = io.floorPowerOfTwo(e.width),
                        l.height = io.floorPowerOfTwo(e.height),
                        l.getContext("2d").drawImage(e, 0, 0, l.width, l.height),
                        console.warn("THREE.WebGLRenderer: image is not power of two (" + e.width + "x" + e.height + "). Resized to " + l.width + "x" + l.height, e),
                        e = l);
                        var i = _(e)
                          , r = y.convert(t.format)
                          , o = y.convert(t.type);
                        T(f.TEXTURE_2D, t, i);
                        var a = t.mipmaps;
                        if (t.isDepthTexture) {
                            var s = f.DEPTH_COMPONENT;
                            if (1015 === t.type) {
                                if (!u)
                                    throw Error("Float Depth Texture only supported in WebGL2.0");
                                s = f.DEPTH_COMPONENT32F
                            } else
                                u && (s = f.DEPTH_COMPONENT16);
                            1026 === t.format && s === f.DEPTH_COMPONENT && 1012 !== t.type && 1014 !== t.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                            t.type = 1012,
                            o = y.convert(t.type)),
                            1027 === t.format && (s = f.DEPTH_STENCIL,
                            1020 !== t.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                            t.type = 1020,
                            o = y.convert(t.type))),
                            m.texImage2D(f.TEXTURE_2D, 0, s, e.width, e.height, 0, r, o, null)
                        } else if (t.isDataTexture)
                            if (0 < a.length && i) {
                                for (var c = 0, h = a.length; c < h; c++)
                                    s = a[c],
                                    m.texImage2D(f.TEXTURE_2D, c, r, s.width, s.height, 0, r, o, s.data);
                                t.generateMipmaps = !1,
                                n.__maxMipLevel = a.length - 1
                            } else
                                m.texImage2D(f.TEXTURE_2D, 0, r, e.width, e.height, 0, r, o, e.data),
                                n.__maxMipLevel = 0;
                        else if (t.isCompressedTexture) {
                            for (c = 0,
                            h = a.length; c < h; c++)
                                s = a[c],
                                1023 !== t.format && 1022 !== t.format ? -1 < m.getCompressedTextureFormats().indexOf(r) ? m.compressedTexImage2D(f.TEXTURE_2D, c, r, s.width, s.height, 0, s.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : m.texImage2D(f.TEXTURE_2D, c, r, s.width, s.height, 0, r, o, s.data);
                            n.__maxMipLevel = a.length - 1
                        } else if (0 < a.length && i) {
                            for (c = 0,
                            h = a.length; c < h; c++)
                                s = a[c],
                                m.texImage2D(f.TEXTURE_2D, c, r, r, o, s);
                            t.generateMipmaps = !1,
                            n.__maxMipLevel = a.length - 1
                        } else
                            m.texImage2D(f.TEXTURE_2D, 0, r, r, o, e),
                            n.__maxMipLevel = 0;
                        return w(t, i) && E(f.TEXTURE_2D, t, e.width, e.height),
                        n.__version = t.version,
                        void (t.onUpdate && t.onUpdate(t))
                    }
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", t)
                }
            m.activeTexture(f.TEXTURE0 + e),
            m.bindTexture(f.TEXTURE_2D, n.__webglTexture)
        }
        function T(t, e, n) {
            n ? (f.texParameteri(t, f.TEXTURE_WRAP_S, y.convert(e.wrapS)),
            f.texParameteri(t, f.TEXTURE_WRAP_T, y.convert(e.wrapT)),
            f.texParameteri(t, f.TEXTURE_MAG_FILTER, y.convert(e.magFilter)),
            f.texParameteri(t, f.TEXTURE_MIN_FILTER, y.convert(e.minFilter))) : (f.texParameteri(t, f.TEXTURE_WRAP_S, f.CLAMP_TO_EDGE),
            f.texParameteri(t, f.TEXTURE_WRAP_T, f.CLAMP_TO_EDGE),
            1001 === e.wrapS && 1001 === e.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", e),
            f.texParameteri(t, f.TEXTURE_MAG_FILTER, r(e.magFilter)),
            f.texParameteri(t, f.TEXTURE_MIN_FILTER, r(e.minFilter)),
            1003 !== e.minFilter && 1006 !== e.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", e)),
            !(n = i.get("EXT_texture_filter_anisotropic")) || 1015 === e.type && null === i.get("OES_texture_float_linear") || 1016 === e.type && null === i.get("OES_texture_half_float_linear") || !(1 < e.anisotropy || g.get(e).__currentAnisotropy) || (f.texParameterf(t, n.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(e.anisotropy, v.getMaxAnisotropy())),
            g.get(e).__currentAnisotropy = e.anisotropy)
        }
        function c(t, e, n, i) {
            var r = y.convert(e.texture.format)
              , o = y.convert(e.texture.type);
            m.texImage2D(i, 0, r, e.width, e.height, 0, r, o, null),
            f.bindFramebuffer(f.FRAMEBUFFER, t),
            f.framebufferTexture2D(f.FRAMEBUFFER, n, i, g.get(e.texture).__webglTexture, 0),
            f.bindFramebuffer(f.FRAMEBUFFER, null)
        }
        function h(t, e) {
            f.bindRenderbuffer(f.RENDERBUFFER, t),
            e.depthBuffer && !e.stencilBuffer ? (f.renderbufferStorage(f.RENDERBUFFER, f.DEPTH_COMPONENT16, e.width, e.height),
            f.framebufferRenderbuffer(f.FRAMEBUFFER, f.DEPTH_ATTACHMENT, f.RENDERBUFFER, t)) : e.depthBuffer && e.stencilBuffer ? (f.renderbufferStorage(f.RENDERBUFFER, f.DEPTH_STENCIL, e.width, e.height),
            f.framebufferRenderbuffer(f.FRAMEBUFFER, f.DEPTH_STENCIL_ATTACHMENT, f.RENDERBUFFER, t)) : f.renderbufferStorage(f.RENDERBUFFER, f.RGBA4, e.width, e.height),
            f.bindRenderbuffer(f.RENDERBUFFER, null)
        }
        var l, u = "undefined" != typeof WebGL2RenderingContext && f instanceof WebGL2RenderingContext, d = {};
        this.setTexture2D = s,
        this.setTextureCube = function(t, e) {
            var n = g.get(t);
            if (6 === t.image.length)
                if (0 < t.version && n.__version !== t.version) {
                    n.__image__webglTextureCube || (t.addEventListener("dispose", M),
                    n.__image__webglTextureCube = f.createTexture(),
                    x.memory.textures++),
                    m.activeTexture(f.TEXTURE0 + e),
                    m.bindTexture(f.TEXTURE_CUBE_MAP, n.__image__webglTextureCube),
                    f.pixelStorei(f.UNPACK_FLIP_Y_WEBGL, t.flipY),
                    e = t && t.isCompressedTexture;
                    for (var i = t.image[0] && t.image[0].isDataTexture, r = [], o = 0; o < 6; o++)
                        r[o] = e || i ? i ? t.image[o].image : t.image[o] : b(t.image[o], v.maxCubemapSize);
                    var a = r[0]
                      , s = _(a)
                      , c = y.convert(t.format)
                      , h = y.convert(t.type);
                    for (T(f.TEXTURE_CUBE_MAP, t, s),
                    o = 0; o < 6; o++)
                        if (e)
                            for (var l, u = r[o].mipmaps, d = 0, p = u.length; d < p; d++)
                                l = u[d],
                                1023 !== t.format && 1022 !== t.format ? -1 < m.getCompressedTextureFormats().indexOf(c) ? m.compressedTexImage2D(f.TEXTURE_CUBE_MAP_POSITIVE_X + o, d, c, l.width, l.height, 0, l.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : m.texImage2D(f.TEXTURE_CUBE_MAP_POSITIVE_X + o, d, c, l.width, l.height, 0, c, h, l.data);
                        else
                            i ? m.texImage2D(f.TEXTURE_CUBE_MAP_POSITIVE_X + o, 0, c, r[o].width, r[o].height, 0, c, h, r[o].data) : m.texImage2D(f.TEXTURE_CUBE_MAP_POSITIVE_X + o, 0, c, c, h, r[o]);
                    n.__maxMipLevel = e ? u.length - 1 : 0,
                    w(t, s) && E(f.TEXTURE_CUBE_MAP, t, a.width, a.height),
                    n.__version = t.version,
                    t.onUpdate && t.onUpdate(t)
                } else
                    m.activeTexture(f.TEXTURE0 + e),
                    m.bindTexture(f.TEXTURE_CUBE_MAP, n.__image__webglTextureCube)
        }
        ,
        this.setTextureCubeDynamic = function(t, e) {
            m.activeTexture(f.TEXTURE0 + e),
            m.bindTexture(f.TEXTURE_CUBE_MAP, g.get(t).__webglTexture)
        }
        ,
        this.setupRenderTarget = function(t) {
            var e = g.get(t)
              , n = g.get(t.texture);
            t.addEventListener("dispose", a),
            n.__webglTexture = f.createTexture(),
            x.memory.textures++;
            var i = !0 === t.isWebGLRenderTargetCube
              , r = _(t);
            if (i) {
                e.__webglFramebuffer = [];
                for (var o = 0; o < 6; o++)
                    e.__webglFramebuffer[o] = f.createFramebuffer()
            } else
                e.__webglFramebuffer = f.createFramebuffer();
            if (i) {
                for (m.bindTexture(f.TEXTURE_CUBE_MAP, n.__webglTexture),
                T(f.TEXTURE_CUBE_MAP, t.texture, r),
                o = 0; o < 6; o++)
                    c(e.__webglFramebuffer[o], t, f.COLOR_ATTACHMENT0, f.TEXTURE_CUBE_MAP_POSITIVE_X + o);
                w(t.texture, r) && E(f.TEXTURE_CUBE_MAP, t.texture, t.width, t.height),
                m.bindTexture(f.TEXTURE_CUBE_MAP, null)
            } else
                m.bindTexture(f.TEXTURE_2D, n.__webglTexture),
                T(f.TEXTURE_2D, t.texture, r),
                c(e.__webglFramebuffer, t, f.COLOR_ATTACHMENT0, f.TEXTURE_2D),
                w(t.texture, r) && E(f.TEXTURE_2D, t.texture, t.width, t.height),
                m.bindTexture(f.TEXTURE_2D, null);
            if (t.depthBuffer) {
                if (e = g.get(t),
                n = !0 === t.isWebGLRenderTargetCube,
                t.depthTexture) {
                    if (n)
                        throw Error("target.depthTexture not supported in Cube render targets");
                    if (t && t.isWebGLRenderTargetCube)
                        throw Error("Depth Texture with cube render targets is not supported");
                    if (f.bindFramebuffer(f.FRAMEBUFFER, e.__webglFramebuffer),
                    !t.depthTexture || !t.depthTexture.isDepthTexture)
                        throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    if (g.get(t.depthTexture).__webglTexture && t.depthTexture.image.width === t.width && t.depthTexture.image.height === t.height || (t.depthTexture.image.width = t.width,
                    t.depthTexture.image.height = t.height,
                    t.depthTexture.needsUpdate = !0),
                    s(t.depthTexture, 0),
                    e = g.get(t.depthTexture).__webglTexture,
                    1026 === t.depthTexture.format)
                        f.framebufferTexture2D(f.FRAMEBUFFER, f.DEPTH_ATTACHMENT, f.TEXTURE_2D, e, 0);
                    else {
                        if (1027 !== t.depthTexture.format)
                            throw Error("Unknown depthTexture format");
                        f.framebufferTexture2D(f.FRAMEBUFFER, f.DEPTH_STENCIL_ATTACHMENT, f.TEXTURE_2D, e, 0)
                    }
                } else if (n)
                    for (e.__webglDepthbuffer = [],
                    n = 0; n < 6; n++)
                        f.bindFramebuffer(f.FRAMEBUFFER, e.__webglFramebuffer[n]),
                        e.__webglDepthbuffer[n] = f.createRenderbuffer(),
                        h(e.__webglDepthbuffer[n], t);
                else
                    f.bindFramebuffer(f.FRAMEBUFFER, e.__webglFramebuffer),
                    e.__webglDepthbuffer = f.createRenderbuffer(),
                    h(e.__webglDepthbuffer, t);
                f.bindFramebuffer(f.FRAMEBUFFER, null)
            }
        }
        ,
        this.updateRenderTargetMipmap = function(t) {
            var e, n = t.texture, i = _(t);
            w(n, i) && (i = t.isWebGLRenderTargetCube ? f.TEXTURE_CUBE_MAP : f.TEXTURE_2D,
            e = g.get(n).__webglTexture,
            m.bindTexture(i, e),
            E(i, n, t.width, t.height),
            m.bindTexture(i, null))
        }
    }
    function ce(n, i) {
        return {
            convert: function(t) {
                if (1e3 === t)
                    return n.REPEAT;
                if (1001 === t)
                    return n.CLAMP_TO_EDGE;
                if (1002 === t)
                    return n.MIRRORED_REPEAT;
                if (1003 === t)
                    return n.NEAREST;
                if (1004 === t)
                    return n.NEAREST_MIPMAP_NEAREST;
                if (1005 === t)
                    return n.NEAREST_MIPMAP_LINEAR;
                if (1006 === t)
                    return n.LINEAR;
                if (1007 === t)
                    return n.LINEAR_MIPMAP_NEAREST;
                if (1008 === t)
                    return n.LINEAR_MIPMAP_LINEAR;
                if (1009 === t)
                    return n.UNSIGNED_BYTE;
                if (1017 === t)
                    return n.UNSIGNED_SHORT_4_4_4_4;
                if (1018 === t)
                    return n.UNSIGNED_SHORT_5_5_5_1;
                if (1019 === t)
                    return n.UNSIGNED_SHORT_5_6_5;
                if (1010 === t)
                    return n.BYTE;
                if (1011 === t)
                    return n.SHORT;
                if (1012 === t)
                    return n.UNSIGNED_SHORT;
                if (1013 === t)
                    return n.INT;
                if (1014 === t)
                    return n.UNSIGNED_INT;
                if (1015 === t)
                    return n.FLOAT;
                if (1016 === t) {
                    var e = i.get("OES_texture_half_float");
                    if (null !== e)
                        return e.HALF_FLOAT_OES
                }
                if (1021 === t)
                    return n.ALPHA;
                if (1022 === t)
                    return n.RGB;
                if (1023 === t)
                    return n.RGBA;
                if (1024 === t)
                    return n.LUMINANCE;
                if (1025 === t)
                    return n.LUMINANCE_ALPHA;
                if (1026 === t)
                    return n.DEPTH_COMPONENT;
                if (1027 === t)
                    return n.DEPTH_STENCIL;
                if (100 === t)
                    return n.FUNC_ADD;
                if (101 === t)
                    return n.FUNC_SUBTRACT;
                if (102 === t)
                    return n.FUNC_REVERSE_SUBTRACT;
                if (200 === t)
                    return n.ZERO;
                if (201 === t)
                    return n.ONE;
                if (202 === t)
                    return n.SRC_COLOR;
                if (203 === t)
                    return n.ONE_MINUS_SRC_COLOR;
                if (204 === t)
                    return n.SRC_ALPHA;
                if (205 === t)
                    return n.ONE_MINUS_SRC_ALPHA;
                if (206 === t)
                    return n.DST_ALPHA;
                if (207 === t)
                    return n.ONE_MINUS_DST_ALPHA;
                if (208 === t)
                    return n.DST_COLOR;
                if (209 === t)
                    return n.ONE_MINUS_DST_COLOR;
                if (210 === t)
                    return n.SRC_ALPHA_SATURATE;
                if ((33776 === t || 33777 === t || 33778 === t || 33779 === t) && null !== (e = i.get("WEBGL_compressed_texture_s3tc"))) {
                    if (33776 === t)
                        return e.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (33777 === t)
                        return e.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (33778 === t)
                        return e.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (33779 === t)
                        return e.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if ((35840 === t || 35841 === t || 35842 === t || 35843 === t) && null !== (e = i.get("WEBGL_compressed_texture_pvrtc"))) {
                    if (35840 === t)
                        return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (35841 === t)
                        return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (35842 === t)
                        return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (35843 === t)
                        return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (36196 === t && null !== (e = i.get("WEBGL_compressed_texture_etc1")))
                    return e.COMPRESSED_RGB_ETC1_WEBGL;
                if ((37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t) && null !== (e = i.get("WEBGL_compressed_texture_astc")))
                    return t;
                if ((103 === t || 104 === t) && null !== (e = i.get("EXT_blend_minmax"))) {
                    if (103 === t)
                        return e.MIN_EXT;
                    if (104 === t)
                        return e.MAX_EXT
                }
                return 1020 === t && null !== (e = i.get("WEBGL_depth_texture")) ? e.UNSIGNED_INT_24_8_WEBGL : 0
            }
        }
    }
    function he(t, e, n, i) {
        s.call(this),
        this.type = "PerspectiveCamera",
        this.fov = void 0 !== t ? t : 50,
        this.zoom = 1,
        this.near = void 0 !== n ? n : .1,
        this.far = void 0 !== i ? i : 2e3,
        this.focus = 10,
        this.aspect = void 0 !== e ? e : 1,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    function le(t) {
        he.call(this),
        this.cameras = t || []
    }
    function ue(n) {
        function t() {
            var t, e;
            null !== r && !0 === r.isPresenting ? (t = (e = r.getEyeParameters("left")).renderWidth,
            e = e.renderHeight,
            m = n.getPixelRatio(),
            f = n.getSize(),
            n.setDrawingBufferSize(2 * t, e, 1)) : i.enabled && n.setDrawingBufferSize(f.width, f.height, m)
        }
        var i = this
          , r = null
          , o = null
          , a = null
          , s = new _t
          , c = new _t;
        "undefined" != typeof window && "VRFrameData"in window && (o = new window.VRFrameData,
        window.addEventListener("vrdisplaypresentchange", t, !1));
        var h = new _t
          , l = new V
          , u = new wt
          , d = new he;
        d.bounds = new Et(0,0,.5,1),
        d.layers.enable(1);
        var p = new he;
        p.bounds = new Et(.5,0,.5,1),
        p.layers.enable(2);
        var f, m, g = new le([d, p]);
        g.layers.enable(1),
        g.layers.enable(2),
        this.enabled = !1,
        this.userHeight = 1.6,
        this.getDevice = function() {
            return r
        }
        ,
        this.setDevice = function(t) {
            void 0 !== t && (r = t)
        }
        ,
        this.setPoseTarget = function(t) {
            void 0 !== t && (a = t)
        }
        ,
        this.getCamera = function(t) {
            if (null === r)
                return t;
            r.depthNear = t.near,
            r.depthFar = t.far,
            r.getFrameData(o),
            (e = r.stageParameters) ? s.fromArray(e.sittingToStandingTransform) : s.makeTranslation(0, i.userHeight, 0);
            var e = o.pose
              , n = null !== a ? a : t;
            return n.matrix.copy(s),
            n.matrix.decompose(n.position, n.quaternion, n.scale),
            null !== e.orientation && (l.fromArray(e.orientation),
            n.quaternion.multiply(l)),
            null !== e.position && (l.setFromRotationMatrix(s),
            u.fromArray(e.position),
            u.applyQuaternion(l),
            n.position.add(u)),
            n.updateMatrixWorld(),
            !1 === r.isPresenting ? t : (d.near = t.near,
            p.near = t.near,
            d.far = t.far,
            p.far = t.far,
            g.matrixWorld.copy(t.matrixWorld),
            g.matrixWorldInverse.copy(t.matrixWorldInverse),
            d.matrixWorldInverse.fromArray(o.leftViewMatrix),
            p.matrixWorldInverse.fromArray(o.rightViewMatrix),
            c.getInverse(s),
            d.matrixWorldInverse.multiply(c),
            p.matrixWorldInverse.multiply(c),
            null !== (t = n.parent) && (h.getInverse(t.matrixWorld),
            d.matrixWorldInverse.multiply(h),
            p.matrixWorldInverse.multiply(h)),
            d.matrixWorld.getInverse(d.matrixWorldInverse),
            p.matrixWorld.getInverse(p.matrixWorldInverse),
            d.projectionMatrix.fromArray(o.leftProjectionMatrix),
            p.projectionMatrix.fromArray(o.rightProjectionMatrix),
            g.projectionMatrix.copy(d.projectionMatrix),
            (t = r.getLayers()).length && (null !== (t = t[0]).leftBounds && 4 === t.leftBounds.length && d.bounds.fromArray(t.leftBounds),
            null !== t.rightBounds && 4 === t.rightBounds.length && p.bounds.fromArray(t.rightBounds)),
            g)
        }
        ,
        this.getStandingMatrix = function() {
            return s
        }
        ,
        this.submitFrame = function() {
            null !== r && !0 === r.isPresenting && r.submitFrame()
        }
        ,
        this.dispose = function() {
            "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", t)
        }
    }
    function de(t) {
        function e() {
            (T = new Pt(pt)).get("WEBGL_depth_texture"),
            T.get("OES_texture_float"),
            T.get("OES_texture_float_linear"),
            T.get("OES_texture_half_float"),
            T.get("OES_texture_half_float_linear"),
            T.get("OES_standard_derivatives"),
            T.get("OES_element_index_uint"),
            T.get("ANGLE_instanced_arrays"),
            k = new ce(pt,T),
            S = new Lt(pt,T,t),
            (A = new ae(pt,T,k)).scissor(K.copy(ot).multiplyScalar(it)),
            A.viewport(Q.copy(rt).multiplyScalar(it)),
            R = new It(pt),
            L = new Xt,
            C = new se(pt,T,A,L,S,k,R),
            P = new St(pt),
            N = new Nt(pt,P,R),
            O = new Ut(N,R),
            F = new Bt(pt),
            I = new Wt(V,T,S),
            B = new Jt,
            U = new te,
            D = new At(V,A,N,x),
            z = new Rt(pt,T,R),
            H = new Ot(pt,T,R),
            G = new oe(V,pt,A,C,S),
            R.programs = I.programs,
            V.context = pt,
            V.capabilities = S,
            V.extensions = T,
            V.properties = L,
            V.renderLists = B,
            V.state = A,
            V.info = R
        }
        function n(t) {
            t.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            j = !0
        }
        function i() {
            console.log("THREE.WebGLRenderer: Context Restored."),
            j = !1,
            e()
        }
        function c(t) {
            (t = t.target).removeEventListener("dispose", c),
            h(t),
            L.remove(t)
        }
        function h(t) {
            var e = L.get(t).program;
            (t.program = void 0) !== e && I.releaseProgram(e)
        }
        function r() {
            var t = ft.getDevice();
            (t && t.isPresenting ? t : window).requestAnimationFrame(o)
        }
        function o(t) {
            !1 !== xt && (bt(t),
            r())
        }
        function a(t, e, n, i) {
            for (var r = 0, o = t.length; r < o; r++) {
                var a = (h = t[r]).object
                  , s = h.geometry
                  , c = void 0 === i ? h.material : i
                  , h = h.group;
                if (n.isArrayCamera)
                    for (var l = (J = n).cameras, u = 0, d = l.length; u < d; u++) {
                        var p, f = l[u];
                        a.layers.test(f.layers) && (p = f.bounds,
                        A.viewport(Q.set(p.x * et, p.y * nt, p.z * et, p.w * nt).multiplyScalar(it)),
                        m(a, e, f, s, c, h))
                    }
                else
                    J = null,
                    m(a, e, n, s, c, h)
            }
        }
        function m(t, e, n, i, r, o) {
            var a, s, c;
            t.onBeforeRender(V, e, n, i, r, o),
            M = U.get(e, J || n),
            t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld),
            t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
            t.isImmediateRenderObject ? (a = t.isMesh && t.matrixWorld.determinant() < 0,
            A.setMaterial(r, a),
            a = w(n, e.fog, r, t),
            Y = "",
            s = a,
            c = r,
            t.render(function(t) {
                V.renderBufferImmediate(t, s, c)
            })) : V.renderBufferDirect(n, e.fog, i, r, t, o),
            t.onAfterRender(V, e, n, i, r, o),
            M = U.get(e, J || n)
        }
        function p(t, e, n) {
            var i = L.get(t)
              , r = M.state.lights;
            n = I.getParameters(t, r.state, M.state.shadowsArray, e, ct.numPlanes, ct.numIntersection, n);
            var o = I.getProgramCode(t, n)
              , a = i.program
              , s = !0;
            if (void 0 === a)
                t.addEventListener("dispose", c);
            else if (a.code !== o)
                h(t);
            else {
                if (i.lightsHash !== r.state.hash)
                    L.update(t, "lightsHash", r.state.hash);
                else if (void 0 !== n.shaderID)
                    return;
                s = !1
            }
            if (s && (n.shaderID ? (a = qo[n.shaderID],
            i.shader = {
                name: t.type,
                uniforms: Go.clone(a.uniforms),
                vertexShader: a.vertexShader,
                fragmentShader: a.fragmentShader
            }) : i.shader = {
                name: t.type,
                uniforms: t.uniforms,
                vertexShader: t.vertexShader,
                fragmentShader: t.fragmentShader
            },
            t.onBeforeCompile(i.shader, V),
            a = I.acquireProgram(t, i.shader, n, o),
            i.program = a,
            t.program = a),
            n = a.getAttributes(),
            t.morphTargets)
                for (o = t.numSupportedMorphTargets = 0; o < V.maxMorphTargets; o++)
                    0 <= n["morphTarget" + o] && t.numSupportedMorphTargets++;
            if (t.morphNormals)
                for (o = t.numSupportedMorphNormals = 0; o < V.maxMorphNormals; o++)
                    0 <= n["morphNormal" + o] && t.numSupportedMorphNormals++;
            n = i.shader.uniforms,
            (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (i.numClippingPlanes = ct.numPlanes,
            i.numIntersection = ct.numIntersection,
            n.clippingPlanes = ct.uniform),
            i.fog = e,
            i.lightsHash = r.state.hash,
            t.lights && (n.ambientLightColor.value = r.state.ambient,
            n.directionalLights.value = r.state.directional,
            n.spotLights.value = r.state.spot,
            n.rectAreaLights.value = r.state.rectArea,
            n.pointLights.value = r.state.point,
            n.hemisphereLights.value = r.state.hemi,
            n.directionalShadowMap.value = r.state.directionalShadowMap,
            n.directionalShadowMatrix.value = r.state.directionalShadowMatrix,
            n.spotShadowMap.value = r.state.spotShadowMap,
            n.spotShadowMatrix.value = r.state.spotShadowMatrix,
            n.pointShadowMap.value = r.state.pointShadowMap,
            n.pointShadowMatrix.value = r.state.pointShadowMatrix),
            t = i.program.getUniforms(),
            t = Dt.seqWithValue(t.seq, n),
            i.uniformsList = t
        }
        function w(t, e, n, i) {
            tt = 0;
            var r = L.get(n)
              , o = M.state.lights;
            ht && (lt || t !== Z) && ct.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, t, r, t === Z && n.id === q),
            !1 !== n.needsUpdate || (void 0 === r.program || n.fog && r.fog !== e || n.lights && r.lightsHash !== o.state.hash || void 0 !== r.numClippingPlanes && (r.numClippingPlanes !== ct.numPlanes || r.numIntersection !== ct.numIntersection)) && (n.needsUpdate = !0),
            n.needsUpdate && (p(n, e, i),
            n.needsUpdate = !1);
            var a, s, c = !1, h = !1, l = !1, u = (o = r.program).getUniforms(), d = r.shader.uniforms;
            return A.useProgram(o.program) && (l = h = c = !0),
            n.id !== q && (q = n.id,
            h = !0),
            !c && t === Z || (u.setValue(pt, "projectionMatrix", t.projectionMatrix),
            S.logarithmicDepthBuffer && u.setValue(pt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)),
            Z !== (J || t) && (Z = J || t,
            l = h = !0),
            !(n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshStandardMaterial || n.envMap) || void 0 !== (c = u.map.cameraPosition) && c.setValue(pt, dt.setFromMatrixPosition(t.matrixWorld)),
            (n.isMeshPhongMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.skinning) && u.setValue(pt, "viewMatrix", t.matrixWorldInverse)),
            n.skinning && (u.setOptional(pt, i, "bindMatrix"),
            u.setOptional(pt, i, "bindMatrixInverse"),
            t = i.skeleton) && (c = t.bones,
            S.floatVertexTextures ? (void 0 === t.boneTexture && (c = Math.sqrt(4 * c.length),
            c = io.ceilPowerOfTwo(c),
            c = Math.max(c, 4),
            (a = new Float32Array(c * c * 4)).set(t.boneMatrices),
            (s = new Mt(a,c,c,1023,1015)).needsUpdate = !0,
            t.boneMatrices = a,
            t.boneTexture = s,
            t.boneTextureSize = c),
            u.setValue(pt, "boneTexture", t.boneTexture),
            u.setValue(pt, "boneTextureSize", t.boneTextureSize)) : u.setOptional(pt, t, "boneMatrices")),
            h && (u.setValue(pt, "toneMappingExposure", V.toneMappingExposure),
            u.setValue(pt, "toneMappingWhitePoint", V.toneMappingWhitePoint),
            n.lights && (h = l,
            d.ambientLightColor.needsUpdate = h,
            d.directionalLights.needsUpdate = h,
            d.pointLights.needsUpdate = h,
            d.spotLights.needsUpdate = h,
            d.rectAreaLights.needsUpdate = h,
            d.hemisphereLights.needsUpdate = h),
            e && n.fog && (d.fogColor.value = e.color,
            e.isFog ? (d.fogNear.value = e.near,
            d.fogFar.value = e.far) : e.isFogExp2 && (d.fogDensity.value = e.density)),
            n.isMeshBasicMaterial ? f(d, n) : n.isMeshLambertMaterial ? (f(d, n),
            n.emissiveMap && (d.emissiveMap.value = n.emissiveMap)) : n.isMeshPhongMaterial ? (f(d, n),
            n.isMeshToonMaterial ? (g(d, n),
            n.gradientMap && (d.gradientMap.value = n.gradientMap)) : g(d, n)) : n.isMeshStandardMaterial ? (f(d, n),
            n.isMeshPhysicalMaterial && (d.clearCoat.value = n.clearCoat,
            d.clearCoatRoughness.value = n.clearCoatRoughness),
            d.roughness.value = n.roughness,
            d.metalness.value = n.metalness,
            n.roughnessMap && (d.roughnessMap.value = n.roughnessMap),
            n.metalnessMap && (d.metalnessMap.value = n.metalnessMap),
            n.emissiveMap && (d.emissiveMap.value = n.emissiveMap),
            n.bumpMap && (d.bumpMap.value = n.bumpMap,
            d.bumpScale.value = n.bumpScale),
            n.normalMap && (d.normalMap.value = n.normalMap,
            d.normalScale.value.copy(n.normalScale)),
            n.displacementMap && (d.displacementMap.value = n.displacementMap,
            d.displacementScale.value = n.displacementScale,
            d.displacementBias.value = n.displacementBias),
            n.envMap && (d.envMapIntensity.value = n.envMapIntensity)) : n.isMeshDepthMaterial ? (f(d, n),
            n.displacementMap && (d.displacementMap.value = n.displacementMap,
            d.displacementScale.value = n.displacementScale,
            d.displacementBias.value = n.displacementBias)) : n.isMeshDistanceMaterial ? (f(d, n),
            n.displacementMap && (d.displacementMap.value = n.displacementMap,
            d.displacementScale.value = n.displacementScale,
            d.displacementBias.value = n.displacementBias),
            d.referencePosition.value.copy(n.referencePosition),
            d.nearDistance.value = n.nearDistance,
            d.farDistance.value = n.farDistance) : n.isMeshNormalMaterial ? (f(d, n),
            n.bumpMap && (d.bumpMap.value = n.bumpMap,
            d.bumpScale.value = n.bumpScale),
            n.normalMap && (d.normalMap.value = n.normalMap,
            d.normalScale.value.copy(n.normalScale)),
            n.displacementMap && (d.displacementMap.value = n.displacementMap,
            d.displacementScale.value = n.displacementScale,
            d.displacementBias.value = n.displacementBias)) : n.isLineBasicMaterial ? (d.diffuse.value = n.color,
            d.opacity.value = n.opacity,
            n.isLineDashedMaterial && (d.dashSize.value = n.dashSize,
            d.totalSize.value = n.dashSize + n.gapSize,
            d.scale.value = n.scale)) : n.isPointsMaterial ? (d.diffuse.value = n.color,
            d.opacity.value = n.opacity,
            d.size.value = n.size * it,
            d.scale.value = .5 * nt,
            d.map.value = n.map,
            null !== n.map && (!0 === n.map.matrixAutoUpdate && n.map.updateMatrix(),
            d.uvTransform.value.copy(n.map.matrix))) : n.isShadowMaterial && (d.color.value = n.color,
            d.opacity.value = n.opacity),
            void 0 !== d.ltc_1 && (d.ltc_1.value = Xo.LTC_1),
            void 0 !== d.ltc_2 && (d.ltc_2.value = Xo.LTC_2),
            Dt.upload(pt, r.uniformsList, d, V)),
            n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (Dt.upload(pt, r.uniformsList, d, V),
            n.uniformsNeedUpdate = !1),
            u.setValue(pt, "modelViewMatrix", i.modelViewMatrix),
            u.setValue(pt, "normalMatrix", i.normalMatrix),
            u.setValue(pt, "modelMatrix", i.matrixWorld),
            o
        }
        function f(t, e) {
            var n;
            t.opacity.value = e.opacity,
            e.color && (t.diffuse.value = e.color),
            e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity),
            e.map && (t.map.value = e.map),
            e.alphaMap && (t.alphaMap.value = e.alphaMap),
            e.specularMap && (t.specularMap.value = e.specularMap),
            e.envMap && (t.envMap.value = e.envMap,
            t.flipEnvMap.value = e.envMap && e.envMap.isCubeTexture ? -1 : 1,
            t.reflectivity.value = e.reflectivity,
            t.refractionRatio.value = e.refractionRatio,
            t.maxMipLevel.value = L.get(e.envMap).__maxMipLevel),
            e.lightMap && (t.lightMap.value = e.lightMap,
            t.lightMapIntensity.value = e.lightMapIntensity),
            e.aoMap && (t.aoMap.value = e.aoMap,
            t.aoMapIntensity.value = e.aoMapIntensity),
            e.map ? n = e.map : e.specularMap ? n = e.specularMap : e.displacementMap ? n = e.displacementMap : e.normalMap ? n = e.normalMap : e.bumpMap ? n = e.bumpMap : e.roughnessMap ? n = e.roughnessMap : e.metalnessMap ? n = e.metalnessMap : e.alphaMap ? n = e.alphaMap : e.emissiveMap && (n = e.emissiveMap),
            void 0 !== n && (!0 === (n = n.isWebGLRenderTarget ? n.texture : n).matrixAutoUpdate && n.updateMatrix(),
            t.uvTransform.value.copy(n.matrix))
        }
        function g(t, e) {
            t.specular.value = e.specular,
            t.shininess.value = Math.max(e.shininess, 1e-4),
            e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
            e.bumpMap && (t.bumpMap.value = e.bumpMap,
            t.bumpScale.value = e.bumpScale),
            e.normalMap && (t.normalMap.value = e.normalMap,
            t.normalScale.value.copy(e.normalScale)),
            e.displacementMap && (t.displacementMap.value = e.displacementMap,
            t.displacementScale.value = e.displacementScale,
            t.displacementBias.value = e.displacementBias)
        }
        console.log("THREE.WebGLRenderer", "92");
        var s = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
          , l = void 0 !== t.context ? t.context : null
          , u = void 0 !== t.alpha && t.alpha
          , d = void 0 === t.depth || t.depth
          , v = void 0 === t.stencil || t.stencil
          , y = void 0 !== t.antialias && t.antialias
          , x = void 0 === t.premultipliedAlpha || t.premultipliedAlpha
          , b = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer
          , _ = void 0 !== t.powerPreference ? t.powerPreference : "default"
          , E = null
          , M = null;
        this.domElement = s,
        this.context = null,
        this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this.gammaFactor = 2,
        this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1,
        this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1,
        this.maxMorphTargets = 8,
        this.maxMorphNormals = 4;
        var T, S, A, R, L, C, P, N, O, I, B, U, D, F, z, H, G, k, V = this, j = !1, W = null, X = null, q = -1, Y = "", Z = null, J = null, Q = new Et, K = new Et, $ = null, tt = 0, et = s.width, nt = s.height, it = 1, rt = new Et(0,0,et,nt), ot = new Et(0,0,et,nt), at = !1, st = new Tt, ct = new Ct, ht = !1, lt = !1, ut = new _t, dt = new wt;
        try {
            u = {
                alpha: u,
                depth: d,
                stencil: v,
                antialias: y,
                premultipliedAlpha: x,
                preserveDrawingBuffer: b,
                powerPreference: _
            },
            s.addEventListener("webglcontextlost", n, !1),
            s.addEventListener("webglcontextrestored", i, !1);
            var pt = l || s.getContext("webgl", u) || s.getContext("experimental-webgl", u);
            if (null === pt) {
                if (null !== s.getContext("webgl"))
                    throw Error("Error creating WebGL context with your selected attributes.");
                throw Error("Error creating WebGL context.")
            }
            void 0 === pt.getShaderPrecisionFormat && (pt.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            }
            )
        } catch (t) {
            console.error("THREE.WebGLRenderer: " + t.message)
        }
        e();
        var ft = new ue(V);
        this.vr = ft;
        var mt = new ie(V,O,S.maxTextureSize);
        this.shadowMap = mt,
        this.getContext = function() {
            return pt
        }
        ,
        this.getContextAttributes = function() {
            return pt.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            var t = T.get("WEBGL_lose_context");
            t && t.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            var t = T.get("WEBGL_lose_context");
            t && t.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return it
        }
        ,
        this.setPixelRatio = function(t) {
            void 0 !== t && (it = t,
            this.setSize(et, nt, !1))
        }
        ,
        this.getSize = function() {
            return {
                width: et,
                height: nt
            }
        }
        ,
        this.setSize = function(t, e, n) {
            var i = ft.getDevice();
            i && i.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (et = t,
            nt = e,
            s.width = t * it,
            s.height = e * it,
            !1 !== n && (s.style.width = t + "px",
            s.style.height = e + "px"),
            this.setViewport(0, 0, t, e))
        }
        ,
        this.getDrawingBufferSize = function() {
            return {
                width: et * it,
                height: nt * it
            }
        }
        ,
        this.setDrawingBufferSize = function(t, e, n) {
            et = t,
            nt = e,
            it = n,
            s.width = t * n,
            s.height = e * n,
            this.setViewport(0, 0, t, e)
        }
        ,
        this.getCurrentViewport = function() {
            return Q
        }
        ,
        this.setViewport = function(t, e, n, i) {
            rt.set(t, nt - e - i, n, i),
            A.viewport(Q.copy(rt).multiplyScalar(it))
        }
        ,
        this.setScissor = function(t, e, n, i) {
            ot.set(t, nt - e - i, n, i),
            A.scissor(K.copy(ot).multiplyScalar(it))
        }
        ,
        this.setScissorTest = function(t) {
            A.setScissorTest(at = t)
        }
        ,
        this.getClearColor = function() {
            return D.getClearColor()
        }
        ,
        this.setClearColor = function() {
            D.setClearColor.apply(D, arguments)
        }
        ,
        this.getClearAlpha = function() {
            return D.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            D.setClearAlpha.apply(D, arguments)
        }
        ,
        this.clear = function(t, e, n) {
            var i = 0;
            void 0 !== t && !t || (i |= pt.COLOR_BUFFER_BIT),
            void 0 !== e && !e || (i |= pt.DEPTH_BUFFER_BIT),
            void 0 !== n && !n || (i |= pt.STENCIL_BUFFER_BIT),
            pt.clear(i)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.clearTarget = function(t, e, n, i) {
            this.setRenderTarget(t),
            this.clear(e, n, i)
        }
        ,
        this.dispose = function() {
            s.removeEventListener("webglcontextlost", n, !1),
            s.removeEventListener("webglcontextrestored", i, !1),
            B.dispose(),
            U.dispose(),
            L.dispose(),
            O.dispose(),
            ft.dispose(),
            xt = !1
        }
        ,
        this.renderBufferImmediate = function(t, e, n) {
            A.initAttributes();
            var i = L.get(t);
            if (t.hasPositions && !i.position && (i.position = pt.createBuffer()),
            t.hasNormals && !i.normal && (i.normal = pt.createBuffer()),
            t.hasUvs && !i.uv && (i.uv = pt.createBuffer()),
            t.hasColors && !i.color && (i.color = pt.createBuffer()),
            e = e.getAttributes(),
            t.hasPositions && (pt.bindBuffer(pt.ARRAY_BUFFER, i.position),
            pt.bufferData(pt.ARRAY_BUFFER, t.positionArray, pt.DYNAMIC_DRAW),
            A.enableAttribute(e.position),
            pt.vertexAttribPointer(e.position, 3, pt.FLOAT, !1, 0, 0)),
            t.hasNormals) {
                if (pt.bindBuffer(pt.ARRAY_BUFFER, i.normal),
                !n.isMeshPhongMaterial && !n.isMeshStandardMaterial && !n.isMeshNormalMaterial && !0 === n.flatShading)
                    for (var r = 0, o = 3 * t.count; r < o; r += 9) {
                        var a = t.normalArray
                          , s = (a[r + 0] + a[r + 3] + a[r + 6]) / 3
                          , c = (a[r + 1] + a[r + 4] + a[r + 7]) / 3
                          , h = (a[r + 2] + a[r + 5] + a[r + 8]) / 3;
                        a[r + 0] = s,
                        a[r + 1] = c,
                        a[r + 2] = h,
                        a[r + 3] = s,
                        a[r + 4] = c,
                        a[r + 5] = h,
                        a[r + 6] = s,
                        a[r + 7] = c,
                        a[r + 8] = h
                    }
                pt.bufferData(pt.ARRAY_BUFFER, t.normalArray, pt.DYNAMIC_DRAW),
                A.enableAttribute(e.normal),
                pt.vertexAttribPointer(e.normal, 3, pt.FLOAT, !1, 0, 0)
            }
            t.hasUvs && n.map && (pt.bindBuffer(pt.ARRAY_BUFFER, i.uv),
            pt.bufferData(pt.ARRAY_BUFFER, t.uvArray, pt.DYNAMIC_DRAW),
            A.enableAttribute(e.uv),
            pt.vertexAttribPointer(e.uv, 2, pt.FLOAT, !1, 0, 0)),
            t.hasColors && 0 !== n.vertexColors && (pt.bindBuffer(pt.ARRAY_BUFFER, i.color),
            pt.bufferData(pt.ARRAY_BUFFER, t.colorArray, pt.DYNAMIC_DRAW),
            A.enableAttribute(e.color),
            pt.vertexAttribPointer(e.color, 3, pt.FLOAT, !1, 0, 0)),
            A.disableUnusedAttributes(),
            pt.drawArrays(pt.TRIANGLES, 0, t.count),
            t.count = 0
        }
        ,
        this.renderBufferDirect = function(t, e, n, i, r, o) {
            var a = r.isMesh && r.matrixWorld.determinant() < 0;
            A.setMaterial(i, a);
            var s = w(t, e, i, r)
              , c = !1;
            (t = n.id + "_" + s.id + "_" + (!0 === i.wireframe)) !== Y && (Y = t,
            c = !0),
            r.morphTargetInfluences && (F.update(r, n, i, s),
            c = !0);
            var h, a = n.index, l = n.attributes.position;
            if (e = 1,
            !0 === i.wireframe && (a = N.getWireframeAttribute(n),
            e = 2),
            t = z,
            null !== a && (h = P.get(a),
            (t = H).setIndex(h)),
            c) {
                if (n && n.isInstancedBufferGeometry && null === T.get("ANGLE_instanced_arrays"))
                    console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                else {
                    A.initAttributes();
                    var c = n.attributes
                      , s = s.getAttributes()
                      , u = i.defaultAttributeValues;
                    for (_ in s) {
                        var d = s[_];
                        if (0 <= d)
                            if (void 0 !== (v = c[_])) {
                                var p, f, m, g, v, y = v.normalized, x = v.itemSize, b = P.get(v);
                                void 0 !== b && (p = b.buffer,
                                f = b.type,
                                b = b.bytesPerElement,
                                v.isInterleavedBufferAttribute ? (g = (m = v.data).stride,
                                v = v.offset,
                                m && m.isInstancedInterleavedBuffer ? (A.enableAttributeAndDivisor(d, m.meshPerAttribute),
                                void 0 === n.maxInstancedCount && (n.maxInstancedCount = m.meshPerAttribute * m.count)) : A.enableAttribute(d),
                                pt.bindBuffer(pt.ARRAY_BUFFER, p),
                                pt.vertexAttribPointer(d, x, f, y, g * b, v * b)) : (v.isInstancedBufferAttribute ? (A.enableAttributeAndDivisor(d, v.meshPerAttribute),
                                void 0 === n.maxInstancedCount && (n.maxInstancedCount = v.meshPerAttribute * v.count)) : A.enableAttribute(d),
                                pt.bindBuffer(pt.ARRAY_BUFFER, p),
                                pt.vertexAttribPointer(d, x, f, y, 0, 0)))
                            } else if (void 0 !== u && void 0 !== (y = u[_]))
                                switch (y.length) {
                                case 2:
                                    pt.vertexAttrib2fv(d, y);
                                    break;
                                case 3:
                                    pt.vertexAttrib3fv(d, y);
                                    break;
                                case 4:
                                    pt.vertexAttrib4fv(d, y);
                                    break;
                                default:
                                    pt.vertexAttrib1fv(d, y)
                                }
                    }
                    A.disableUnusedAttributes()
                }
                null !== a && pt.bindBuffer(pt.ELEMENT_ARRAY_BUFFER, h.buffer)
            }
            h = 1 / 0,
            null !== a ? h = a.count : void 0 !== l && (h = l.count),
            a = n.drawRange.start * e;
            var l = null !== o ? o.start * e : 0
              , _ = Math.max(a, l);
            if (0 !== (o = Math.max(0, Math.min(h, a + n.drawRange.count * e, l + (null !== o ? o.count * e : 1 / 0)) - 1 - _ + 1))) {
                if (r.isMesh)
                    if (!0 === i.wireframe)
                        A.setLineWidth(i.wireframeLinewidth * (null === W ? it : 1)),
                        t.setMode(pt.LINES);
                    else
                        switch (r.drawMode) {
                        case 0:
                            t.setMode(pt.TRIANGLES);
                            break;
                        case 1:
                            t.setMode(pt.TRIANGLE_STRIP);
                            break;
                        case 2:
                            t.setMode(pt.TRIANGLE_FAN)
                        }
                else
                    r.isLine ? (i = i.linewidth,
                    A.setLineWidth((i = void 0 === i ? 1 : i) * (null === W ? it : 1)),
                    r.isLineSegments ? t.setMode(pt.LINES) : r.isLineLoop ? t.setMode(pt.LINE_LOOP) : t.setMode(pt.LINE_STRIP)) : r.isPoints && t.setMode(pt.POINTS);
                n && n.isInstancedBufferGeometry ? 0 < n.maxInstancedCount && t.renderInstances(n, _, o) : t.render(_, o)
            }
        }
        ;
        var gt, vt, yt, xt = !(this.compile = function(n, t) {
            (M = U.get(n, t)).init(),
            n.traverse(function(t) {
                t.isLight && (M.pushLight(t),
                t.castShadow && M.pushShadow(t))
            }),
            M.setupLights(t),
            n.traverse(function(t) {
                if (t.material)
                    if (Array.isArray(t.material))
                        for (var e = 0; e < t.material.length; e++)
                            p(t.material[e], n.fog, t);
                    else
                        p(t.material, n.fog, t)
            })
        }
        ), bt = null;
        this.animate = function(t) {
            null !== (bt = t) ? xt || (r(),
            xt = !0) : xt = !1
        }
        ,
        this.render = function(t, e, n, i) {
            var r, o;
            e && e.isCamera ? j || (Y = "",
            q = -1,
            !(Z = null) === t.autoUpdate && t.updateMatrixWorld(),
            null === e.parent && e.updateMatrixWorld(),
            ft.enabled && (e = ft.getCamera(e)),
            (M = U.get(t, e)).init(),
            t.onBeforeRender(V, t, e, n),
            ut.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
            st.setFromMatrix(ut),
            lt = this.localClippingEnabled,
            ht = ct.init(this.clippingPlanes, lt, e),
            (E = B.get(t, e)).init(),
            function t(e, n, i) {
                if (!1 !== e.visible) {
                    if (e.layers.test(n.layers))
                        if (e.isLight)
                            M.pushLight(e),
                            e.castShadow && M.pushShadow(e);
                        else if (e.isSprite)
                            e.frustumCulled && !st.intersectsSprite(e) || M.pushSprite(e);
                        else if (e.isImmediateRenderObject)
                            i && dt.setFromMatrixPosition(e.matrixWorld).applyMatrix4(ut),
                            E.push(e, null, e.material, dt.z, null);
                        else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.update(),
                        !e.frustumCulled || st.intersectsObject(e))) {
                            i && dt.setFromMatrixPosition(e.matrixWorld).applyMatrix4(ut);
                            var r = O.update(e)
                              , o = e.material;
                            if (Array.isArray(o))
                                for (var a = r.groups, s = 0, c = a.length; s < c; s++) {
                                    var h = a[s]
                                      , l = o[h.materialIndex];
                                    l && l.visible && E.push(e, r, l, dt.z, h)
                                }
                            else
                                o.visible && E.push(e, r, o, dt.z, null)
                        }
                    for (s = 0,
                    c = (e = e.children).length; s < c; s++)
                        t(e[s], n, i)
                }
            }(t, e, V.sortObjects),
            !0 === V.sortObjects && E.sort(),
            ht && ct.beginShadows(),
            mt.render(M.state.shadowsArray, t, e),
            M.setupLights(e),
            ht && ct.endShadows(),
            this.info.autoReset && this.info.reset(),
            this.setRenderTarget(n = void 0 === n ? null : n),
            D.render(E, t, e, i),
            i = E.opaque,
            r = E.transparent,
            t.overrideMaterial ? (o = t.overrideMaterial,
            i.length && a(i, t, e, o),
            r.length && a(r, t, e, o)) : (i.length && a(i, t, e),
            r.length && a(r, t, e)),
            G.render(M.state.spritesArray, t, e),
            n && C.updateRenderTargetMipmap(n),
            A.buffers.depth.setTest(!0),
            A.buffers.depth.setMask(!0),
            A.buffers.color.setMask(!0),
            A.setPolygonOffset(!1),
            t.onAfterRender(V, t, e),
            ft.enabled && ft.submitFrame(),
            M = E = null) : console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
        }
        ,
        this.allocTextureUnit = function() {
            var t = tt;
            return t >= S.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + t + " texture units while this GPU supports only " + S.maxTextures),
            tt += 1,
            t
        }
        ,
        this.setTexture2D = (gt = !1,
        function(t, e) {
            t && t.isWebGLRenderTarget && (gt || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."),
            gt = !0),
            t = t.texture),
            C.setTexture2D(t, e)
        }
        ),
        this.setTexture = (vt = !1,
        function(t, e) {
            vt || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."),
            vt = !0),
            C.setTexture2D(t, e)
        }
        ),
        this.setTextureCube = (yt = !1,
        function(t, e) {
            t && t.isWebGLRenderTargetCube && (yt || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."),
            yt = !0),
            t = t.texture),
            t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? C.setTextureCube(t, e) : C.setTextureCubeDynamic(t, e)
        }
        ),
        this.getRenderTarget = function() {
            return W
        }
        ,
        this.setRenderTarget = function(t) {
            (W = t) && void 0 === L.get(t).__webglFramebuffer && C.setupRenderTarget(t);
            var e = null
              , n = !1;
            $ = t ? (e = L.get(t).__webglFramebuffer,
            t.isWebGLRenderTargetCube && (e = e[t.activeCubeFace],
            n = !0),
            Q.copy(t.viewport),
            K.copy(t.scissor),
            t.scissorTest) : (Q.copy(rt).multiplyScalar(it),
            K.copy(ot).multiplyScalar(it),
            at),
            X !== e && (pt.bindFramebuffer(pt.FRAMEBUFFER, e),
            X = e),
            A.viewport(Q),
            A.scissor(K),
            A.setScissorTest($),
            n && (n = L.get(t.texture),
            pt.framebufferTexture2D(pt.FRAMEBUFFER, pt.COLOR_ATTACHMENT0, pt.TEXTURE_CUBE_MAP_POSITIVE_X + t.activeCubeFace, n.__webglTexture, t.activeMipMapLevel))
        }
        ,
        this.readRenderTargetPixels = function(t, e, n, i, r, o) {
            if (t && t.isWebGLRenderTarget) {
                var a = L.get(t).__webglFramebuffer;
                if (a) {
                    var s = !1;
                    a !== X && (pt.bindFramebuffer(pt.FRAMEBUFFER, a),
                    s = !0);
                    try {
                        var c = t.texture
                          , h = c.format
                          , l = c.type;
                        1023 !== h && k.convert(h) !== pt.getParameter(pt.IMPLEMENTATION_COLOR_READ_FORMAT) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === l || k.convert(l) === pt.getParameter(pt.IMPLEMENTATION_COLOR_READ_TYPE) || 1015 === l && (T.get("OES_texture_float") || T.get("WEBGL_color_buffer_float")) || 1016 === l && T.get("EXT_color_buffer_half_float") ? pt.checkFramebufferStatus(pt.FRAMEBUFFER) === pt.FRAMEBUFFER_COMPLETE ? 0 <= e && e <= t.width - i && 0 <= n && n <= t.height - r && pt.readPixels(e, n, i, r, k.convert(h), k.convert(l), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.")
                    } finally {
                        s && pt.bindFramebuffer(pt.FRAMEBUFFER, X)
                    }
                }
            } else
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
        }
        ,
        this.copyFramebufferToTexture = function(t, e, n) {
            var i = e.image.width
              , r = e.image.height
              , o = k.convert(e.format);
            this.setTexture2D(e, 0),
            pt.copyTexImage2D(pt.TEXTURE_2D, n || 0, o, t.x, t.y, i, r, 0)
        }
        ,
        this.copyTextureToTexture = function(t, e, n, i) {
            var r = e.image.width
              , o = e.image.height
              , a = k.convert(n.format)
              , s = k.convert(n.type);
            e = e.isDataTexture ? e.image.data : e.image,
            this.setTexture2D(n, 0),
            pt.texSubImage2D(pt.TEXTURE_2D, i || 0, t.x, t.y, r, o, a, s, e)
        }
    }
    function pe(t, e) {
        this.name = "",
        this.color = new w(t),
        this.density = void 0 !== e ? e : 25e-5
    }
    function fe(t, e, n) {
        this.name = "",
        this.color = new w(t),
        this.near = void 0 !== e ? e : 1,
        this.far = void 0 !== n ? n : 1e3
    }
    function me() {
        l.call(this),
        this.type = "Scene",
        this.overrideMaterial = this.fog = this.background = null,
        this.autoUpdate = !0
    }
    function ge(t) {
        I.call(this),
        this.type = "SpriteMaterial",
        this.color = new w(16777215),
        this.map = null,
        this.rotation = 0,
        this.lights = this.fog = !1,
        this.setValues(t)
    }
    function ve(t) {
        l.call(this),
        this.type = "Sprite",
        this.material = void 0 !== t ? t : new ge,
        this.center = new W(.5,.5)
    }
    function ye() {
        l.call(this),
        this.type = "LOD",
        Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }
        })
    }
    function xe(t, e) {
        if (this.bones = (t = t || []).slice(0),
        this.boneMatrices = new Float32Array(16 * this.bones.length),
        void 0 === e)
            this.calculateInverses();
        else if (this.bones.length === e.length)
            this.boneInverses = e.slice(0);
        else
            for (console.warn("THREE.Skeleton boneInverses is the wrong length."),
            this.boneInverses = [],
            t = 0,
            e = this.bones.length; t < e; t++)
                this.boneInverses.push(new _t)
    }
    function be() {
        l.call(this),
        this.type = "Bone"
    }
    function _e(t, e) {
        H.call(this, t, e),
        this.type = "SkinnedMesh",
        this.bindMode = "attached",
        this.bindMatrix = new _t,
        this.bindMatrixInverse = new _t,
        t = new xe(t = this.initBones()),
        this.bind(t, this.matrixWorld),
        this.normalizeSkinWeights()
    }
    function we(t) {
        I.call(this),
        this.type = "LineBasicMaterial",
        this.color = new w(16777215),
        this.linewidth = 1,
        this.linejoin = this.linecap = "round",
        this.lights = !1,
        this.setValues(t)
    }
    function Ee(t, e, n) {
        if (1 === n)
            return console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."),
            new Me(t,e);
        l.call(this),
        this.type = "Line",
        this.geometry = void 0 !== t ? t : new C,
        this.material = void 0 !== e ? e : new we({
            color: 16777215 * Math.random()
        })
    }
    function Me(t, e) {
        Ee.call(this, t, e),
        this.type = "LineSegments"
    }
    function Te(t, e) {
        Ee.call(this, t, e),
        this.type = "LineLoop"
    }
    function Se(t) {
        I.call(this),
        this.type = "PointsMaterial",
        this.color = new w(16777215),
        this.map = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.lights = !1,
        this.setValues(t)
    }
    function Ae(t, e) {
        l.call(this),
        this.type = "Points",
        this.geometry = void 0 !== t ? t : new C,
        this.material = void 0 !== e ? e : new Se({
            color: 16777215 * Math.random()
        })
    }
    function Re() {
        l.call(this),
        this.type = "Group"
    }
    function Le(t, e, n, i, r, o, a, s, c) {
        d.call(this, t, e, n, i, r, o, a, s, c),
        this.generateMipmaps = !1
    }
    function Ce(t, e, n, i, r, o, a, s, c, h, l, u) {
        d.call(this, null, o, a, s, c, h, i, r, l, u),
        this.image = {
            width: e,
            height: n
        },
        this.mipmaps = t,
        this.generateMipmaps = this.flipY = !1
    }
    function Pe(t, e, n, i, r, o, a, s, c, h) {
        if (1026 !== (h = void 0 !== h ? h : 1026) && 1027 !== h)
            throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        d.call(this, null, i, r, o, a, s, h, n = void 0 === (n = void 0 === n && 1026 === h ? 1012 : n) && 1027 === h ? 1020 : n, c),
        this.image = {
            width: t,
            height: e
        },
        this.magFilter = void 0 !== a ? a : 1003,
        this.minFilter = void 0 !== s ? s : 1003,
        this.generateMipmaps = this.flipY = !1
    }
    function Ne(t) {
        C.call(this),
        this.type = "WireframeGeometry";
        var e = []
          , n = [0, 0]
          , i = {}
          , r = ["a", "b", "c"];
        if (t && t.isGeometry) {
            for (var o = t.faces, a = 0, s = o.length; a < s; a++)
                for (var c = o[a], h = 0; h < 3; h++) {
                    var l = c[r[h]]
                      , u = c[r[(h + 1) % 3]];
                    n[0] = Math.min(l, u),
                    n[1] = Math.max(l, u),
                    void 0 === i[l = n[0] + "," + n[1]] && (i[l] = {
                        index1: n[0],
                        index2: n[1]
                    })
                }
            for (l in i)
                a = i[l],
                r = t.vertices[a.index1],
                e.push(r.x, r.y, r.z),
                r = t.vertices[a.index2],
                e.push(r.x, r.y, r.z)
        } else if (t && t.isBufferGeometry)
            if (r = new wt,
            null !== t.index) {
                for (var o = t.attributes.position, c = t.index, d = t.groups, p = (d = (t = 0) === d.length ? [{
                    start: 0,
                    count: c.count,
                    materialIndex: 0
                }] : d).length; t < p; ++t)
                    for (h = (a = d[t]).start,
                    s = a.count,
                    s = (a = h) + s; a < s; a += 3)
                        for (h = 0; h < 3; h++)
                            l = c.getX(a + h),
                            u = c.getX(a + (h + 1) % 3),
                            n[0] = Math.min(l, u),
                            n[1] = Math.max(l, u),
                            void 0 === i[l = n[0] + "," + n[1]] && (i[l] = {
                                index1: n[0],
                                index2: n[1]
                            });
                for (l in i)
                    a = i[l],
                    r.fromBufferAttribute(o, a.index1),
                    e.push(r.x, r.y, r.z),
                    r.fromBufferAttribute(o, a.index2),
                    e.push(r.x, r.y, r.z)
            } else
                for (a = 0,
                s = (o = t.attributes.position).count / 3; a < s; a++)
                    for (h = 0; h < 3; h++)
                        r.fromBufferAttribute(o, i = 3 * a + h),
                        e.push(r.x, r.y, r.z),
                        r.fromBufferAttribute(o, i = 3 * a + (h + 1) % 3),
                        e.push(r.x, r.y, r.z);
        this.addAttribute("position", new L(e,3))
    }
    function Oe(t, e, n) {
        M.call(this),
        this.type = "ParametricGeometry",
        this.parameters = {
            func: t,
            slices: e,
            stacks: n
        },
        this.fromBufferGeometry(new Ie(t,e,n)),
        this.mergeVertices()
    }
    function Ie(t, e, n) {
        C.call(this),
        this.type = "ParametricBufferGeometry",
        this.parameters = {
            func: t,
            slices: e,
            stacks: n
        };
        for (var i = [], r = [], o = [], a = [], s = new wt, c = new wt, h = new wt, l = new wt, u = new wt, d = e + 1, p = 0; p <= n; p++)
            for (var f = p / n, m = 0; m <= e; m++) {
                var g = m / e;
                t(g, f, c),
                r.push(c.x, c.y, c.z),
                0 <= g - 1e-5 ? (t(g - 1e-5, f, h),
                l.subVectors(c, h)) : (t(1e-5 + g, f, h),
                l.subVectors(h, c)),
                0 <= f - 1e-5 ? (t(g, f - 1e-5, h),
                u.subVectors(c, h)) : (t(g, 1e-5 + f, h),
                u.subVectors(h, c)),
                s.crossVectors(l, u).normalize(),
                o.push(s.x, s.y, s.z),
                a.push(g, f)
            }
        for (p = 0; p < n; p++)
            for (m = 0; m < e; m++)
                s = (p + 1) * d + m + 1,
                i.push(p * d + m, t = p * d + m + 1, c = (p + 1) * d + m),
                i.push(t, s, c);
        this.setIndex(i),
        this.addAttribute("position", new L(r,3)),
        this.addAttribute("normal", new L(o,3)),
        this.addAttribute("uv", new L(a,2))
    }
    function Be(t, e, n, i) {
        M.call(this),
        this.type = "PolyhedronGeometry",
        this.parameters = {
            vertices: t,
            indices: e,
            radius: n,
            detail: i
        },
        this.fromBufferGeometry(new Ue(t,e,n,i)),
        this.mergeVertices()
    }
    function Ue(n, m, t, e) {
        function g(t) {
            u.push(t.x, t.y, t.z)
        }
        function v(t, e) {
            e.x = n[(t *= 3) + 0],
            e.y = n[t + 1],
            e.z = n[t + 2]
        }
        function l(t, e, n, i) {
            i < 0 && 1 === t.x && (d[e] = t.x - 1),
            0 === n.x && 0 === n.z && (d[e] = i / 2 / Math.PI + .5)
        }
        C.call(this),
        this.type = "PolyhedronBufferGeometry",
        this.parameters = {
            vertices: n,
            indices: m,
            radius: t,
            detail: e
        },
        t = t || 1;
        var u = []
          , d = [];
        !function(t) {
            for (var e = new wt, n = new wt, i = new wt, r = 0; r < m.length; r += 3) {
                v(m[r + 0], e),
                v(m[r + 1], n),
                v(m[r + 2], i);
                for (var o = e, a = n, s = i, c = Math.pow(2, t), h = [], l = 0; l <= c; l++) {
                    h[l] = [];
                    for (var u = o.clone().lerp(s, l / c), d = a.clone().lerp(s, l / c), p = c - l, f = 0; f <= p; f++)
                        h[l][f] = 0 === f && l === c ? u : u.clone().lerp(d, f / p)
                }
                for (l = 0; l < c; l++)
                    for (f = 0; f < 2 * (c - l) - 1; f++)
                        o = Math.floor(f / 2),
                        0 == f % 2 ? (g(h[l][o + 1]),
                        g(h[l + 1][o]),
                        g(h[l][o])) : (g(h[l][o + 1]),
                        g(h[l + 1][o + 1]),
                        g(h[l + 1][o]))
            }
        }(e = e || 0),
        function(t) {
            for (var e = new wt, n = 0; n < u.length; n += 3)
                e.x = u[n + 0],
                e.y = u[n + 1],
                e.z = u[n + 2],
                e.normalize().multiplyScalar(t),
                u[n + 0] = e.x,
                u[n + 1] = e.y,
                u[n + 2] = e.z
        }(t),
        function() {
            for (var t = new wt, e = 0; e < u.length; e += 3)
                t.x = u[e + 0],
                t.y = u[e + 1],
                t.z = u[e + 2],
                d.push(Math.atan2(t.z, -t.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) / Math.PI + .5));
            for (var t = new wt, e = new wt, n = new wt, i = new wt, r = new W, o = new W, a = new W, s = 0, c = 0; s < u.length; s += 9,
            c += 6) {
                t.set(u[s + 0], u[s + 1], u[s + 2]),
                e.set(u[s + 3], u[s + 4], u[s + 5]),
                n.set(u[s + 6], u[s + 7], u[s + 8]),
                r.set(d[c + 0], d[c + 1]),
                o.set(d[c + 2], d[c + 3]),
                a.set(d[c + 4], d[c + 5]),
                i.copy(t).add(e).add(n).divideScalar(3);
                var h = Math.atan2(i.z, -i.x);
                l(r, c + 0, t, h),
                l(o, c + 2, e, h),
                l(a, c + 4, n, h)
            }
            for (t = 0; t < d.length; t += 6)
                e = d[t + 0],
                n = d[t + 2],
                i = d[t + 4],
                r = Math.min(e, n, i),
                .9 < Math.max(e, n, i) && r < .1 && (e < .2 && (d[t + 0] += 1),
                n < .2 && (d[t + 2] += 1),
                i < .2 && (d[t + 4] += 1))
        }(),
        this.addAttribute("position", new L(u,3)),
        this.addAttribute("normal", new L(u.slice(),3)),
        this.addAttribute("uv", new L(d,2)),
        0 === e ? this.computeVertexNormals() : this.normalizeNormals()
    }
    function De(t, e) {
        M.call(this),
        this.type = "TetrahedronGeometry",
        this.parameters = {
            radius: t,
            detail: e
        },
        this.fromBufferGeometry(new Fe(t,e)),
        this.mergeVertices()
    }
    function Fe(t, e) {
        Ue.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e),
        this.type = "TetrahedronBufferGeometry",
        this.parameters = {
            radius: t,
            detail: e
        }
    }
    function ze(t, e) {
        M.call(this),
        this.type = "OctahedronGeometry",
        this.parameters = {
            radius: t,
            detail: e
        },
        this.fromBufferGeometry(new He(t,e)),
        this.mergeVertices()
    }
    function He(t, e) {
        Ue.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e),
        this.type = "OctahedronBufferGeometry",
        this.parameters = {
            radius: t,
            detail: e
        }
    }
    function Ge(t, e) {
        M.call(this),
        this.type = "IcosahedronGeometry",
        this.parameters = {
            radius: t,
            detail: e
        },
        this.fromBufferGeometry(new ke(t,e)),
        this.mergeVertices()
    }
    function ke(t, e) {
        var n = (1 + Math.sqrt(5)) / 2;
        Ue.call(this, [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e),
        this.type = "IcosahedronBufferGeometry",
        this.parameters = {
            radius: t,
            detail: e
        }
    }
    function Ve(t, e) {
        M.call(this),
        this.type = "DodecahedronGeometry",
        this.parameters = {
            radius: t,
            detail: e
        },
        this.fromBufferGeometry(new je(t,e)),
        this.mergeVertices()
    }
    function je(t, e) {
        var n = (1 + Math.sqrt(5)) / 2
          , i = 1 / n;
        Ue.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e),
        this.type = "DodecahedronBufferGeometry",
        this.parameters = {
            radius: t,
            detail: e
        }
    }
    function We(t, e, n, i, r, o) {
        M.call(this),
        this.type = "TubeGeometry",
        this.parameters = {
            path: t,
            tubularSegments: e,
            radius: n,
            radialSegments: i,
            closed: r
        },
        void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed."),
        t = new Xe(t,e,n,i,r),
        this.tangents = t.tangents,
        this.normals = t.normals,
        this.binormals = t.binormals,
        this.fromBufferGeometry(t),
        this.mergeVertices()
    }
    function Xe(r, o, a, s, t) {
        function e(t) {
            d = r.getPointAt(t / o, d);
            var e = c.normals[t];
            for (t = c.binormals[t],
            h = 0; h <= s; h++) {
                var n = h / s * Math.PI * 2
                  , i = Math.sin(n)
                  , n = -Math.cos(n);
                u.x = n * e.x + i * t.x,
                u.y = n * e.y + i * t.y,
                u.z = n * e.z + i * t.z,
                u.normalize(),
                f.push(u.x, u.y, u.z),
                l.x = d.x + a * u.x,
                l.y = d.y + a * u.y,
                l.z = d.z + a * u.z,
                p.push(l.x, l.y, l.z)
            }
        }
        C.call(this),
        this.type = "TubeBufferGeometry",
        this.parameters = {
            path: r,
            tubularSegments: o,
            radius: a,
            radialSegments: s,
            closed: t
        },
        o = o || 64,
        a = a || 1,
        s = s || 8;
        var c = r.computeFrenetFrames(o, t = t || !1);
        this.tangents = c.tangents,
        this.normals = c.normals,
        this.binormals = c.binormals;
        for (var h, l = new wt, u = new wt, n = new W, d = new wt, p = [], f = [], i = [], m = [], g = 0; g < o; g++)
            e(g);
        for (e(!1 === t ? o : 0),
        g = 0; g <= o; g++)
            for (h = 0; h <= s; h++)
                n.x = g / o,
                n.y = h / s,
                i.push(n.x, n.y);
        !function() {
            for (h = 1; h <= o; h++)
                for (g = 1; g <= s; g++) {
                    var t = (s + 1) * h + (g - 1)
                      , e = (s + 1) * h + g
                      , n = (s + 1) * (h - 1) + g;
                    m.push((s + 1) * (h - 1) + (g - 1), t, n),
                    m.push(t, e, n)
                }
        }(),
        this.setIndex(m),
        this.addAttribute("position", new L(p,3)),
        this.addAttribute("normal", new L(f,3)),
        this.addAttribute("uv", new L(i,2))
    }
    function qe(t, e, n, i, r, o, a) {
        M.call(this),
        this.type = "TorusKnotGeometry",
        this.parameters = {
            radius: t,
            tube: e,
            tubularSegments: n,
            radialSegments: i,
            p: r,
            q: o
        },
        void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."),
        this.fromBufferGeometry(new Ye(t,e,n,i,r,o)),
        this.mergeVertices()
    }
    function Ye(t, e, n, i, r, o) {
        function a(t, e, n, i, r) {
            var o = Math.sin(t);
            e = n / e * t,
            n = Math.cos(e),
            r.x = i * (2 + n) * .5 * Math.cos(t),
            r.y = i * (2 + n) * o * .5,
            r.z = i * Math.sin(e) * .5
        }
        C.call(this),
        this.type = "TorusKnotBufferGeometry",
        this.parameters = {
            radius: t,
            tube: e,
            tubularSegments: n,
            radialSegments: i,
            p: r,
            q: o
        },
        t = t || 1,
        e = e || .4,
        n = Math.floor(n) || 64,
        i = Math.floor(i) || 8,
        r = r || 2,
        o = o || 3;
        for (var s = [], c = [], h = [], l = [], u = new wt, d = new wt, p = new wt, f = new wt, m = new wt, g = new wt, v = new wt, y = 0; y <= n; ++y) {
            var x = y / n * r * Math.PI * 2;
            for (a(x, r, o, t, p),
            a(x + .01, r, o, t, f),
            g.subVectors(f, p),
            v.addVectors(f, p),
            m.crossVectors(g, v),
            v.crossVectors(m, g),
            m.normalize(),
            v.normalize(),
            x = 0; x <= i; ++x) {
                var b = x / i * Math.PI * 2
                  , _ = -e * Math.cos(b)
                  , b = e * Math.sin(b);
                u.x = p.x + (_ * v.x + b * m.x),
                u.y = p.y + (_ * v.y + b * m.y),
                u.z = p.z + (_ * v.z + b * m.z),
                c.push(u.x, u.y, u.z),
                d.subVectors(u, p).normalize(),
                h.push(d.x, d.y, d.z),
                l.push(y / n),
                l.push(x / i)
            }
        }
        for (x = 1; x <= n; x++)
            for (y = 1; y <= i; y++)
                e = (i + 1) * x + y,
                s.push((i + 1) * (x - 1) + (y - 1), t = (i + 1) * x + (y - 1), r = (i + 1) * (x - 1) + y),
                s.push(t, e, r);
        this.setIndex(s),
        this.addAttribute("position", new L(c,3)),
        this.addAttribute("normal", new L(h,3)),
        this.addAttribute("uv", new L(l,2))
    }
    function Ze(t, e, n, i, r) {
        M.call(this),
        this.type = "TorusGeometry",
        this.parameters = {
            radius: t,
            tube: e,
            radialSegments: n,
            tubularSegments: i,
            arc: r
        },
        this.fromBufferGeometry(new Je(t,e,n,i,r)),
        this.mergeVertices()
    }
    function Je(t, e, n, i, r) {
        C.call(this),
        this.type = "TorusBufferGeometry",
        this.parameters = {
            radius: t,
            tube: e,
            radialSegments: n,
            tubularSegments: i,
            arc: r
        },
        t = t || 1,
        e = e || .4,
        n = Math.floor(n) || 8,
        i = Math.floor(i) || 6,
        r = r || 2 * Math.PI;
        for (var o, a = [], s = [], c = [], h = [], l = new wt, u = new wt, d = new wt, p = 0; p <= n; p++)
            for (o = 0; o <= i; o++) {
                var f = o / i * r
                  , m = p / n * Math.PI * 2;
                u.x = (t + e * Math.cos(m)) * Math.cos(f),
                u.y = (t + e * Math.cos(m)) * Math.sin(f),
                u.z = e * Math.sin(m),
                s.push(u.x, u.y, u.z),
                l.x = t * Math.cos(f),
                l.y = t * Math.sin(f),
                d.subVectors(u, l).normalize(),
                c.push(d.x, d.y, d.z),
                h.push(o / i),
                h.push(p / n)
            }
        for (p = 1; p <= n; p++)
            for (o = 1; o <= i; o++)
                a.push((r = (i + 1) * p + o) - 1, t = (e = (i + 1) * (p - 1) + o) - 1, r),
                a.push(t, e, r);
        this.setIndex(a),
        this.addAttribute("position", new L(s,3)),
        this.addAttribute("normal", new L(c,3)),
        this.addAttribute("uv", new L(h,2))
    }
    function Qe(t, e, n, i, r) {
        for (var o, a = 0, s = e, c = n - i; s < n; s += i)
            a += (t[c] - t[s]) * (t[s + 1] + t[c + 1]),
            c = s;
        if (r === 0 < a)
            for (r = e; r < n; r += i)
                o = cn(r, t[r], t[r + 1], o);
        else
            for (r = n - i; e <= r; r -= i)
                o = cn(r, t[r], t[r + 1], o);
        return o && rn(o, o.next) && (hn(o),
        o = o.next),
        o
    }
    function Ke(t, e) {
        if (!t)
            return t;
        e = e || t;
        do {
            var n = !1;
            if (t.steiner || !rn(t, t.next) && 0 !== nn(t.prev, t, t.next))
                t = t.next;
            else {
                if (hn(t),
                (t = e = t.prev) === t.next)
                    break;
                n = !0
            }
        } while (n || t !== e);
        return e
    }
    function $e(t, e) {
        return t.x - e.x
    }
    function tn(t, e, n, i, r) {
        return 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1) | (1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
    }
    function en(t, e, n, i, r, o, a, s) {
        return 0 <= (r - a) * (e - s) - (t - a) * (o - s) && 0 <= (t - a) * (i - s) - (n - a) * (e - s) && 0 <= (n - a) * (o - s) - (r - a) * (i - s)
    }
    function nn(t, e, n) {
        return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
    }
    function rn(t, e) {
        return t.x === e.x && t.y === e.y
    }
    function on(t, e, n, i) {
        return rn(t, e) && rn(n, i) || rn(t, i) && rn(n, e) || 0 < nn(t, e, n) != 0 < nn(t, e, i) && 0 < nn(n, i, t) != 0 < nn(n, i, e)
    }
    function an(t, e) {
        return nn(t.prev, t, t.next) < 0 ? 0 <= nn(t, e, t.next) && 0 <= nn(t, t.prev, e) : nn(t, e, t.prev) < 0 || nn(t, t.next, e) < 0
    }
    function sn(t, e) {
        var n = new ln(t.i,t.x,t.y)
          , i = new ln(e.i,e.x,e.y)
          , r = t.next
          , o = e.prev;
        return (t.next = e).prev = t,
        (n.next = r).prev = n,
        (i.next = n).prev = i,
        (o.next = i).prev = o,
        i
    }
    function cn(t, e, n, i) {
        return t = new ln(t,e,n),
        i ? (t.next = i.next,
        (t.prev = i).next.prev = t,
        i.next = t) : (t.prev = t).next = t,
        t
    }
    function hn(t) {
        t.next.prev = t.prev,
        t.prev.next = t.next,
        t.prevZ && (t.prevZ.nextZ = t.nextZ),
        t.nextZ && (t.nextZ.prevZ = t.prevZ)
    }
    function ln(t, e, n) {
        this.i = t,
        this.x = e,
        this.y = n,
        this.nextZ = this.prevZ = this.z = this.next = this.prev = null,
        this.steiner = !1
    }
    function un(t) {
        var e = t.length;
        2 < e && t[e - 1].equals(t[0]) && t.pop()
    }
    function dn(t, e) {
        for (var n = 0; n < e.length; n++)
            t.push(e[n].x),
            t.push(e[n].y)
    }
    function pn(t, e) {
        M.call(this),
        this.type = "ExtrudeGeometry",
        this.parameters = {
            shapes: t,
            options: e
        },
        this.fromBufferGeometry(new fn(t,e)),
        this.mergeVertices()
    }
    function fn(t, G) {
        function e(t) {
            function e(t, e, n) {
                return e || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                e.clone().multiplyScalar(n).add(t)
            }
            function n(t, e, n) {
                var i = t.x - e.x
                  , r = t.y - e.y
                  , o = n.x - t.x
                  , a = n.y - t.y
                  , s = i * i + r * r;
                if (Math.abs(i * a - r * o) > Number.EPSILON) {
                    var c = Math.sqrt(s)
                      , h = Math.sqrt(o * o + a * a)
                      , s = e.x - r / c;
                    if (e = e.y + i / c,
                    (r = (o = s + i * (a = ((n.x - a / h - s) * a - (n.y + o / h - e) * o) / (i * a - r * o)) - t.x) * o + (i = e + r * a - t.y) * i) <= 2)
                        return new W(o,i);
                    r = Math.sqrt(r / 2)
                } else
                    t = !1,
                    i > Number.EPSILON ? o > Number.EPSILON && (t = !0) : i < -Number.EPSILON ? o < -Number.EPSILON && (t = !0) : Math.sign(r) === Math.sign(a) && (t = !0),
                    r = t ? (o = -r,
                    Math.sqrt(s)) : (o = i,
                    i = r,
                    Math.sqrt(s / 2));
                return new W(o / r,i / r)
            }
            function i(t, e) {
                for (O = t.length; 0 <= --O; ) {
                    var n = O
                      , i = O - 1;
                    i < 0 && (i = t.length - 1);
                    for (var r = m + 2 * b, o = 0; o < r; o++) {
                        var a = P * o
                          , s = e + i + a
                          , c = e + i + (h = P * (o + 1))
                          , h = e + n + h;
                        l(e + n + a),
                        l(s),
                        l(h),
                        l(s),
                        l(c),
                        l(h),
                        a = V.length / 3,
                        u((a = w.generateSideWallUV(k, V, a - 6, a - 3, a - 2, a - 1))[0]),
                        u(a[1]),
                        u(a[3]),
                        u(a[1]),
                        u(a[2]),
                        u(a[3])
                    }
                }
            }
            function r(t, e, n) {
                p.push(t),
                p.push(e),
                p.push(n)
            }
            function o(t, e, n) {
                l(t),
                l(e),
                l(n),
                t = V.length / 3,
                u((t = w.generateTopUV(k, V, t - 3, t - 2, t - 1))[0]),
                u(t[1]),
                u(t[2])
            }
            function l(t) {
                V.push(p[3 * t]),
                V.push(p[3 * t + 1]),
                V.push(p[3 * t + 2])
            }
            function u(t) {
                j.push(t.x),
                j.push(t.y)
            }
            var a, s, c, h, d, p = [], f = void 0 !== G.curveSegments ? G.curveSegments : 12, m = void 0 !== G.steps ? G.steps : 1, g = void 0 !== G.amount ? G.amount : 100, v = void 0 === G.bevelEnabled || G.bevelEnabled, y = void 0 !== G.bevelThickness ? G.bevelThickness : 6, x = void 0 !== G.bevelSize ? G.bevelSize : y - 2, b = void 0 !== G.bevelSegments ? G.bevelSegments : 3, _ = G.extrudePath, w = void 0 !== G.UVGenerator ? G.UVGenerator : Js, E = !1;
            _ && (a = _.getSpacedPoints(m),
            v = !(E = !0),
            s = _.computeFrenetFrames(m, !1),
            c = new wt,
            h = new wt,
            d = new wt),
            v || (x = y = b = 0),
            t = (f = t.extractPoints(f)).shape;
            var M = f.holes;
            if (!Zs.isClockWise(t)) {
                t = t.reverse();
                for (var T = 0, S = M.length; T < S; T++) {
                    var A = M[T];
                    Zs.isClockWise(A) && (M[T] = A.reverse())
                }
            }
            var R = Zs.triangulateShape(t, M)
              , L = t
              , T = 0;
            for (S = M.length; T < S; T++)
                A = M[T],
                t = t.concat(A);
            var C, P = t.length, N = R.length, f = [], O = 0, I = (U = L.length) - 1;
            for (F = O + 1; O < U; O++,
            I++,
            F++)
                f[O] = n(L[O], L[I = I === U ? 0 : I], L[F = F === U ? 0 : F]);
            var _ = []
              , B = f.concat();
            for (T = 0,
            S = M.length; T < S; T++) {
                for (var U, A = M[T], D = [], O = 0, I = (U = A.length) - 1, F = O + 1; O < U; O++,
                I++,
                F++)
                    I === U && (I = 0),
                    F === U && (F = 0),
                    D[O] = n(A[O], A[I], A[F]);
                _.push(D),
                B = B.concat(D)
            }
            for (I = 0; I < b; I++) {
                U = I / b;
                var z = y * Math.cos(U * Math.PI / 2);
                for (F = x * Math.sin(U * Math.PI / 2),
                O = 0,
                U = L.length; O < U; O++) {
                    var H = e(L[O], f[O], F);
                    r(H.x, H.y, -z)
                }
                for (T = 0,
                S = M.length; T < S; T++)
                    for (A = M[T],
                    D = _[T],
                    O = 0,
                    U = A.length; O < U; O++)
                        r((H = e(A[O], D[O], F)).x, H.y, -z)
            }
            for (F = x,
            O = 0; O < P; O++)
                H = v ? e(t[O], B[O], F) : t[O],
                E ? (h.copy(s.normals[0]).multiplyScalar(H.x),
                c.copy(s.binormals[0]).multiplyScalar(H.y),
                d.copy(a[0]).add(h).add(c),
                r(d.x, d.y, d.z)) : r(H.x, H.y, 0);
            for (U = 1; U <= m; U++)
                for (O = 0; O < P; O++)
                    H = v ? e(t[O], B[O], F) : t[O],
                    E ? (h.copy(s.normals[U]).multiplyScalar(H.x),
                    c.copy(s.binormals[U]).multiplyScalar(H.y),
                    d.copy(a[U]).add(h).add(c),
                    r(d.x, d.y, d.z)) : r(H.x, H.y, g / m * U);
            for (I = b - 1; 0 <= I; I--) {
                for (U = I / b,
                z = y * Math.cos(U * Math.PI / 2),
                F = x * Math.sin(U * Math.PI / 2),
                O = 0,
                U = L.length; O < U; O++)
                    r((H = e(L[O], f[O], F)).x, H.y, g + z);
                for (T = 0,
                S = M.length; T < S; T++)
                    for (A = M[T],
                    D = _[T],
                    O = 0,
                    U = A.length; O < U; O++)
                        H = e(A[O], D[O], F),
                        E ? r(H.x, H.y + a[m - 1].y, a[m - 1].x + z) : r(H.x, H.y, g + z)
            }
            !function() {
                var t = V.length / 3;
                if (v) {
                    var e = 0 * P;
                    for (O = 0; O < N; O++)
                        o((C = R[O])[2] + e, C[1] + e, C[0] + e);
                    for (e = P * (m + 2 * b),
                    O = 0; O < N; O++)
                        o((C = R[O])[0] + e, C[1] + e, C[2] + e)
                } else {
                    for (O = 0; O < N; O++)
                        o((C = R[O])[2], C[1], C[0]);
                    for (O = 0; O < N; O++)
                        o((C = R[O])[0] + P * m, C[1] + P * m, C[2] + P * m)
                }
                k.addGroup(t, V.length / 3 - t, 0)
            }(),
            function() {
                var t = V.length / 3
                  , e = 0;
                for (i(L, e),
                e += L.length,
                T = 0,
                S = M.length; T < S; T++)
                    i(A = M[T], e),
                    e += A.length;
                k.addGroup(t, V.length / 3 - t, 1)
            }()
        }
        C.call(this),
        this.type = "ExtrudeBufferGeometry",
        this.parameters = {
            shapes: t,
            options: G
        },
        t = Array.isArray(t) ? t : [t];
        for (var k = this, V = [], j = [], n = 0, i = t.length; n < i; n++)
            e(t[n]);
        this.addAttribute("position", new L(V,3)),
        this.addAttribute("uv", new L(j,2)),
        this.computeVertexNormals()
    }
    function mn(t, e) {
        M.call(this),
        this.type = "TextGeometry",
        this.parameters = {
            text: t,
            parameters: e
        },
        this.fromBufferGeometry(new gn(t,e)),
        this.mergeVertices()
    }
    function gn(t, e) {
        var n = (e = e || {}).font;
        if (!n || !n.isFont)
            return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),
            new M;
        t = n.generateShapes(t, e.size, e.curveSegments),
        e.amount = void 0 !== e.height ? e.height : 50,
        void 0 === e.bevelThickness && (e.bevelThickness = 10),
        void 0 === e.bevelSize && (e.bevelSize = 8),
        void 0 === e.bevelEnabled && (e.bevelEnabled = !1),
        fn.call(this, t, e),
        this.type = "TextBufferGeometry"
    }
    function vn(t, e, n, i, r, o, a) {
        M.call(this),
        this.type = "SphereGeometry",
        this.parameters = {
            radius: t,
            widthSegments: e,
            heightSegments: n,
            phiStart: i,
            phiLength: r,
            thetaStart: o,
            thetaLength: a
        },
        this.fromBufferGeometry(new yn(t,e,n,i,r,o,a)),
        this.mergeVertices()
    }
    function yn(t, e, n, i, r, o, a) {
        C.call(this),
        this.type = "SphereBufferGeometry",
        this.parameters = {
            radius: t,
            widthSegments: e,
            heightSegments: n,
            phiStart: i,
            phiLength: r,
            thetaStart: o,
            thetaLength: a
        },
        t = t || 1,
        e = Math.max(3, Math.floor(e) || 8),
        n = Math.max(2, Math.floor(n) || 6),
        i = void 0 !== i ? i : 0,
        r = void 0 !== r ? r : 2 * Math.PI;
        for (var s = (o = void 0 !== o ? o : 0) + (a = void 0 !== a ? a : Math.PI), c = 0, h = [], l = new wt, u = new wt, d = [], p = [], f = [], m = [], g = 0; g <= n; g++) {
            for (var v = [], y = g / n, x = 0; x <= e; x++) {
                var b = x / e;
                l.x = -t * Math.cos(i + b * r) * Math.sin(o + y * a),
                l.y = t * Math.cos(o + y * a),
                l.z = t * Math.sin(i + b * r) * Math.sin(o + y * a),
                p.push(l.x, l.y, l.z),
                u.set(l.x, l.y, l.z).normalize(),
                f.push(u.x, u.y, u.z),
                m.push(b, 1 - y),
                v.push(c++)
            }
            h.push(v)
        }
        for (g = 0; g < n; g++)
            for (x = 0; x < e; x++)
                t = h[g][x + 1],
                i = h[g][x],
                r = h[g + 1][x],
                a = h[g + 1][x + 1],
                (0 !== g || 0 < o) && d.push(t, i, a),
                (g !== n - 1 || s < Math.PI) && d.push(i, r, a);
        this.setIndex(d),
        this.addAttribute("position", new L(p,3)),
        this.addAttribute("normal", new L(f,3)),
        this.addAttribute("uv", new L(m,2))
    }
    function xn(t, e, n, i, r, o) {
        M.call(this),
        this.type = "RingGeometry",
        this.parameters = {
            innerRadius: t,
            outerRadius: e,
            thetaSegments: n,
            phiSegments: i,
            thetaStart: r,
            thetaLength: o
        },
        this.fromBufferGeometry(new bn(t,e,n,i,r,o)),
        this.mergeVertices()
    }
    function bn(t, e, n, i, r, o) {
        C.call(this),
        this.type = "RingBufferGeometry",
        this.parameters = {
            innerRadius: t,
            outerRadius: e,
            thetaSegments: n,
            phiSegments: i,
            thetaStart: r,
            thetaLength: o
        },
        t = t || .5,
        e = e || 1,
        r = void 0 !== r ? r : 0,
        o = void 0 !== o ? o : 2 * Math.PI,
        n = void 0 !== n ? Math.max(3, n) : 8;
        for (var a, s = [], c = [], h = [], l = [], u = t, d = (e - t) / (i = void 0 !== i ? Math.max(1, i) : 1), p = new wt, f = new W, m = 0; m <= i; m++) {
            for (a = 0; a <= n; a++)
                t = r + a / n * o,
                p.x = u * Math.cos(t),
                p.y = u * Math.sin(t),
                c.push(p.x, p.y, p.z),
                h.push(0, 0, 1),
                f.x = (p.x / e + 1) / 2,
                f.y = (p.y / e + 1) / 2,
                l.push(f.x, f.y);
            u += d
        }
        for (m = 0; m < i; m++)
            for (e = m * (n + 1),
            a = 0; a < n; a++)
                o = (t = a + e) + n + 2,
                s.push(t, r = t + n + 1, u = t + 1),
                s.push(r, o, u);
        this.setIndex(s),
        this.addAttribute("position", new L(c,3)),
        this.addAttribute("normal", new L(h,3)),
        this.addAttribute("uv", new L(l,2))
    }
    function _n(t, e, n, i) {
        M.call(this),
        this.type = "LatheGeometry",
        this.parameters = {
            points: t,
            segments: e,
            phiStart: n,
            phiLength: i
        },
        this.fromBufferGeometry(new wn(t,e,n,i)),
        this.mergeVertices()
    }
    function wn(t, e, n, i) {
        C.call(this),
        this.type = "LatheBufferGeometry",
        this.parameters = {
            points: t,
            segments: e,
            phiStart: n,
            phiLength: i
        },
        e = Math.floor(e) || 12,
        n = n || 0,
        i = i || 2 * Math.PI,
        i = io.clamp(i, 0, 2 * Math.PI);
        for (var r = [], o = [], a = [], s = 1 / e, c = new wt, h = new W, l = 0; l <= e; l++)
            for (var u = n + l * s * i, d = Math.sin(u), p = Math.cos(u), u = 0; u <= t.length - 1; u++)
                c.x = t[u].x * d,
                c.y = t[u].y,
                c.z = t[u].x * p,
                o.push(c.x, c.y, c.z),
                h.x = l / e,
                h.y = u / (t.length - 1),
                a.push(h.x, h.y);
        for (l = 0; l < e; l++)
            for (u = 0; u < t.length - 1; u++)
                s = (n = u + l * t.length) + t.length,
                c = n + t.length + 1,
                r.push(n, s, h = n + 1),
                r.push(s, c, h);
        if (this.setIndex(r),
        this.addAttribute("position", new L(o,3)),
        this.addAttribute("uv", new L(a,2)),
        this.computeVertexNormals(),
        i === 2 * Math.PI)
            for (i = this.attributes.normal.array,
            r = new wt,
            o = new wt,
            a = new wt,
            n = e * t.length * 3,
            u = l = 0; l < t.length; l++,
            u += 3)
                r.x = i[u + 0],
                r.y = i[u + 1],
                r.z = i[u + 2],
                o.x = i[n + u + 0],
                o.y = i[n + u + 1],
                o.z = i[n + u + 2],
                a.addVectors(r, o).normalize(),
                i[u + 0] = i[n + u + 0] = a.x,
                i[u + 1] = i[n + u + 1] = a.y,
                i[u + 2] = i[n + u + 2] = a.z
    }
    function En(t, e) {
        M.call(this),
        this.type = "ShapeGeometry",
        "object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."),
        e = e.curveSegments),
        this.parameters = {
            shapes: t,
            curveSegments: e
        },
        this.fromBufferGeometry(new Mn(t,e)),
        this.mergeVertices()
    }
    function Mn(t, s) {
        function e(t) {
            var e, n = h.length / 3, i = (t = t.extractPoints(s)).shape, r = t.holes;
            if (!1 === Zs.isClockWise(i))
                for (i = i.reverse(),
                t = 0,
                e = r.length; t < e; t++) {
                    var o = r[t];
                    !0 === Zs.isClockWise(o) && (r[t] = o.reverse())
                }
            var a = Zs.triangulateShape(i, r);
            for (t = 0,
            e = r.length; t < e; t++)
                o = r[t],
                i = i.concat(o);
            for (t = 0,
            e = i.length; t < e; t++)
                o = i[t],
                h.push(o.x, o.y, 0),
                l.push(0, 0, 1),
                u.push(o.x, o.y);
            for (t = 0,
            e = a.length; t < e; t++)
                i = a[t],
                c.push(i[0] + n, i[1] + n, i[2] + n),
                d += 3
        }
        C.call(this),
        this.type = "ShapeBufferGeometry",
        this.parameters = {
            shapes: t,
            curveSegments: s
        },
        s = s || 12;
        var c = []
          , h = []
          , l = []
          , u = []
          , n = 0
          , d = 0;
        if (!1 === Array.isArray(t))
            e(t);
        else
            for (var i = 0; i < t.length; i++)
                e(t[i]),
                this.addGroup(n, d, i),
                n += d,
                d = 0;
        this.setIndex(c),
        this.addAttribute("position", new L(h,3)),
        this.addAttribute("normal", new L(l,3)),
        this.addAttribute("uv", new L(u,2))
    }
    function Tn(t, e) {
        if (e.shapes = [],
        Array.isArray(t))
            for (var n = 0, i = t.length; n < i; n++)
                e.shapes.push(t[n].uuid);
        else
            e.shapes.push(t.uuid);
        return e
    }
    function Sn(t, e) {
        C.call(this),
        this.type = "EdgesGeometry",
        this.parameters = {
            thresholdAngle: e
        };
        var n = [];
        e = Math.cos(io.DEG2RAD * (void 0 !== e ? e : 1));
        var i = [0, 0]
          , r = {}
          , o = ["a", "b", "c"];
        t.isBufferGeometry ? (a = new M).fromBufferGeometry(t) : a = t.clone(),
        a.mergeVertices(),
        a.computeFaceNormals(),
        t = a.vertices;
        for (var a, s = 0, c = (a = a.faces).length; s < c; s++)
            for (var h = a[s], l = 0; l < 3; l++) {
                var u = h[o[l]]
                  , d = h[o[(l + 1) % 3]];
                i[0] = Math.min(u, d),
                i[1] = Math.max(u, d),
                void 0 === r[u = i[0] + "," + i[1]] ? r[u] = {
                    index1: i[0],
                    index2: i[1],
                    face1: s,
                    face2: void 0
                } : r[u].face2 = s
            }
        for (u in r)
            (void 0 === (i = r[u]).face2 || a[i.face1].normal.dot(a[i.face2].normal) <= e) && (o = t[i.index1],
            n.push(o.x, o.y, o.z),
            o = t[i.index2],
            n.push(o.x, o.y, o.z));
        this.addAttribute("position", new L(n,3))
    }
    function An(t, e, n, i, r, o, a, s) {
        M.call(this),
        this.type = "CylinderGeometry",
        this.parameters = {
            radiusTop: t,
            radiusBottom: e,
            height: n,
            radialSegments: i,
            heightSegments: r,
            openEnded: o,
            thetaStart: a,
            thetaLength: s
        },
        this.fromBufferGeometry(new Rn(t,e,n,i,r,o,a,s)),
        this.mergeVertices()
    }
    function Rn(d, p, f, m, g, t, v, y) {
        function e(t) {
            for (var e = new W, n = new wt, i = 0, r = !0 === t ? d : p, o = !0 === t ? 1 : -1, a = M, s = 1; s <= m; s++)
                _.push(0, S * o, 0),
                w.push(0, o, 0),
                E.push(.5, .5),
                M++;
            var c = M;
            for (s = 0; s <= m; s++) {
                var h = s / m * y + v
                  , l = Math.cos(h)
                  , h = Math.sin(h);
                n.x = r * h,
                n.y = S * o,
                n.z = r * l,
                _.push(n.x, n.y, n.z),
                w.push(0, o, 0),
                e.x = .5 * l + .5,
                e.y = .5 * h * o + .5,
                E.push(e.x, e.y),
                M++
            }
            for (s = 0; s < m; s++)
                e = a + s,
                n = c + s,
                !0 === t ? b.push(n, n + 1, e) : b.push(n + 1, n, e),
                i += 3;
            x.addGroup(A, i, !0 === t ? 1 : 2),
            A += i
        }
        C.call(this),
        this.type = "CylinderBufferGeometry",
        this.parameters = {
            radiusTop: d,
            radiusBottom: p,
            height: f,
            radialSegments: m,
            heightSegments: g,
            openEnded: t,
            thetaStart: v,
            thetaLength: y
        };
        var x = this;
        d = void 0 !== d ? d : 1,
        p = void 0 !== p ? p : 1,
        f = f || 1,
        m = Math.floor(m) || 8,
        g = Math.floor(g) || 1,
        t = void 0 !== t && t,
        v = void 0 !== v ? v : 0,
        y = void 0 !== y ? y : 2 * Math.PI;
        var b = []
          , _ = []
          , w = []
          , E = []
          , M = 0
          , T = []
          , S = f / 2
          , A = 0;
        !function() {
            for (var t = new wt, e = new wt, n = 0, i = (p - d) / f, r = 0; r <= g; r++) {
                for (var o = [], a = r / g, s = a * (p - d) + d, c = 0; c <= m; c++) {
                    var h = c / m
                      , l = h * y + v
                      , u = Math.sin(l)
                      , l = Math.cos(l);
                    e.x = s * u,
                    e.y = -a * f + S,
                    e.z = s * l,
                    _.push(e.x, e.y, e.z),
                    t.set(u, i, l).normalize(),
                    w.push(t.x, t.y, t.z),
                    E.push(h, 1 - a),
                    o.push(M++)
                }
                T.push(o)
            }
            for (c = 0; c < m; c++)
                for (r = 0; r < g; r++)
                    t = T[r + 1][c],
                    e = T[r + 1][c + 1],
                    i = T[r][c + 1],
                    b.push(T[r][c], t, i),
                    b.push(t, e, i),
                    n += 6;
            x.addGroup(A, n, 0),
            A += n
        }(),
        !1 === t && (0 < d && e(!0),
        0 < p && e(!1)),
        this.setIndex(b),
        this.addAttribute("position", new L(_,3)),
        this.addAttribute("normal", new L(w,3)),
        this.addAttribute("uv", new L(E,2))
    }
    function Ln(t, e, n, i, r, o, a) {
        An.call(this, 0, t, e, n, i, r, o, a),
        this.type = "ConeGeometry",
        this.parameters = {
            radius: t,
            height: e,
            radialSegments: n,
            heightSegments: i,
            openEnded: r,
            thetaStart: o,
            thetaLength: a
        }
    }
    function Cn(t, e, n, i, r, o, a) {
        Rn.call(this, 0, t, e, n, i, r, o, a),
        this.type = "ConeBufferGeometry",
        this.parameters = {
            radius: t,
            height: e,
            radialSegments: n,
            heightSegments: i,
            openEnded: r,
            thetaStart: o,
            thetaLength: a
        }
    }
    function Pn(t, e, n, i) {
        M.call(this),
        this.type = "CircleGeometry",
        this.parameters = {
            radius: t,
            segments: e,
            thetaStart: n,
            thetaLength: i
        },
        this.fromBufferGeometry(new Nn(t,e,n,i)),
        this.mergeVertices()
    }
    function Nn(t, e, n, i) {
        C.call(this),
        this.type = "CircleBufferGeometry",
        this.parameters = {
            radius: t,
            segments: e,
            thetaStart: n,
            thetaLength: i
        },
        t = t || 1,
        e = void 0 !== e ? Math.max(3, e) : 8,
        n = void 0 !== n ? n : 0,
        i = void 0 !== i ? i : 2 * Math.PI;
        var r = []
          , o = []
          , a = []
          , s = []
          , c = new wt
          , h = new W;
        o.push(0, 0, 0),
        a.push(0, 0, 1),
        s.push(.5, .5);
        for (var l = 0, u = 3; l <= e; l++,
        u += 3) {
            var d = n + l / e * i;
            c.x = t * Math.cos(d),
            c.y = t * Math.sin(d),
            o.push(c.x, c.y, c.z),
            a.push(0, 0, 1),
            h.x = (o[u] / t + 1) / 2,
            h.y = (o[u + 1] / t + 1) / 2,
            s.push(h.x, h.y)
        }
        for (u = 1; u <= e; u++)
            r.push(u, u + 1, 0);
        this.setIndex(r),
        this.addAttribute("position", new L(o,3)),
        this.addAttribute("normal", new L(a,3)),
        this.addAttribute("uv", new L(s,2))
    }
    function On(t) {
        I.call(this),
        this.type = "ShadowMaterial",
        this.color = new w(0),
        this.transparent = !0,
        this.setValues(t)
    }
    function In(t) {
        U.call(this, t),
        this.type = "RawShaderMaterial"
    }
    function Bn(t) {
        I.call(this),
        this.defines = {
            STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new w(16777215),
        this.metalness = this.roughness = .5,
        this.lightMap = this.map = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new w(0),
        this.emissiveIntensity = 1,
        this.bumpMap = this.emissiveMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalScale = new W(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null,
        this.envMapIntensity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinejoin = this.wireframeLinecap = "round",
        this.morphNormals = this.morphTargets = this.skinning = !1,
        this.setValues(t)
    }
    function Un(t) {
        Bn.call(this),
        this.defines = {
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.reflectivity = .5,
        this.clearCoatRoughness = this.clearCoat = 0,
        this.setValues(t)
    }
    function Dn(t) {
        I.call(this),
        this.type = "MeshPhongMaterial",
        this.color = new w(16777215),
        this.specular = new w(1118481),
        this.shininess = 30,
        this.lightMap = this.map = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new w(0),
        this.emissiveIntensity = 1,
        this.bumpMap = this.emissiveMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalScale = new W(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.envMap = this.alphaMap = this.specularMap = null,
        this.combine = 0,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinejoin = this.wireframeLinecap = "round",
        this.morphNormals = this.morphTargets = this.skinning = !1,
        this.setValues(t)
    }
    function Fn(t) {
        Dn.call(this),
        this.defines = {
            TOON: ""
        },
        this.type = "MeshToonMaterial",
        this.gradientMap = null,
        this.setValues(t)
    }
    function zn(t) {
        I.call(this),
        this.type = "MeshNormalMaterial",
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalScale = new W(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.morphNormals = this.morphTargets = this.skinning = this.lights = this.fog = !1,
        this.setValues(t)
    }
    function Hn(t) {
        I.call(this),
        this.type = "MeshLambertMaterial",
        this.color = new w(16777215),
        this.lightMap = this.map = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new w(0),
        this.emissiveIntensity = 1,
        this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null,
        this.combine = 0,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinejoin = this.wireframeLinecap = "round",
        this.morphNormals = this.morphTargets = this.skinning = !1,
        this.setValues(t)
    }
    function Gn(t) {
        we.call(this),
        this.type = "LineDashedMaterial",
        this.scale = 1,
        this.dashSize = 3,
        this.gapSize = 1,
        this.setValues(t)
    }
    function kn(t, e, n) {
        var i = this
          , r = !1
          , o = 0
          , a = 0
          , s = void 0;
        this.onStart = void 0,
        this.onLoad = t,
        this.onProgress = e,
        this.onError = n,
        this.itemStart = function(t) {
            a++,
            !1 === r && void 0 !== i.onStart && i.onStart(t, o, a),
            r = !0
        }
        ,
        this.itemEnd = function(t) {
            o++,
            void 0 !== i.onProgress && i.onProgress(t, o, a),
            o === a && (r = !1,
            void 0 !== i.onLoad) && i.onLoad()
        }
        ,
        this.itemError = function(t) {
            void 0 !== i.onError && i.onError(t)
        }
        ,
        this.resolveURL = function(t) {
            return s ? s(t) : t
        }
        ,
        this.setURLModifier = function(t) {
            return s = t,
            this
        }
    }
    function Vn(t) {
        this.manager = void 0 !== t ? t : tc
    }
    function jn(t) {
        this.manager = void 0 !== t ? t : tc,
        this._parser = null
    }
    function Wn(t) {
        this.manager = void 0 !== t ? t : tc,
        this._parser = null
    }
    function Xn(t) {
        this.manager = void 0 !== t ? t : tc
    }
    function qn(t) {
        this.manager = void 0 !== t ? t : tc
    }
    function Yn(t) {
        this.manager = void 0 !== t ? t : tc
    }
    function Zn() {
        this.type = "Curve",
        this.arcLengthDivisions = 200
    }
    function Jn(t, e, n, i, r, o, a, s) {
        Zn.call(this),
        this.type = "EllipseCurve",
        this.aX = t || 0,
        this.aY = e || 0,
        this.xRadius = n || 1,
        this.yRadius = i || 1,
        this.aStartAngle = r || 0,
        this.aEndAngle = o || 2 * Math.PI,
        this.aClockwise = a || !1,
        this.aRotation = s || 0
    }
    function Qn(t, e, n, i, r, o) {
        Jn.call(this, t, e, n, n, i, r, o),
        this.type = "ArcCurve"
    }
    function Kn() {
        var s = 0
          , c = 0
          , h = 0
          , l = 0;
        return {
            initCatmullRom: function(t, e, n, i, r) {
                h = -3 * (s = e) + 3 * n - 2 * (c = t = r * (n - t)) - (i = r * (i - e)),
                l = 2 * e - 2 * n + t + i
            },
            initNonuniformCatmullRom: function(t, e, n, i, r, o, a) {
                h = -3 * (s = e) + 3 * n - 2 * (c = t = ((e - t) / r - (n - t) / (r + o) + (n - e) / o) * o) - (i = ((n - e) / o - (i - e) / (o + a) + (i - n) / a) * o),
                l = 2 * e - 2 * n + t + i
            },
            calc: function(t) {
                var e = t * t;
                return s + c * t + h * e + l * e * t
            }
        }
    }
    function $n(t, e, n, i) {
        Zn.call(this),
        this.type = "CatmullRomCurve3",
        this.points = t || [],
        this.closed = e || !1,
        this.curveType = n || "centripetal",
        this.tension = i || .5
    }
    function ti(t, e, n, i, r) {
        var o = t * t;
        return (2 * n - 2 * i + (e = .5 * (i - e)) + (r = .5 * (r - n))) * t * o + (-3 * n + 3 * i - 2 * e - r) * o + e * t + n
    }
    function ei(t, e, n, i) {
        var r = 1 - t;
        return r * r * e + 2 * (1 - t) * t * n + t * t * i
    }
    function ni(t, e, n, i, r) {
        var o = 1 - t
          , a = 1 - t;
        return o * o * o * e + 3 * a * a * t * n + 3 * (1 - t) * t * t * i + t * t * t * r
    }
    function ii(t, e, n, i) {
        Zn.call(this),
        this.type = "CubicBezierCurve",
        this.v0 = t || new W,
        this.v1 = e || new W,
        this.v2 = n || new W,
        this.v3 = i || new W
    }
    function ri(t, e, n, i) {
        Zn.call(this),
        this.type = "CubicBezierCurve3",
        this.v0 = t || new wt,
        this.v1 = e || new wt,
        this.v2 = n || new wt,
        this.v3 = i || new wt
    }
    function oi(t, e) {
        Zn.call(this),
        this.type = "LineCurve",
        this.v1 = t || new W,
        this.v2 = e || new W
    }
    function ai(t, e) {
        Zn.call(this),
        this.type = "LineCurve3",
        this.v1 = t || new wt,
        this.v2 = e || new wt
    }
    function si(t, e, n) {
        Zn.call(this),
        this.type = "QuadraticBezierCurve",
        this.v0 = t || new W,
        this.v1 = e || new W,
        this.v2 = n || new W
    }
    function ci(t, e, n) {
        Zn.call(this),
        this.type = "QuadraticBezierCurve3",
        this.v0 = t || new wt,
        this.v1 = e || new wt,
        this.v2 = n || new wt
    }
    function hi(t) {
        Zn.call(this),
        this.type = "SplineCurve",
        this.points = t || []
    }
    function li() {
        Zn.call(this),
        this.type = "CurvePath",
        this.curves = [],
        this.autoClose = !1
    }
    function ui(t) {
        li.call(this),
        this.type = "Path",
        this.currentPoint = new W,
        t && this.setFromPoints(t)
    }
    function di(t) {
        ui.call(this, t),
        this.uuid = io.generateUUID(),
        this.type = "Shape",
        this.holes = []
    }
    function pi(t, e) {
        l.call(this),
        this.type = "Light",
        this.color = new w(t),
        this.intensity = void 0 !== e ? e : 1,
        this.receiveShadow = void 0
    }
    function fi(t, e, n) {
        pi.call(this, t, n),
        this.type = "HemisphereLight",
        this.castShadow = void 0,
        this.position.copy(l.DefaultUp),
        this.updateMatrix(),
        this.groundColor = new w(e)
    }
    function mi(t) {
        this.camera = t,
        this.bias = 0,
        this.radius = 1,
        this.mapSize = new W(512,512),
        this.map = null,
        this.matrix = new _t
    }
    function gi() {
        mi.call(this, new he(50,1,.5,500))
    }
    function vi(t, e, n, i, r, o) {
        pi.call(this, t, e),
        this.type = "SpotLight",
        this.position.copy(l.DefaultUp),
        this.updateMatrix(),
        this.target = new l,
        Object.defineProperty(this, "power", {
            get: function() {
                return this.intensity * Math.PI
            },
            set: function(t) {
                this.intensity = t / Math.PI
            }
        }),
        this.distance = void 0 !== n ? n : 0,
        this.angle = void 0 !== i ? i : Math.PI / 3,
        this.penumbra = void 0 !== r ? r : 0,
        this.decay = void 0 !== o ? o : 1,
        this.shadow = new gi
    }
    function yi(t, e, n, i) {
        pi.call(this, t, e),
        this.type = "PointLight",
        Object.defineProperty(this, "power", {
            get: function() {
                return 4 * this.intensity * Math.PI
            },
            set: function(t) {
                this.intensity = t / (4 * Math.PI)
            }
        }),
        this.distance = void 0 !== n ? n : 0,
        this.decay = void 0 !== i ? i : 1,
        this.shadow = new mi(new he(90,1,.5,500))
    }
    function xi() {
        mi.call(this, new p(-5,5,5,-5,.5,500))
    }
    function bi(t, e) {
        pi.call(this, t, e),
        this.type = "DirectionalLight",
        this.position.copy(l.DefaultUp),
        this.updateMatrix(),
        this.target = new l,
        this.shadow = new xi
    }
    function _i(t, e) {
        pi.call(this, t, e),
        this.type = "AmbientLight",
        this.castShadow = void 0
    }
    function wi(t, e, n, i) {
        pi.call(this, t, e),
        this.type = "RectAreaLight",
        this.width = void 0 !== n ? n : 10,
        this.height = void 0 !== i ? i : 10
    }
    function Ei(t, e, n, i) {
        Oi.call(this, t, e, n, i)
    }
    function Mi(t, e, n) {
        Oi.call(this, t, e, n)
    }
    function Ti(t, e, n, i) {
        this.parameterPositions = t,
        this._cachedIndex = 0,
        this.resultBuffer = void 0 !== i ? i : new e.constructor(n),
        this.sampleValues = e,
        this.valueSize = n
    }
    function Si(t, e, n, i) {
        Ti.call(this, t, e, n, i)
    }
    function Ai(t, e, n, i) {
        Oi.call(this, t, e, n, i)
    }
    function Ri(t, e, n, i) {
        Oi.call(this, t, e, n, i)
    }
    function Li(t, e, n, i) {
        Oi.call(this, t, e, n, i)
    }
    function Ci(t, e, n, i) {
        Ti.call(this, t, e, n, i),
        this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0
    }
    function Pi(t, e, n, i) {
        Ti.call(this, t, e, n, i)
    }
    function Ni(t, e, n, i) {
        Ti.call(this, t, e, n, i)
    }
    function Oi(t, e, n, i) {
        if (void 0 === t)
            throw Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === e || 0 === e.length)
            throw Error("THREE.KeyframeTrack: no keyframes in track named " + t);
        this.name = t,
        this.times = sc.convertArray(e, this.TimeBufferType),
        this.values = sc.convertArray(n, this.ValueBufferType),
        this.setInterpolation(i || this.DefaultInterpolation),
        this.validate(),
        this.optimize()
    }
    function Ii(t, e, n, i) {
        Oi.call(this, t, e, n, i)
    }
    function Bi(t, e, n) {
        this.name = t,
        this.tracks = n,
        this.duration = void 0 !== e ? e : -1,
        this.uuid = io.generateUUID(),
        this.duration < 0 && this.resetDuration(),
        this.optimize()
    }
    function Ui(t) {
        this.manager = void 0 !== t ? t : tc,
        this.textures = {}
    }
    function Di(t) {
        this.manager = void 0 !== t ? t : tc
    }
    function Fi() {}
    function zi(t) {
        "boolean" == typeof t && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."),
        t = void 0),
        this.manager = void 0 !== t ? t : tc,
        this.withCredentials = !1
    }
    function Hi(t) {
        this.manager = void 0 !== t ? t : tc,
        this.texturePath = ""
    }
    function Gi(t) {
        "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
        "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        this.manager = void 0 !== t ? t : tc,
        this.options = void 0
    }
    function ki() {
        this.type = "ShapePath",
        this.color = new w,
        this.subPaths = [],
        this.currentPath = null
    }
    function Vi(t) {
        this.type = "Font",
        this.data = t
    }
    function ji(t) {
        this.manager = void 0 !== t ? t : tc
    }
    function Wi(t) {
        this.manager = void 0 !== t ? t : tc
    }
    function Xi() {
        this.type = "StereoCamera",
        this.aspect = 1,
        this.eyeSep = .064,
        this.cameraL = new he,
        this.cameraL.layers.enable(1),
        this.cameraL.matrixAutoUpdate = !1,
        this.cameraR = new he,
        this.cameraR.layers.enable(2),
        this.cameraR.matrixAutoUpdate = !1
    }
    function qi(t, e, n) {
        l.call(this),
        this.type = "CubeCamera";
        var r = new he(90,1,t,e);
        r.up.set(0, -1, 0),
        r.lookAt(new wt(1,0,0)),
        this.add(r);
        var o = new he(90,1,t,e);
        o.up.set(0, -1, 0),
        o.lookAt(new wt(-1,0,0)),
        this.add(o);
        var a = new he(90,1,t,e);
        a.up.set(0, 0, 1),
        a.lookAt(new wt(0,1,0)),
        this.add(a);
        var s = new he(90,1,t,e);
        s.up.set(0, 0, -1),
        s.lookAt(new wt(0,-1,0)),
        this.add(s);
        var c = new he(90,1,t,e);
        c.up.set(0, -1, 0),
        c.lookAt(new wt(0,0,1)),
        this.add(c);
        var h = new he(90,1,t,e);
        h.up.set(0, -1, 0),
        h.lookAt(new wt(0,0,-1)),
        this.add(h),
        this.renderTarget = new i(n,n,{
            format: 1022,
            magFilter: 1006,
            minFilter: 1006
        }),
        this.renderTarget.texture.name = "CubeCamera",
        this.update = function(t, e) {
            null === this.parent && this.updateMatrixWorld();
            var n = this.renderTarget
              , i = n.texture.generateMipmaps;
            n.texture.generateMipmaps = !1,
            n.activeCubeFace = 0,
            t.render(e, r, n),
            n.activeCubeFace = 1,
            t.render(e, o, n),
            n.activeCubeFace = 2,
            t.render(e, a, n),
            n.activeCubeFace = 3,
            t.render(e, s, n),
            n.activeCubeFace = 4,
            t.render(e, c, n),
            n.texture.generateMipmaps = i,
            n.activeCubeFace = 5,
            t.render(e, h, n),
            t.setRenderTarget(null)
        }
        ,
        this.clear = function(t, e, n, i) {
            for (var r = this.renderTarget, o = 0; o < 6; o++)
                r.activeCubeFace = o,
                t.setRenderTarget(r),
                t.clear(e, n, i);
            t.setRenderTarget(null)
        }
    }
    function Yi() {
        l.call(this),
        this.type = "AudioListener",
        this.context = mh.getContext(),
        this.gain = this.context.createGain(),
        this.gain.connect(this.context.destination),
        this.filter = null
    }
    function Zi(t) {
        l.call(this),
        this.type = "Audio",
        this.context = t.context,
        this.gain = this.context.createGain(),
        this.gain.connect(t.getInput()),
        this.autoplay = !1,
        this.buffer = null,
        this.loop = !1,
        this.offset = this.startTime = 0,
        this.playbackRate = 1,
        this.isPlaying = !1,
        this.hasPlaybackControl = !0,
        this.sourceType = "empty",
        this.filters = []
    }
    function Ji(t) {
        Zi.call(this, t),
        this.panner = this.context.createPanner(),
        this.panner.connect(this.gain)
    }
    function Qi(t, e) {
        this.analyser = t.context.createAnalyser(),
        this.analyser.fftSize = void 0 !== e ? e : 2048,
        this.data = new Uint8Array(this.analyser.frequencyBinCount),
        t.getOutput().connect(this.analyser)
    }
    function Ki(t, e, n) {
        switch (this.binding = t,
        this.valueSize = n,
        t = Float64Array,
        e) {
        case "quaternion":
            e = this._slerp;
            break;
        case "string":
        case "bool":
            t = Array,
            e = this._select;
            break;
        default:
            e = this._lerp
        }
        this.buffer = new t(4 * n),
        this._mixBufferRegion = e,
        this.referenceCount = this.useCount = this.cumulativeWeight = 0
    }
    function $i(t, e, n) {
        n = n || tr.parseTrackName(e),
        this._targetGroup = t,
        this._bindings = t.subscribe_(e, n)
    }
    function tr(t, e, n) {
        this.path = e,
        this.parsedPath = n || tr.parseTrackName(e),
        this.node = tr.findNode(t, this.parsedPath.nodeName) || t,
        this.rootNode = t
    }
    function er() {
        this.uuid = io.generateUUID(),
        this._objects = Array.prototype.slice.call(arguments),
        this.nCachedObjects_ = 0;
        var t = {};
        this._indicesByUUID = t;
        for (var e = 0, n = arguments.length; e !== n; ++e)
            t[arguments[e].uuid] = e;
        this._paths = [],
        this._parsedPaths = [],
        this._bindings = [],
        this._bindingsIndicesByPath = {};
        var i = this;
        this.stats = {
            objects: {
                get total() {
                    return i._objects.length
                },
                get inUse() {
                    return this.total - i.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return i._bindings.length
            }
        }
    }
    function nr(t, e, n) {
        this._mixer = t,
        this._clip = e,
        this._localRoot = n || null,
        e = (t = e.tracks).length,
        n = Array(e);
        for (var i = {
            endingStart: 2400,
            endingEnd: 2400
        }, r = 0; r !== e; ++r) {
            var o = t[r].createInterpolant(null);
            (n[r] = o).settings = i
        }
        this._interpolantSettings = i,
        this._interpolants = n,
        this._propertyBindings = Array(e),
        this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null,
        this.loop = 2201,
        this._loopCount = -1,
        this._startTime = null,
        this.time = 0,
        this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1,
        this.repetitions = 1 / 0,
        this.paused = !1,
        this.enabled = !0,
        this.clampWhenFinished = !1,
        this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0
    }
    function ir(t) {
        this._root = t,
        this._initMemoryManager(),
        this.time = this._accuIndex = 0,
        this.timeScale = 1
    }
    function rr(t, e) {
        "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."),
        t = e),
        this.value = t
    }
    function or() {
        C.call(this),
        this.type = "InstancedBufferGeometry",
        this.maxInstancedCount = void 0
    }
    function ar(t, e, n, i) {
        this.data = t,
        this.itemSize = e,
        this.offset = n,
        this.normalized = !0 === i
    }
    function sr(t, e) {
        this.array = t,
        this.stride = e,
        this.count = void 0 !== t ? t.length / e : 0,
        this.dynamic = !1,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0
    }
    function cr(t, e, n) {
        sr.call(this, t, e),
        this.meshPerAttribute = n || 1
    }
    function hr(t, e, n) {
        y.call(this, t, e),
        this.meshPerAttribute = n || 1
    }
    function lr(t, e, n, i) {
        this.ray = new D(t,e),
        this.near = n || 0,
        this.far = i || 1 / 0,
        this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        },
        Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),
                    this.Points
                }
            }
        })
    }
    function ur(t, e) {
        return t.distance - e.distance
    }
    function dr(t, e, n, i) {
        if (!1 !== t.visible && (t.raycast(e, n),
        !0 === i)) {
            i = 0;
            for (var r = (t = t.children).length; i < r; i++)
                dr(t[i], e, n, !0)
        }
    }
    function pr(t) {
        this.autoStart = void 0 === t || t,
        this.elapsedTime = this.oldTime = this.startTime = 0,
        this.running = !1
    }
    function fr(t, e, n) {
        return this.radius = void 0 !== t ? t : 1,
        this.phi = void 0 !== e ? e : 0,
        this.theta = void 0 !== n ? n : 0,
        this
    }
    function mr(t, e, n) {
        return this.radius = void 0 !== t ? t : 1,
        this.theta = void 0 !== e ? e : 0,
        this.y = void 0 !== n ? n : 0,
        this
    }
    function gr(t, e) {
        this.min = void 0 !== t ? t : new W(1 / 0,1 / 0),
        this.max = void 0 !== e ? e : new W(-1 / 0,-1 / 0)
    }
    function vr(t) {
        l.call(this),
        this.material = t,
        this.render = function() {}
    }
    function yr(t, e, n, i) {
        this.object = t,
        this.size = void 0 !== e ? e : 1,
        t = void 0 !== n ? n : 16711680,
        i = void 0 !== i ? i : 1,
        e = 0,
        (n = this.object.geometry) && n.isGeometry ? e = 3 * n.faces.length : n && n.isBufferGeometry && (e = n.attributes.normal.count),
        n = new C,
        e = new L(6 * e,3),
        n.addAttribute("position", e),
        Me.call(this, n, new we({
            color: t,
            linewidth: i
        })),
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function xr(t, e) {
        l.call(this),
        this.light = t,
        this.light.updateMatrixWorld(),
        this.matrix = t.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = e,
        t = new C,
        e = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
        for (var n = 0, i = 1; n < 32; n++,
        i++) {
            var r = n / 32 * Math.PI * 2
              , o = i / 32 * Math.PI * 2;
            e.push(Math.cos(r), Math.sin(r), 1, Math.cos(o), Math.sin(o), 1)
        }
        t.addAttribute("position", new L(e,3)),
        e = new we({
            fog: !1
        }),
        this.cone = new Me(t,e),
        this.add(this.cone),
        this.update()
    }
    function br(t) {
        for (var e = function t(e) {
            var n = [];
            e && e.isBone && n.push(e);
            for (var i = 0; i < e.children.length; i++)
                n.push.apply(n, t(e.children[i]));
            return n
        }(t), n = new C, i = [], r = [], o = new w(0,0,1), a = new w(0,1,0), s = 0; s < e.length; s++) {
            var c = e[s];
            c.parent && c.parent.isBone && (i.push(0, 0, 0),
            i.push(0, 0, 0),
            r.push(o.r, o.g, o.b),
            r.push(a.r, a.g, a.b))
        }
        n.addAttribute("position", new L(i,3)),
        n.addAttribute("color", new L(r,3)),
        i = new we({
            vertexColors: 2,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        }),
        Me.call(this, n, i),
        this.root = t,
        this.bones = e,
        this.matrix = t.matrixWorld,
        this.matrixAutoUpdate = !1
    }
    function _r(t, e, n) {
        this.light = t,
        this.light.updateMatrixWorld(),
        this.color = n,
        t = new yn(e,4,2),
        e = new B({
            wireframe: !0,
            fog: !1
        }),
        H.call(this, t, e),
        this.matrix = this.light.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function wr(t, e) {
        l.call(this),
        this.light = t,
        this.light.updateMatrixWorld(),
        this.matrix = t.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = e,
        t = new we({
            fog: !1
        }),
        (e = new C).addAttribute("position", new y(new Float32Array(15),3)),
        this.line = new Ee(e,t),
        this.add(this.line),
        this.update()
    }
    function Er(t, e, n) {
        l.call(this),
        this.light = t,
        this.light.updateMatrixWorld(),
        this.matrix = t.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = n,
        (t = new He(e)).rotateY(.5 * Math.PI),
        this.material = new B({
            wireframe: !0,
            fog: !1
        }),
        void 0 === this.color && (this.material.vertexColors = 2),
        e = t.getAttribute("position"),
        e = new Float32Array(3 * e.count),
        t.addAttribute("color", new y(e,3)),
        this.add(new H(t,this.material)),
        this.update()
    }
    function Mr(t, e, n, i) {
        t = t || 10,
        e = e || 10,
        n = new w(void 0 !== n ? n : 4473924),
        i = new w(void 0 !== i ? i : 8947848);
        var r = e / 2
          , o = t / e
          , a = t / 2;
        t = [];
        for (var s = [], c = 0, h = 0, l = -a; c <= e; c++,
        l += o) {
            t.push(-a, 0, l, a, 0, l),
            t.push(l, 0, -a, l, 0, a);
            var u = c === r ? n : i;
            u.toArray(s, h),
            h += 3,
            u.toArray(s, h),
            h += 3,
            u.toArray(s, h),
            h += 3,
            u.toArray(s, h),
            h += 3
        }
        (e = new C).addAttribute("position", new L(t,3)),
        e.addAttribute("color", new L(s,3)),
        n = new we({
            vertexColors: 2
        }),
        Me.call(this, e, n)
    }
    function Tr(t, e, n, i, r, o) {
        t = t || 10,
        e = e || 16,
        n = n || 8,
        i = i || 64,
        r = new w(void 0 !== r ? r : 4473924),
        o = new w(void 0 !== o ? o : 8947848);
        for (var a = [], s = [], c = 0; c <= e; c++) {
            var h = c / e * 2 * Math.PI
              , l = Math.sin(h) * t
              , h = Math.cos(h) * t;
            a.push(0, 0, 0),
            a.push(l, 0, h);
            var u = 1 & c ? r : o;
            s.push(u.r, u.g, u.b),
            s.push(u.r, u.g, u.b)
        }
        for (c = 0; c <= n; c++) {
            var u = 1 & c ? r : o
              , d = t - t / n * c;
            for (e = 0; e < i; e++)
                h = e / i * 2 * Math.PI,
                l = Math.sin(h) * d,
                h = Math.cos(h) * d,
                a.push(l, 0, h),
                s.push(u.r, u.g, u.b),
                h = (e + 1) / i * 2 * Math.PI,
                l = Math.sin(h) * d,
                h = Math.cos(h) * d,
                a.push(l, 0, h),
                s.push(u.r, u.g, u.b)
        }
        (t = new C).addAttribute("position", new L(a,3)),
        t.addAttribute("color", new L(s,3)),
        a = new we({
            vertexColors: 2
        }),
        Me.call(this, t, a)
    }
    function Sr(t, e, n, i) {
        this.object = t,
        this.size = void 0 !== e ? e : 1,
        t = void 0 !== n ? n : 16776960,
        i = void 0 !== i ? i : 1,
        e = 0,
        (n = this.object.geometry) && n.isGeometry ? e = n.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."),
        n = new C,
        e = new L(6 * e,3),
        n.addAttribute("position", e),
        Me.call(this, n, new we({
            color: t,
            linewidth: i
        })),
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function Ar(t, e, n) {
        l.call(this),
        this.light = t,
        this.light.updateMatrixWorld(),
        this.matrix = t.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = n,
        void 0 === e && (e = 1),
        (t = new C).addAttribute("position", new L([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0],3)),
        e = new we({
            fog: !1
        }),
        this.lightPlane = new Ee(t,e),
        this.add(this.lightPlane),
        (t = new C).addAttribute("position", new L([0, 0, 0, 0, 0, 1],3)),
        this.targetLine = new Ee(t,e),
        this.add(this.targetLine),
        this.update()
    }
    function Rr(t) {
        function e(t, e, n) {
            i(t, n),
            i(e, n)
        }
        function i(t, e) {
            o.push(0, 0, 0),
            a.push(e.r, e.g, e.b),
            void 0 === s[t] && (s[t] = []),
            s[t].push(o.length / 3 - 1)
        }
        var n = new C
          , r = new we({
            color: 16777215,
            vertexColors: 1
        })
          , o = []
          , a = []
          , s = {}
          , c = new w(16755200)
          , h = new w(16711680)
          , l = new w(43775)
          , u = new w(16777215)
          , d = new w(3355443);
        e("n1", "n2", c),
        e("n2", "n4", c),
        e("n4", "n3", c),
        e("n3", "n1", c),
        e("f1", "f2", c),
        e("f2", "f4", c),
        e("f4", "f3", c),
        e("f3", "f1", c),
        e("n1", "f1", c),
        e("n2", "f2", c),
        e("n3", "f3", c),
        e("n4", "f4", c),
        e("p", "n1", h),
        e("p", "n2", h),
        e("p", "n3", h),
        e("p", "n4", h),
        e("u1", "u2", l),
        e("u2", "u3", l),
        e("u3", "u1", l),
        e("c", "t", u),
        e("p", "c", d),
        e("cn1", "cn2", d),
        e("cn3", "cn4", d),
        e("cf1", "cf2", d),
        e("cf3", "cf4", d),
        n.addAttribute("position", new L(o,3)),
        n.addAttribute("color", new L(a,3)),
        Me.call(this, n, r),
        this.camera = t,
        this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
        this.matrix = t.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.pointMap = s,
        this.update()
    }
    function Lr(t, e) {
        this.object = t,
        void 0 === e && (e = 16776960),
        t = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        var n = new Float32Array(24)
          , i = new C;
        i.setIndex(new y(t,1)),
        i.addAttribute("position", new y(n,3)),
        Me.call(this, i, new we({
            color: e
        })),
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function Cr(t, e) {
        this.type = "Box3Helper",
        this.box = t,
        t = void 0 !== e ? e : 16776960,
        e = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        var n = new C;
        n.setIndex(new y(e,1)),
        n.addAttribute("position", new L([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],3)),
        Me.call(this, n, new we({
            color: t
        })),
        this.geometry.computeBoundingSphere()
    }
    function Pr(t, e, n) {
        this.type = "PlaneHelper",
        this.plane = t,
        this.size = void 0 === e ? 1 : e,
        t = void 0 !== n ? n : 16776960,
        (e = new C).addAttribute("position", new L([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0],3)),
        e.computeBoundingSphere(),
        Ee.call(this, e, new we({
            color: t
        })),
        (e = new C).addAttribute("position", new L([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],3)),
        e.computeBoundingSphere(),
        this.add(new H(e,new B({
            color: t,
            opacity: .2,
            transparent: !0,
            depthWrite: !1
        })))
    }
    function Nr(t, e, n, i, r, o) {
        l.call(this),
        void 0 === i && (i = 16776960),
        void 0 === n && (n = 1),
        void 0 === r && (r = .2 * n),
        void 0 === o && (o = .2 * r),
        void 0 === lh && ((lh = new C).addAttribute("position", new L([0, 0, 0, 0, 1, 0],3)),
        (uh = new Rn(0,.5,1,5,1)).translate(0, -.5, 0)),
        this.position.copy(e),
        this.line = new Ee(lh,new we({
            color: i
        })),
        this.line.matrixAutoUpdate = !1,
        this.add(this.line),
        this.cone = new H(uh,new B({
            color: i
        })),
        this.cone.matrixAutoUpdate = !1,
        this.add(this.cone),
        this.setDirection(t),
        this.setLength(n, r, o)
    }
    function Or(t) {
        var e = [0, 0, 0, t = t || 1, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t];
        (t = new C).addAttribute("position", new L(e,3)),
        t.addAttribute("color", new L([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],3)),
        e = new we({
            vertexColors: 2
        }),
        Me.call(this, t, e)
    }
    function Ir(t) {
        console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),
        $n.call(this, t),
        this.type = "catmullrom",
        this.closed = !0
    }
    function Br(t) {
        console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),
        $n.call(this, t),
        this.type = "catmullrom"
    }
    function Ur(t) {
        console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."),
        $n.call(this, t),
        this.type = "catmullrom"
    }
    void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
    void 0 === Number.isInteger && (Number.isInteger = function(t) {
        return "number" == typeof t && isFinite(t) && Math.floor(t) === t
    }
    ),
    void 0 === Math.sign && (Math.sign = function(t) {
        return t < 0 ? -1 : 0 < t ? 1 : +t
    }
    ),
    !1 == "name"in Function.prototype && Object.defineProperty(Function.prototype, "name", {
        get: function() {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
        }
    }),
    void 0 === Object.assign && (Object.assign = function(t) {
        if (null == t)
            throw new TypeError("Cannot convert undefined or null to object");
        for (var e = Object(t), n = 1; n < arguments.length; n++) {
            var i = arguments[n];
            if (null != i)
                for (var r in i)
                    Object.prototype.hasOwnProperty.call(i, r) && (e[r] = i[r])
        }
        return e
    }
    ),
    Object.assign(e.prototype, {
        addEventListener: function(t, e) {
            void 0 === this._listeners && (this._listeners = {});
            var n = this._listeners;
            void 0 === n[t] && (n[t] = []),
            -1 === n[t].indexOf(e) && n[t].push(e)
        },
        hasEventListener: function(t, e) {
            if (void 0 === this._listeners)
                return !1;
            var n = this._listeners;
            return void 0 !== n[t] && -1 !== n[t].indexOf(e)
        },
        removeEventListener: function(t, e) {
            void 0 !== this._listeners && (void 0 !== (t = this._listeners[t]) && (-1 !== (e = t.indexOf(e)) && t.splice(e, 1)))
        },
        dispatchEvent: function(t) {
            if (void 0 !== this._listeners && void 0 !== (e = this._listeners[t.type])) {
                t.target = this;
                for (var e, n = 0, i = (e = e.slice(0)).length; n < i; n++)
                    e[n].call(this, t)
            }
        }
    });
    var Dr, Fr, zr, Hr, Gr, kr, Vr, jr, Wr, Xr, qr, Yr, Zr, Jr, Qr, Kr, $r, to, eo, no, io = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: function() {
            for (var r = [], t = 0; t < 256; t++)
                r[t] = (t < 16 ? "0" : "") + t.toString(16);
            return function() {
                var t = 4294967295 * Math.random() | 0
                  , e = 4294967295 * Math.random() | 0
                  , n = 4294967295 * Math.random() | 0
                  , i = 4294967295 * Math.random() | 0;
                return (r[255 & t] + r[t >> 8 & 255] + r[t >> 16 & 255] + r[t >> 24 & 255] + "-" + r[255 & e] + r[e >> 8 & 255] + "-" + r[e >> 16 & 15 | 64] + r[e >> 24 & 255] + "-" + r[63 & n | 128] + r[n >> 8 & 255] + "-" + r[n >> 16 & 255] + r[n >> 24 & 255] + r[255 & i] + r[i >> 8 & 255] + r[i >> 16 & 255] + r[i >> 24 & 255]).toUpperCase()
            }
        }(),
        clamp: function(t, e, n) {
            return Math.max(e, Math.min(n, t))
        },
        euclideanModulo: function(t, e) {
            return (t % e + e) % e
        },
        mapLinear: function(t, e, n, i, r) {
            return i + (t - e) * (r - i) / (n - e)
        },
        lerp: function(t, e, n) {
            return (1 - n) * t + n * e
        },
        smoothstep: function(t, e, n) {
            return t <= e ? 0 : n <= t ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
        },
        smootherstep: function(t, e, n) {
            return t <= e ? 0 : n <= t ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
        },
        randInt: function(t, e) {
            return t + Math.floor(Math.random() * (e - t + 1))
        },
        randFloat: function(t, e) {
            return t + Math.random() * (e - t)
        },
        randFloatSpread: function(t) {
            return t * (.5 - Math.random())
        },
        degToRad: function(t) {
            return t * io.DEG2RAD
        },
        radToDeg: function(t) {
            return t * io.RAD2DEG
        },
        isPowerOfTwo: function(t) {
            return 0 == (t & t - 1) && 0 !== t
        },
        ceilPowerOfTwo: function(t) {
            return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
        },
        floorPowerOfTwo: function(t) {
            return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
        }
    };
    Object.defineProperties(W.prototype, {
        width: {
            get: function() {
                return this.x
            },
            set: function(t) {
                this.x = t
            }
        },
        height: {
            get: function() {
                return this.y
            },
            set: function(t) {
                this.y = t
            }
        }
    }),
    Object.assign(W.prototype, {
        isVector2: !0,
        set: function(t, e) {
            return this.x = t,
            this.y = e,
            this
        },
        setScalar: function(t) {
            return this.y = this.x = t,
            this
        },
        setX: function(t) {
            return this.x = t,
            this
        },
        setY: function(t) {
            return this.y = t,
            this
        },
        setComponent: function(t, e) {
            switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            default:
                throw Error("index is out of range: " + t)
            }
            return this
        },
        getComponent: function(t) {
            switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw Error("index is out of range: " + t)
            }
        },
        clone: function() {
            return new this.constructor(this.x,this.y)
        },
        copy: function(t) {
            return this.x = t.x,
            this.y = t.y,
            this
        },
        add: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(t, e)) : (this.x += t.x,
            this.y += t.y,
            this)
        },
        addScalar: function(t) {
            return this.x += t,
            this.y += t,
            this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x,
            this.y = t.y + e.y,
            this
        },
        addScaledVector: function(t, e) {
            return this.x += t.x * e,
            this.y += t.y * e,
            this
        },
        sub: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(t, e)) : (this.x -= t.x,
            this.y -= t.y,
            this)
        },
        subScalar: function(t) {
            return this.x -= t,
            this.y -= t,
            this
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x,
            this.y = t.y - e.y,
            this
        },
        multiply: function(t) {
            return this.x *= t.x,
            this.y *= t.y,
            this
        },
        multiplyScalar: function(t) {
            return this.x *= t,
            this.y *= t,
            this
        },
        divide: function(t) {
            return this.x /= t.x,
            this.y /= t.y,
            this
        },
        divideScalar: function(t) {
            return this.multiplyScalar(1 / t)
        },
        applyMatrix3: function(t) {
            var e = this.x
              , n = this.y;
            return t = t.elements,
            this.x = t[0] * e + t[3] * n + t[6],
            this.y = t[1] * e + t[4] * n + t[7],
            this
        },
        min: function(t) {
            return this.x = Math.min(this.x, t.x),
            this.y = Math.min(this.y, t.y),
            this
        },
        max: function(t) {
            return this.x = Math.max(this.x, t.x),
            this.y = Math.max(this.y, t.y),
            this
        },
        clamp: function(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)),
            this.y = Math.max(t.y, Math.min(e.y, this.y)),
            this
        },
        clampScalar: (Dr = new W,
        Fr = new W,
        function(t, e) {
            return Dr.set(t, t),
            Fr.set(e, e),
            this.clamp(Dr, Fr)
        }
        ),
        clampLength: function(t, e) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        angle: function() {
            var t = Math.atan2(this.y, this.x);
            return t < 0 && (t += 2 * Math.PI),
            t
        },
        distanceTo: function(t) {
            return Math.sqrt(this.distanceToSquared(t))
        },
        distanceToSquared: function(t) {
            var e = this.x - t.x;
            return e * e + (t = this.y - t.y) * t
        },
        manhattanDistanceTo: function(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
        },
        setLength: function(t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e,
            this.y += (t.y - this.y) * e,
            this
        },
        lerpVectors: function(t, e, n) {
            return this.subVectors(e, t).multiplyScalar(n).add(t)
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y
        },
        fromArray: function(t, e) {
            return this.x = t[e = void 0 === e ? 0 : e],
            this.y = t[e + 1],
            this
        },
        toArray: function(t, e) {
            return (t = void 0 === t ? [] : t)[e = void 0 === e ? 0 : e] = this.x,
            t[e + 1] = this.y,
            t
        },
        fromBufferAttribute: function(t, e, n) {
            return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),
            this.x = t.getX(e),
            this.y = t.getY(e),
            this
        },
        rotateAround: function(t, e) {
            var n = Math.cos(e);
            e = Math.sin(e);
            var i = this.x - t.x
              , r = this.y - t.y;
            return this.x = i * n - r * e + t.x,
            this.y = i * e + r * n + t.y,
            this
        }
    }),
    Object.assign(_t.prototype, {
        isMatrix4: !0,
        set: function(t, e, n, i, r, o, a, s, c, h, l, u, d, p, f, m) {
            var g = this.elements;
            return g[0] = t,
            g[4] = e,
            g[8] = n,
            g[12] = i,
            g[1] = r,
            g[5] = o,
            g[9] = a,
            g[13] = s,
            g[2] = c,
            g[6] = h,
            g[10] = l,
            g[14] = u,
            g[3] = d,
            g[7] = p,
            g[11] = f,
            g[15] = m,
            this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        },
        clone: function() {
            return (new _t).fromArray(this.elements)
        },
        copy: function(t) {
            var e = this.elements;
            return t = t.elements,
            e[0] = t[0],
            e[1] = t[1],
            e[2] = t[2],
            e[3] = t[3],
            e[4] = t[4],
            e[5] = t[5],
            e[6] = t[6],
            e[7] = t[7],
            e[8] = t[8],
            e[9] = t[9],
            e[10] = t[10],
            e[11] = t[11],
            e[12] = t[12],
            e[13] = t[13],
            e[14] = t[14],
            e[15] = t[15],
            this
        },
        copyPosition: function(t) {
            var e = this.elements;
            return t = t.elements,
            e[12] = t[12],
            e[13] = t[13],
            e[14] = t[14],
            this
        },
        extractBasis: function(t, e, n) {
            return t.setFromMatrixColumn(this, 0),
            e.setFromMatrixColumn(this, 1),
            n.setFromMatrixColumn(this, 2),
            this
        },
        makeBasis: function(t, e, n) {
            return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1),
            this
        },
        extractRotation: (Wr = new wt,
        function(t) {
            var e = this.elements
              , n = t.elements
              , i = 1 / Wr.setFromMatrixColumn(t, 0).length()
              , r = 1 / Wr.setFromMatrixColumn(t, 1).length();
            return t = 1 / Wr.setFromMatrixColumn(t, 2).length(),
            e[0] = n[0] * i,
            e[1] = n[1] * i,
            e[2] = n[2] * i,
            e[4] = n[4] * r,
            e[5] = n[5] * r,
            e[6] = n[6] * r,
            e[8] = n[8] * t,
            e[9] = n[9] * t,
            e[10] = n[10] * t,
            this
        }
        ),
        makeRotationFromEuler: function(t) {
            t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var e, n, i, r = this.elements, o = t.x, a = t.y, s = t.z, c = Math.cos(o), o = Math.sin(o), h = Math.cos(a), a = Math.sin(a), l = Math.cos(s), s = Math.sin(s);
            return "XYZ" === t.order ? (t = c * l,
            e = c * s,
            n = o * l,
            i = o * s,
            r[0] = h * l,
            r[4] = -h * s,
            r[8] = a,
            r[1] = e + n * a,
            r[5] = t - i * a,
            r[9] = -o * h,
            r[2] = i - t * a,
            r[6] = n + e * a,
            r[10] = c * h) : "YXZ" === t.order ? (e = h * s,
            n = a * l,
            r[0] = (t = h * l) + (i = a * s) * o,
            r[4] = n * o - e,
            r[8] = c * a,
            r[1] = c * s,
            r[5] = c * l,
            r[9] = -o,
            r[2] = e * o - n,
            r[6] = i + t * o,
            r[10] = c * h) : "ZXY" === t.order ? (e = h * s,
            n = a * l,
            r[0] = (t = h * l) - (i = a * s) * o,
            r[4] = -c * s,
            r[8] = n + e * o,
            r[1] = e + n * o,
            r[5] = c * l,
            r[9] = i - t * o,
            r[2] = -c * a,
            r[6] = o,
            r[10] = c * h) : "ZYX" === t.order ? (t = c * l,
            e = c * s,
            n = o * l,
            i = o * s,
            r[0] = h * l,
            r[4] = n * a - e,
            r[8] = t * a + i,
            r[1] = h * s,
            r[5] = i * a + t,
            r[9] = e * a - n,
            r[2] = -a,
            r[6] = o * h,
            r[10] = c * h) : "YZX" === t.order ? (t = c * h,
            e = c * a,
            n = o * h,
            i = o * a,
            r[0] = h * l,
            r[4] = i - t * s,
            r[8] = n * s + e,
            r[1] = s,
            r[5] = c * l,
            r[9] = -o * l,
            r[2] = -a * l,
            r[6] = e * s + n,
            r[10] = t - i * s) : "XZY" === t.order && (t = c * h,
            e = c * a,
            n = o * h,
            i = o * a,
            r[0] = h * l,
            r[4] = -s,
            r[8] = a * l,
            r[1] = t * s + i,
            r[5] = c * l,
            r[9] = e * s - n,
            r[2] = n * s - e,
            r[6] = o * l,
            r[10] = i * s + t),
            r[3] = 0,
            r[7] = 0,
            r[11] = 0,
            r[12] = 0,
            r[13] = 0,
            r[14] = 0,
            r[15] = 1,
            this
        },
        makeRotationFromQuaternion: function(t) {
            var e = this.elements
              , n = t._x
              , i = t._y
              , r = t._z
              , o = t._w
              , a = n + n
              , s = i + i
              , c = r + r;
            t = n * a;
            var h = n * s;
            n *= c;
            var l = i * s;
            return i *= c,
            a *= o,
            s *= o,
            o *= c,
            e[0] = 1 - (l + (r *= c)),
            e[4] = h - o,
            e[8] = n + s,
            e[1] = h + o,
            e[5] = 1 - (t + r),
            e[9] = i - a,
            e[2] = n - s,
            e[6] = i + a,
            e[10] = 1 - (t + l),
            e[3] = 0,
            e[7] = 0,
            e[11] = 0,
            e[12] = 0,
            e[13] = 0,
            e[14] = 0,
            e[15] = 1,
            this
        },
        lookAt: (kr = new wt,
        Vr = new wt,
        jr = new wt,
        function(t, e, n) {
            var i = this.elements;
            return jr.subVectors(t, e),
            0 === jr.lengthSq() && (jr.z = 1),
            jr.normalize(),
            kr.crossVectors(n, jr),
            0 === kr.lengthSq() && (1 === Math.abs(n.z) ? jr.x += 1e-4 : jr.z += 1e-4,
            jr.normalize(),
            kr.crossVectors(n, jr)),
            kr.normalize(),
            Vr.crossVectors(jr, kr),
            i[0] = kr.x,
            i[4] = Vr.x,
            i[8] = jr.x,
            i[1] = kr.y,
            i[5] = Vr.y,
            i[9] = jr.y,
            i[2] = kr.z,
            i[6] = Vr.z,
            i[10] = jr.z,
            this
        }
        ),
        multiply: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
            this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
        },
        premultiply: function(t) {
            return this.multiplyMatrices(t, this)
        },
        multiplyMatrices: function(t, e) {
            var n = t.elements
              , i = e.elements;
            e = this.elements,
            t = n[0];
            var r = n[4]
              , o = n[8]
              , a = n[12]
              , s = n[1]
              , c = n[5]
              , h = n[9]
              , l = n[13]
              , u = n[2]
              , d = n[6]
              , p = n[10]
              , f = n[14]
              , m = n[3]
              , g = n[7]
              , v = n[11]
              , n = n[15]
              , y = i[0]
              , x = i[4]
              , b = i[8]
              , _ = i[12]
              , w = i[1]
              , E = i[5]
              , M = i[9]
              , T = i[13]
              , S = i[2]
              , A = i[6]
              , R = i[10]
              , L = i[14]
              , C = i[3]
              , P = i[7]
              , N = i[11]
              , i = i[15];
            return e[0] = t * y + r * w + o * S + a * C,
            e[4] = t * x + r * E + o * A + a * P,
            e[8] = t * b + r * M + o * R + a * N,
            e[12] = t * _ + r * T + o * L + a * i,
            e[1] = s * y + c * w + h * S + l * C,
            e[5] = s * x + c * E + h * A + l * P,
            e[9] = s * b + c * M + h * R + l * N,
            e[13] = s * _ + c * T + h * L + l * i,
            e[2] = u * y + d * w + p * S + f * C,
            e[6] = u * x + d * E + p * A + f * P,
            e[10] = u * b + d * M + p * R + f * N,
            e[14] = u * _ + d * T + p * L + f * i,
            e[3] = m * y + g * w + v * S + n * C,
            e[7] = m * x + g * E + v * A + n * P,
            e[11] = m * b + g * M + v * R + n * N,
            e[15] = m * _ + g * T + v * L + n * i,
            this
        },
        multiplyScalar: function(t) {
            var e = this.elements;
            return e[0] *= t,
            e[4] *= t,
            e[8] *= t,
            e[12] *= t,
            e[1] *= t,
            e[5] *= t,
            e[9] *= t,
            e[13] *= t,
            e[2] *= t,
            e[6] *= t,
            e[10] *= t,
            e[14] *= t,
            e[3] *= t,
            e[7] *= t,
            e[11] *= t,
            e[15] *= t,
            this
        },
        applyToBufferAttribute: (Gr = new wt,
        function(t) {
            for (var e = 0, n = t.count; e < n; e++)
                Gr.x = t.getX(e),
                Gr.y = t.getY(e),
                Gr.z = t.getZ(e),
                Gr.applyMatrix4(this),
                t.setXYZ(e, Gr.x, Gr.y, Gr.z);
            return t
        }
        ),
        determinant: function() {
            var t = this.elements
              , e = t[0]
              , n = t[4]
              , i = t[8]
              , r = t[12]
              , o = t[1]
              , a = t[5]
              , s = t[9]
              , c = t[13]
              , h = t[2]
              , l = t[6]
              , u = t[10]
              , d = t[14];
            return t[3] * (+r * s * l - i * c * l - r * a * u + n * c * u + i * a * d - n * s * d) + t[7] * (+e * s * d - e * c * u + r * o * u - i * o * d + i * c * h - r * s * h) + t[11] * (+e * c * l - e * a * d - r * o * l + n * o * d + r * a * h - n * c * h) + t[15] * (-i * a * h - e * s * l + e * a * u + i * o * l - n * o * u + n * s * h)
        },
        transpose: function() {
            var t = this.elements
              , e = t[1];
            return t[1] = t[4],
            t[4] = e,
            e = t[2],
            t[2] = t[8],
            t[8] = e,
            e = t[6],
            t[6] = t[9],
            t[9] = e,
            e = t[3],
            t[3] = t[12],
            t[12] = e,
            e = t[7],
            t[7] = t[13],
            t[13] = e,
            e = t[11],
            t[11] = t[14],
            t[14] = e,
            this
        },
        setPosition: function(t) {
            var e = this.elements;
            return e[12] = t.x,
            e[13] = t.y,
            e[14] = t.z,
            this
        },
        getInverse: function(t, e) {
            var n = this.elements
              , i = t.elements;
            t = i[0];
            var r = i[1]
              , o = i[2]
              , a = i[3]
              , s = i[4]
              , c = i[5]
              , h = i[6]
              , l = i[7]
              , u = i[8]
              , d = i[9]
              , p = i[10]
              , f = i[11]
              , m = i[12]
              , g = i[13]
              , v = i[14]
              , y = d * v * l - g * p * l + g * h * f - c * v * f - d * h * (i = i[15]) + c * p * i
              , x = m * p * l - u * v * l - m * h * f + s * v * f + u * h * i - s * p * i
              , b = u * g * l - m * d * l + m * c * f - s * g * f - u * c * i + s * d * i
              , _ = m * d * h - u * g * h - m * c * p + s * g * p + u * c * v - s * d * v
              , w = t * y + r * x + o * b + a * _;
            if (0 != w)
                return n[0] = y * (e = 1 / w),
                n[1] = (g * p * a - d * v * a - g * o * f + r * v * f + d * o * i - r * p * i) * e,
                n[2] = (c * v * a - g * h * a + g * o * l - r * v * l - c * o * i + r * h * i) * e,
                n[3] = (d * h * a - c * p * a - d * o * l + r * p * l + c * o * f - r * h * f) * e,
                n[4] = x * e,
                n[5] = (u * v * a - m * p * a + m * o * f - t * v * f - u * o * i + t * p * i) * e,
                n[6] = (m * h * a - s * v * a - m * o * l + t * v * l + s * o * i - t * h * i) * e,
                n[7] = (s * p * a - u * h * a + u * o * l - t * p * l - s * o * f + t * h * f) * e,
                n[8] = b * e,
                n[9] = (m * d * a - u * g * a - m * r * f + t * g * f + u * r * i - t * d * i) * e,
                n[10] = (s * g * a - m * c * a + m * r * l - t * g * l - s * r * i + t * c * i) * e,
                n[11] = (u * c * a - s * d * a - u * r * l + t * d * l + s * r * f - t * c * f) * e,
                n[12] = _ * e,
                n[13] = (u * g * o - m * d * o + m * r * p - t * g * p - u * r * v + t * d * v) * e,
                n[14] = (m * c * o - s * g * o - m * r * h + t * g * h + s * r * v - t * c * v) * e,
                n[15] = (s * d * o - u * c * o + u * r * h - t * d * h - s * r * p + t * c * p) * e,
                this;
            if (!0 === e)
                throw Error("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
            return console.warn("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"),
            this.identity()
        },
        scale: function(t) {
            var e = this.elements
              , n = t.x
              , i = t.y;
            return t = t.z,
            e[0] *= n,
            e[4] *= i,
            e[8] *= t,
            e[1] *= n,
            e[5] *= i,
            e[9] *= t,
            e[2] *= n,
            e[6] *= i,
            e[10] *= t,
            e[3] *= n,
            e[7] *= i,
            e[11] *= t,
            this
        },
        getMaxScaleOnAxis: function() {
            var t = this.elements;
            return Math.sqrt(Math.max(t[0] * t[0] + t[1] * t[1] + t[2] * t[2], t[4] * t[4] + t[5] * t[5] + t[6] * t[6], t[8] * t[8] + t[9] * t[9] + t[10] * t[10]))
        },
        makeTranslation: function(t, e, n) {
            return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1),
            this
        },
        makeRotationX: function(t) {
            var e = Math.cos(t);
            return t = Math.sin(t),
            this.set(1, 0, 0, 0, 0, e, -t, 0, 0, t, e, 0, 0, 0, 0, 1),
            this
        },
        makeRotationY: function(t) {
            var e = Math.cos(t);
            return t = Math.sin(t),
            this.set(e, 0, t, 0, 0, 1, 0, 0, -t, 0, e, 0, 0, 0, 0, 1),
            this
        },
        makeRotationZ: function(t) {
            var e = Math.cos(t);
            return t = Math.sin(t),
            this.set(e, -t, 0, 0, t, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        },
        makeRotationAxis: function(t, e) {
            var n = Math.cos(e);
            e = Math.sin(e);
            var i = 1 - n
              , r = t.x
              , o = t.y;
            t = t.z;
            var a = i * r
              , s = i * o;
            return this.set(a * r + n, a * o - e * t, a * t + e * o, 0, a * o + e * t, s * o + n, s * t - e * r, 0, a * t - e * o, s * t + e * r, i * t * t + n, 0, 0, 0, 0, 1),
            this
        },
        makeScale: function(t, e, n) {
            return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
            this
        },
        makeShear: function(t, e, n) {
            return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1),
            this
        },
        compose: function(t, e, n) {
            return this.makeRotationFromQuaternion(e),
            this.scale(n),
            this.setPosition(t),
            this
        },
        decompose: (zr = new wt,
        Hr = new _t,
        function(t, e, n) {
            var i = this.elements
              , r = zr.set(i[0], i[1], i[2]).length()
              , o = zr.set(i[4], i[5], i[6]).length()
              , a = zr.set(i[8], i[9], i[10]).length();
            this.determinant() < 0 && (r = -r),
            t.x = i[12],
            t.y = i[13],
            t.z = i[14],
            Hr.copy(this);
            var i = 1 / o
              , s = 1 / a;
            return Hr.elements[0] *= t = 1 / r,
            Hr.elements[1] *= t,
            Hr.elements[2] *= t,
            Hr.elements[4] *= i,
            Hr.elements[5] *= i,
            Hr.elements[6] *= i,
            Hr.elements[8] *= s,
            Hr.elements[9] *= s,
            Hr.elements[10] *= s,
            e.setFromRotationMatrix(Hr),
            n.x = r,
            n.y = o,
            n.z = a,
            this
        }
        ),
        makePerspective: function(t, e, n, i, r, o) {
            void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            var a = this.elements;
            return a[0] = 2 * r / (e - t),
            a[4] = 0,
            a[8] = (e + t) / (e - t),
            a[12] = 0,
            a[1] = 0,
            a[5] = 2 * r / (n - i),
            a[9] = (n + i) / (n - i),
            a[13] = 0,
            a[2] = 0,
            a[6] = 0,
            a[10] = -(o + r) / (o - r),
            a[14] = -2 * o * r / (o - r),
            a[3] = 0,
            a[7] = 0,
            a[11] = -1,
            a[15] = 0,
            this
        },
        makeOrthographic: function(t, e, n, i, r, o) {
            var a = this.elements
              , s = 1 / (e - t)
              , c = 1 / (n - i)
              , h = 1 / (o - r);
            return a[0] = 2 * s,
            a[4] = 0,
            a[8] = 0,
            a[12] = -(e + t) * s,
            a[1] = 0,
            a[5] = 2 * c,
            a[9] = 0,
            a[13] = -(n + i) * c,
            a[2] = 0,
            a[6] = 0,
            a[10] = -2 * h,
            a[14] = -(o + r) * h,
            a[3] = 0,
            a[7] = 0,
            a[11] = 0,
            a[15] = 1,
            this
        },
        equals: function(t) {
            var e = this.elements;
            t = t.elements;
            for (var n = 0; n < 16; n++)
                if (e[n] !== t[n])
                    return !1;
            return !0
        },
        fromArray: function(t, e) {
            void 0 === e && (e = 0);
            for (var n = 0; n < 16; n++)
                this.elements[n] = t[n + e];
            return this
        },
        toArray: function(t, e) {
            var n = this.elements;
            return (t = void 0 === t ? [] : t)[e = void 0 === e ? 0 : e] = n[0],
            t[e + 1] = n[1],
            t[e + 2] = n[2],
            t[e + 3] = n[3],
            t[e + 4] = n[4],
            t[e + 5] = n[5],
            t[e + 6] = n[6],
            t[e + 7] = n[7],
            t[e + 8] = n[8],
            t[e + 9] = n[9],
            t[e + 10] = n[10],
            t[e + 11] = n[11],
            t[e + 12] = n[12],
            t[e + 13] = n[13],
            t[e + 14] = n[14],
            t[e + 15] = n[15],
            t
        }
    }),
    Object.assign(V, {
        slerp: function(t, e, n, i) {
            return n.copy(t).slerp(e, i)
        },
        slerpFlat: function(t, e, n, i, r, o, a) {
            var s = n[i + 0]
              , c = n[i + 1]
              , h = n[i + 2];
            n = n[i + 3],
            i = r[o + 0];
            var l, u, d, p = r[o + 1], f = r[o + 2];
            n === (r = r[o + 3]) && s === i && c === p && h === f || (o = 1 - a,
            u = 0 <= (l = s * i + c * p + h * f + n * r) ? 1 : -1,
            (d = 1 - l * l) > Number.EPSILON && (d = Math.sqrt(d),
            l = Math.atan2(d, l * u),
            o = Math.sin(o * l) / d,
            a = Math.sin(a * l) / d),
            s = s * o + i * (u *= a),
            c = c * o + p * u,
            h = h * o + f * u,
            n = n * o + r * u,
            o === 1 - a && (s *= a = 1 / Math.sqrt(s * s + c * c + h * h + n * n),
            c *= a,
            h *= a,
            n *= a)),
            t[e] = s,
            t[e + 1] = c,
            t[e + 2] = h,
            t[e + 3] = n
        }
    }),
    Object.defineProperties(V.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(t) {
                this._x = t,
                this.onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(t) {
                this._y = t,
                this.onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(t) {
                this._z = t,
                this.onChangeCallback()
            }
        },
        w: {
            get: function() {
                return this._w
            },
            set: function(t) {
                this._w = t,
                this.onChangeCallback()
            }
        }
    }),
    Object.assign(V.prototype, {
        set: function(t, e, n, i) {
            return this._x = t,
            this._y = e,
            this._z = n,
            this._w = i,
            this.onChangeCallback(),
            this
        },
        clone: function() {
            return new this.constructor(this._x,this._y,this._z,this._w)
        },
        copy: function(t) {
            return this._x = t.x,
            this._y = t.y,
            this._z = t.z,
            this._w = t.w,
            this.onChangeCallback(),
            this
        },
        setFromEuler: function(t, e) {
            if (!t || !t.isEuler)
                throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var n = t._x
              , i = t._y
              , r = t._z;
            t = t.order;
            var o = Math.cos
              , a = Math.sin
              , s = o(n / 2)
              , c = o(i / 2)
              , o = o(r / 2)
              , n = a(n / 2)
              , i = a(i / 2)
              , r = a(r / 2);
            return "XYZ" === t ? (this._x = n * c * o + s * i * r,
            this._y = s * i * o - n * c * r,
            this._z = s * c * r + n * i * o,
            this._w = s * c * o - n * i * r) : "YXZ" === t ? (this._x = n * c * o + s * i * r,
            this._y = s * i * o - n * c * r,
            this._z = s * c * r - n * i * o,
            this._w = s * c * o + n * i * r) : "ZXY" === t ? (this._x = n * c * o - s * i * r,
            this._y = s * i * o + n * c * r,
            this._z = s * c * r + n * i * o,
            this._w = s * c * o - n * i * r) : "ZYX" === t ? (this._x = n * c * o - s * i * r,
            this._y = s * i * o + n * c * r,
            this._z = s * c * r - n * i * o,
            this._w = s * c * o + n * i * r) : "YZX" === t ? (this._x = n * c * o + s * i * r,
            this._y = s * i * o + n * c * r,
            this._z = s * c * r - n * i * o,
            this._w = s * c * o - n * i * r) : "XZY" === t && (this._x = n * c * o - s * i * r,
            this._y = s * i * o - n * c * r,
            this._z = s * c * r + n * i * o,
            this._w = s * c * o + n * i * r),
            !1 !== e && this.onChangeCallback(),
            this
        },
        setFromAxisAngle: function(t, e) {
            e /= 2;
            var n = Math.sin(e);
            return this._x = t.x * n,
            this._y = t.y * n,
            this._z = t.z * n,
            this._w = Math.cos(e),
            this.onChangeCallback(),
            this
        },
        setFromRotationMatrix: function(t) {
            var e = t.elements
              , n = e[0];
            t = e[4];
            var i = e[8]
              , r = e[1]
              , o = e[5]
              , a = e[9]
              , s = e[2]
              , c = e[6]
              , h = n + o + (e = e[10]);
            return 0 < h ? (n = .5 / Math.sqrt(h + 1),
            this._w = .25 / n,
            this._x = (c - a) * n,
            this._y = (i - s) * n,
            this._z = (r - t) * n) : o < n && e < n ? (n = 2 * Math.sqrt(1 + n - o - e),
            this._w = (c - a) / n,
            this._x = .25 * n,
            this._y = (t + r) / n,
            this._z = (i + s) / n) : e < o ? (n = 2 * Math.sqrt(1 + o - n - e),
            this._w = (i - s) / n,
            this._x = (t + r) / n,
            this._y = .25 * n,
            this._z = (a + c) / n) : (n = 2 * Math.sqrt(1 + e - n - o),
            this._w = (r - t) / n,
            this._x = (i + s) / n,
            this._y = (a + c) / n,
            this._z = .25 * n),
            this.onChangeCallback(),
            this
        },
        setFromUnitVectors: (qr = new wt,
        function(t, e) {
            return void 0 === qr && (qr = new wt),
            (Xr = t.dot(e) + 1) < 1e-6 ? (Xr = 0,
            Math.abs(t.x) > Math.abs(t.z) ? qr.set(-t.y, t.x, 0) : qr.set(0, -t.z, t.y)) : qr.crossVectors(t, e),
            this._x = qr.x,
            this._y = qr.y,
            this._z = qr.z,
            this._w = Xr,
            this.normalize()
        }
        ),
        inverse: function() {
            return this.conjugate()
        },
        conjugate: function() {
            return this._x *= -1,
            this._y *= -1,
            this._z *= -1,
            this.onChangeCallback(),
            this
        },
        dot: function(t) {
            return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
        },
        lengthSq: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        },
        length: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        },
        normalize: function() {
            var t = this.length();
            return 0 === t ? (this._z = this._y = this._x = 0,
            this._w = 1) : (this._x *= t = 1 / t,
            this._y *= t,
            this._z *= t,
            this._w *= t),
            this.onChangeCallback(),
            this
        },
        multiply: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
            this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
        },
        premultiply: function(t) {
            return this.multiplyQuaternions(t, this)
        },
        multiplyQuaternions: function(t, e) {
            var n = t._x
              , i = t._y
              , r = t._z;
            t = t._w;
            var o = e._x
              , a = e._y
              , s = e._z;
            return e = e._w,
            this._x = n * e + t * o + i * s - r * a,
            this._y = i * e + t * a + r * o - n * s,
            this._z = r * e + t * s + n * a - i * o,
            this._w = t * e - n * o - i * a - r * s,
            this.onChangeCallback(),
            this
        },
        slerp: function(t, e) {
            if (0 === e)
                return this;
            if (1 === e)
                return this.copy(t);
            var n = this._x
              , i = this._y
              , r = this._z
              , o = this._w;
            if ((s = o * t._w + n * t._x + i * t._y + r * t._z) < 0 ? (this._w = -t._w,
            this._x = -t._x,
            this._y = -t._y,
            this._z = -t._z,
            s = -s) : this.copy(t),
            1 <= s)
                return this._w = o,
                this._x = n,
                this._y = i,
                this._z = r,
                this;
            if (t = Math.sqrt(1 - s * s),
            Math.abs(t) < .001)
                return this._w = .5 * (o + this._w),
                this._x = .5 * (n + this._x),
                this._y = .5 * (i + this._y),
                this._z = .5 * (r + this._z),
                this;
            var a = Math.atan2(t, s)
              , s = Math.sin((1 - e) * a) / t;
            return e = Math.sin(e * a) / t,
            this._w = o * s + this._w * e,
            this._x = n * s + this._x * e,
            this._y = i * s + this._y * e,
            this._z = r * s + this._z * e,
            this.onChangeCallback(),
            this
        },
        equals: function(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
        },
        fromArray: function(t, e) {
            return this._x = t[e = void 0 === e ? 0 : e],
            this._y = t[e + 1],
            this._z = t[e + 2],
            this._w = t[e + 3],
            this.onChangeCallback(),
            this
        },
        toArray: function(t, e) {
            return (t = void 0 === t ? [] : t)[e = void 0 === e ? 0 : e] = this._x,
            t[e + 1] = this._y,
            t[e + 2] = this._z,
            t[e + 3] = this._w,
            t
        },
        onChange: function(t) {
            return this.onChangeCallback = t,
            this
        },
        onChangeCallback: function() {}
    }),
    Object.assign(wt.prototype, {
        isVector3: !0,
        set: function(t, e, n) {
            return this.x = t,
            this.y = e,
            this.z = n,
            this
        },
        setScalar: function(t) {
            return this.z = this.y = this.x = t,
            this
        },
        setX: function(t) {
            return this.x = t,
            this
        },
        setY: function(t) {
            return this.y = t,
            this
        },
        setZ: function(t) {
            return this.z = t,
            this
        },
        setComponent: function(t, e) {
            switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            case 2:
                this.z = e;
                break;
            default:
                throw Error("index is out of range: " + t)
            }
            return this
        },
        getComponent: function(t) {
            switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw Error("index is out of range: " + t)
            }
        },
        clone: function() {
            return new this.constructor(this.x,this.y,this.z)
        },
        copy: function(t) {
            return this.x = t.x,
            this.y = t.y,
            this.z = t.z,
            this
        },
        add: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(t, e)) : (this.x += t.x,
            this.y += t.y,
            this.z += t.z,
            this)
        },
        addScalar: function(t) {
            return this.x += t,
            this.y += t,
            this.z += t,
            this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x,
            this.y = t.y + e.y,
            this.z = t.z + e.z,
            this
        },
        addScaledVector: function(t, e) {
            return this.x += t.x * e,
            this.y += t.y * e,
            this.z += t.z * e,
            this
        },
        sub: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(t, e)) : (this.x -= t.x,
            this.y -= t.y,
            this.z -= t.z,
            this)
        },
        subScalar: function(t) {
            return this.x -= t,
            this.y -= t,
            this.z -= t,
            this
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x,
            this.y = t.y - e.y,
            this.z = t.z - e.z,
            this
        },
        multiply: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
            this.multiplyVectors(t, e)) : (this.x *= t.x,
            this.y *= t.y,
            this.z *= t.z,
            this)
        },
        multiplyScalar: function(t) {
            return this.x *= t,
            this.y *= t,
            this.z *= t,
            this
        },
        multiplyVectors: function(t, e) {
            return this.x = t.x * e.x,
            this.y = t.y * e.y,
            this.z = t.z * e.z,
            this
        },
        applyEuler: (eo = new V,
        function(t) {
            return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
            this.applyQuaternion(eo.setFromEuler(t))
        }
        ),
        applyAxisAngle: (to = new V,
        function(t, e) {
            return this.applyQuaternion(to.setFromAxisAngle(t, e))
        }
        ),
        applyMatrix3: function(t) {
            var e = this.x
              , n = this.y
              , i = this.z;
            return t = t.elements,
            this.x = t[0] * e + t[3] * n + t[6] * i,
            this.y = t[1] * e + t[4] * n + t[7] * i,
            this.z = t[2] * e + t[5] * n + t[8] * i,
            this
        },
        applyMatrix4: function(t) {
            var e = this.x
              , n = this.y
              , i = this.z
              , r = 1 / ((t = t.elements)[3] * e + t[7] * n + t[11] * i + t[15]);
            return this.x = (t[0] * e + t[4] * n + t[8] * i + t[12]) * r,
            this.y = (t[1] * e + t[5] * n + t[9] * i + t[13]) * r,
            this.z = (t[2] * e + t[6] * n + t[10] * i + t[14]) * r,
            this
        },
        applyQuaternion: function(t) {
            var e = this.x
              , n = this.y
              , i = this.z
              , r = t.x
              , o = t.y
              , a = t.z
              , s = (t = t.w) * e + o * i - a * n
              , c = t * n + a * e - r * i
              , h = t * i + r * n - o * e;
            return this.x = s * t + (e = -r * e - o * n - a * i) * -r + c * -a - h * -o,
            this.y = c * t + e * -o + h * -r - s * -a,
            this.z = h * t + e * -a + s * -o - c * -r,
            this
        },
        project: ($r = new _t,
        function(t) {
            return $r.multiplyMatrices(t.projectionMatrix, $r.getInverse(t.matrixWorld)),
            this.applyMatrix4($r)
        }
        ),
        unproject: (Kr = new _t,
        function(t) {
            return Kr.multiplyMatrices(t.matrixWorld, Kr.getInverse(t.projectionMatrix)),
            this.applyMatrix4(Kr)
        }
        ),
        transformDirection: function(t) {
            var e = this.x
              , n = this.y
              , i = this.z;
            return t = t.elements,
            this.x = t[0] * e + t[4] * n + t[8] * i,
            this.y = t[1] * e + t[5] * n + t[9] * i,
            this.z = t[2] * e + t[6] * n + t[10] * i,
            this.normalize()
        },
        divide: function(t) {
            return this.x /= t.x,
            this.y /= t.y,
            this.z /= t.z,
            this
        },
        divideScalar: function(t) {
            return this.multiplyScalar(1 / t)
        },
        min: function(t) {
            return this.x = Math.min(this.x, t.x),
            this.y = Math.min(this.y, t.y),
            this.z = Math.min(this.z, t.z),
            this
        },
        max: function(t) {
            return this.x = Math.max(this.x, t.x),
            this.y = Math.max(this.y, t.y),
            this.z = Math.max(this.z, t.z),
            this
        },
        clamp: function(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)),
            this.y = Math.max(t.y, Math.min(e.y, this.y)),
            this.z = Math.max(t.z, Math.min(e.z, this.z)),
            this
        },
        clampScalar: (Jr = new wt,
        Qr = new wt,
        function(t, e) {
            return Jr.set(t, t, t),
            Qr.set(e, e, e),
            this.clamp(Jr, Qr)
        }
        ),
        clampLength: function(t, e) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e,
            this.y += (t.y - this.y) * e,
            this.z += (t.z - this.z) * e,
            this
        },
        lerpVectors: function(t, e, n) {
            return this.subVectors(e, t).multiplyScalar(n).add(t)
        },
        cross: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
            this.crossVectors(t, e)) : this.crossVectors(this, t)
        },
        crossVectors: function(t, e) {
            var n = t.x
              , i = t.y;
            t = t.z;
            var r = e.x
              , o = e.y;
            return e = e.z,
            this.x = i * e - t * o,
            this.y = t * r - n * e,
            this.z = n * o - i * r,
            this
        },
        projectOnVector: function(t) {
            var e = t.dot(this) / t.lengthSq();
            return this.copy(t).multiplyScalar(e)
        },
        projectOnPlane: (Zr = new wt,
        function(t) {
            return Zr.copy(this).projectOnVector(t),
            this.sub(Zr)
        }
        ),
        reflect: (Yr = new wt,
        function(t) {
            return this.sub(Yr.copy(t).multiplyScalar(2 * this.dot(t)))
        }
        ),
        angleTo: function(t) {
            return t = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq()),
            Math.acos(io.clamp(t, -1, 1))
        },
        distanceTo: function(t) {
            return Math.sqrt(this.distanceToSquared(t))
        },
        distanceToSquared: function(t) {
            var e = this.x - t.x
              , n = this.y - t.y;
            return e * e + n * n + (t = this.z - t.z) * t
        },
        manhattanDistanceTo: function(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
        },
        setFromSpherical: function(t) {
            var e = Math.sin(t.phi) * t.radius;
            return this.x = e * Math.sin(t.theta),
            this.y = Math.cos(t.phi) * t.radius,
            this.z = e * Math.cos(t.theta),
            this
        },
        setFromCylindrical: function(t) {
            return this.x = t.radius * Math.sin(t.theta),
            this.y = t.y,
            this.z = t.radius * Math.cos(t.theta),
            this
        },
        setFromMatrixPosition: function(t) {
            return t = t.elements,
            this.x = t[12],
            this.y = t[13],
            this.z = t[14],
            this
        },
        setFromMatrixScale: function(t) {
            var e = this.setFromMatrixColumn(t, 0).length()
              , n = this.setFromMatrixColumn(t, 1).length();
            return t = this.setFromMatrixColumn(t, 2).length(),
            this.x = e,
            this.y = n,
            this.z = t,
            this
        },
        setFromMatrixColumn: function(t, e) {
            return this.fromArray(t.elements, 4 * e)
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z
        },
        fromArray: function(t, e) {
            return this.x = t[e = void 0 === e ? 0 : e],
            this.y = t[e + 1],
            this.z = t[e + 2],
            this
        },
        toArray: function(t, e) {
            return (t = void 0 === t ? [] : t)[e = void 0 === e ? 0 : e] = this.x,
            t[e + 1] = this.y,
            t[e + 2] = this.z,
            t
        },
        fromBufferAttribute: function(t, e, n) {
            return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),
            this.x = t.getX(e),
            this.y = t.getY(e),
            this.z = t.getZ(e),
            this
        }
    }),
    Object.assign(g.prototype, {
        isMatrix3: !0,
        set: function(t, e, n, i, r, o, a, s, c) {
            var h = this.elements;
            return h[0] = t,
            h[1] = i,
            h[2] = a,
            h[3] = e,
            h[4] = r,
            h[5] = s,
            h[6] = n,
            h[7] = o,
            h[8] = c,
            this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
            this
        },
        clone: function() {
            return (new this.constructor).fromArray(this.elements)
        },
        copy: function(t) {
            var e = this.elements;
            return t = t.elements,
            e[0] = t[0],
            e[1] = t[1],
            e[2] = t[2],
            e[3] = t[3],
            e[4] = t[4],
            e[5] = t[5],
            e[6] = t[6],
            e[7] = t[7],
            e[8] = t[8],
            this
        },
        setFromMatrix4: function(t) {
            return t = t.elements,
            this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
            this
        },
        applyToBufferAttribute: (no = new wt,
        function(t) {
            for (var e = 0, n = t.count; e < n; e++)
                no.x = t.getX(e),
                no.y = t.getY(e),
                no.z = t.getZ(e),
                no.applyMatrix3(this),
                t.setXYZ(e, no.x, no.y, no.z);
            return t
        }
        ),
        multiply: function(t) {
            return this.multiplyMatrices(this, t)
        },
        premultiply: function(t) {
            return this.multiplyMatrices(t, this)
        },
        multiplyMatrices: function(t, e) {
            var n = t.elements
              , i = e.elements;
            e = this.elements,
            t = n[0];
            var r = n[3]
              , o = n[6]
              , a = n[1]
              , s = n[4]
              , c = n[7]
              , h = n[2]
              , l = n[5]
              , n = n[8]
              , u = i[0]
              , d = i[3]
              , p = i[6]
              , f = i[1]
              , m = i[4]
              , g = i[7]
              , v = i[2]
              , y = i[5]
              , i = i[8];
            return e[0] = t * u + r * f + o * v,
            e[3] = t * d + r * m + o * y,
            e[6] = t * p + r * g + o * i,
            e[1] = a * u + s * f + c * v,
            e[4] = a * d + s * m + c * y,
            e[7] = a * p + s * g + c * i,
            e[2] = h * u + l * f + n * v,
            e[5] = h * d + l * m + n * y,
            e[8] = h * p + l * g + n * i,
            this
        },
        multiplyScalar: function(t) {
            var e = this.elements;
            return e[0] *= t,
            e[3] *= t,
            e[6] *= t,
            e[1] *= t,
            e[4] *= t,
            e[7] *= t,
            e[2] *= t,
            e[5] *= t,
            e[8] *= t,
            this
        },
        determinant: function() {
            var t = this.elements
              , e = t[0]
              , n = t[1]
              , i = t[2]
              , r = t[3]
              , o = t[4]
              , a = t[5]
              , s = t[6]
              , c = t[7];
            return e * o * (t = t[8]) - e * a * c - n * r * t + n * a * s + i * r * c - i * o * s
        },
        getInverse: function(t, e) {
            t && t.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
            var n = t.elements;
            t = this.elements;
            var i = n[0]
              , r = n[1]
              , o = n[2]
              , a = n[3]
              , s = n[4]
              , c = n[5]
              , h = n[6]
              , l = n[7]
              , u = (n = n[8]) * s - c * l
              , d = c * h - n * a
              , p = l * a - s * h
              , f = i * u + r * d + o * p;
            if (0 != f)
                return t[0] = u * (e = 1 / f),
                t[1] = (o * l - n * r) * e,
                t[2] = (c * r - o * s) * e,
                t[3] = d * e,
                t[4] = (n * i - o * h) * e,
                t[5] = (o * a - c * i) * e,
                t[6] = p * e,
                t[7] = (r * h - l * i) * e,
                t[8] = (s * i - r * a) * e,
                this;
            if (!0 === e)
                throw Error("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");
            return console.warn("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"),
            this.identity()
        },
        transpose: function() {
            var t = this.elements
              , e = t[1];
            return t[1] = t[3],
            t[3] = e,
            e = t[2],
            t[2] = t[6],
            t[6] = e,
            e = t[5],
            t[5] = t[7],
            t[7] = e,
            this
        },
        getNormalMatrix: function(t) {
            return this.setFromMatrix4(t).getInverse(this).transpose()
        },
        transposeIntoArray: function(t) {
            var e = this.elements;
            return t[0] = e[0],
            t[1] = e[3],
            t[2] = e[6],
            t[3] = e[1],
            t[4] = e[4],
            t[5] = e[7],
            t[6] = e[2],
            t[7] = e[5],
            t[8] = e[8],
            this
        },
        setUvTransform: function(t, e, n, i, r, o, a) {
            var s = Math.cos(r);
            r = Math.sin(r),
            this.set(n * s, n * r, -n * (s * o + r * a) + o + t, -i * r, i * s, -i * (-r * o + s * a) + a + e, 0, 0, 1)
        },
        scale: function(t, e) {
            var n = this.elements;
            return n[0] *= t,
            n[3] *= t,
            n[6] *= t,
            n[1] *= e,
            n[4] *= e,
            n[7] *= e,
            this
        },
        rotate: function(t) {
            var e = Math.cos(t);
            t = Math.sin(t);
            var n = this.elements
              , i = n[0]
              , r = n[3]
              , o = n[6]
              , a = n[1]
              , s = n[4]
              , c = n[7];
            return n[0] = e * i + t * a,
            n[3] = e * r + t * s,
            n[6] = e * o + t * c,
            n[1] = -t * i + e * a,
            n[4] = -t * r + e * s,
            n[7] = -t * o + e * c,
            this
        },
        translate: function(t, e) {
            var n = this.elements;
            return n[0] += t * n[2],
            n[3] += t * n[5],
            n[6] += t * n[8],
            n[1] += e * n[2],
            n[4] += e * n[5],
            n[7] += e * n[8],
            this
        },
        equals: function(t) {
            var e = this.elements;
            t = t.elements;
            for (var n = 0; n < 9; n++)
                if (e[n] !== t[n])
                    return !1;
            return !0
        },
        fromArray: function(t, e) {
            void 0 === e && (e = 0);
            for (var n = 0; n < 9; n++)
                this.elements[n] = t[n + e];
            return this
        },
        toArray: function(t, e) {
            var n = this.elements;
            return (t = void 0 === t ? [] : t)[e = void 0 === e ? 0 : e] = n[0],
            t[e + 1] = n[1],
            t[e + 2] = n[2],
            t[e + 3] = n[3],
            t[e + 4] = n[4],
            t[e + 5] = n[5],
            t[e + 6] = n[6],
            t[e + 7] = n[7],
            t[e + 8] = n[8],
            t
        }
    });
    var ro, oo, ao, so, co, ho, lo, uo, po, fo, mo, go, vo, yo, xo, bo, _o, wo, Eo, Mo, To, So, Ao, Ro, Lo, Co, Po, No, Oo, Io, Bo, Uo = 0;
    function Do(t) {
        for (var e = 0, n = t.length - 3; e <= n; e += 3) {
            go.fromArray(t, e);
            var i = yo.x * Math.abs(go.x) + yo.y * Math.abs(go.y) + yo.z * Math.abs(go.z)
              , r = ho.dot(go)
              , o = lo.dot(go)
              , a = uo.dot(go);
            if (Math.max(-Math.max(r, o, a), Math.min(r, o, a)) > i)
                return !1
        }
        return !0
    }
    function Fo(t) {
        var e = t.geometry;
        if (void 0 !== e)
            if (e.isGeometry)
                for (e = e.vertices,
                wo = 0,
                Eo = e.length; wo < Eo; wo++)
                    Mo.copy(e[wo]),
                    Mo.applyMatrix4(t.matrixWorld),
                    _o.expandByPoint(Mo);
            else if (e.isBufferGeometry && void 0 !== (e = e.attributes.position))
                for (wo = 0,
                Eo = e.count; wo < Eo; wo++)
                    Mo.fromBufferAttribute(e, wo).applyMatrix4(t.matrixWorld),
                    _o.expandByPoint(Mo)
    }
    d.DEFAULT_IMAGE = void 0,
    d.DEFAULT_MAPPING = 300,
    d.prototype = Object.assign(Object.create(e.prototype), {
        constructor: d,
        isTexture: !0,
        updateMatrix: function() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.name = t.name,
            this.image = t.image,
            this.mipmaps = t.mipmaps.slice(0),
            this.mapping = t.mapping,
            this.wrapS = t.wrapS,
            this.wrapT = t.wrapT,
            this.magFilter = t.magFilter,
            this.minFilter = t.minFilter,
            this.anisotropy = t.anisotropy,
            this.format = t.format,
            this.type = t.type,
            this.offset.copy(t.offset),
            this.repeat.copy(t.repeat),
            this.center.copy(t.center),
            this.rotation = t.rotation,
            this.matrixAutoUpdate = t.matrixAutoUpdate,
            this.matrix.copy(t.matrix),
            this.generateMipmaps = t.generateMipmaps,
            this.premultiplyAlpha = t.premultiplyAlpha,
            this.flipY = t.flipY,
            this.unpackAlignment = t.unpackAlignment,
            this.encoding = t.encoding,
            this
        },
        toJSON: function(t) {
            var e = void 0 === t || "string" == typeof t;
            if (!e && void 0 !== t.textures[this.uuid])
                return t.textures[this.uuid];
            var n, i, r, o, a, s, c = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY
            };
            return void 0 !== this.image && (void 0 === (n = this.image).uuid && (n.uuid = io.generateUUID()),
            e || void 0 !== t.images[n.uuid] || (i = t.images,
            r = n.uuid,
            o = n.uuid,
            n instanceof HTMLCanvasElement ? a = n : ((a = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")).width = n.width,
            a.height = n.height,
            s = a.getContext("2d"),
            n instanceof ImageData ? s.putImageData(n, 0, 0) : s.drawImage(n, 0, 0, n.width, n.height)),
            a = 2048 < a.width || 2048 < a.height ? a.toDataURL("image/jpeg", .6) : a.toDataURL("image/png"),
            i[r] = {
                uuid: o,
                url: a
            }),
            c.image = n.uuid),
            e || (t.textures[this.uuid] = c),
            c
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        },
        transformUv: function(t) {
            if (300 === this.mapping) {
                if (t.applyMatrix3(this.matrix),
                t.x < 0 || 1 < t.x)
                    switch (this.wrapS) {
                    case 1e3:
                        t.x -= Math.floor(t.x);
                        break;
                    case 1001:
                        t.x = t.x < 0 ? 0 : 1;
                        break;
                    case 1002:
                        t.x = 1 === Math.abs(Math.floor(t.x) % 2) ? Math.ceil(t.x) - t.x : t.x - Math.floor(t.x)
                    }
                if (t.y < 0 || 1 < t.y)
                    switch (this.wrapT) {
                    case 1e3:
                        t.y -= Math.floor(t.y);
                        break;
                    case 1001:
                        t.y = t.y < 0 ? 0 : 1;
                        break;
                    case 1002:
                        t.y = 1 === Math.abs(Math.floor(t.y) % 2) ? Math.ceil(t.y) - t.y : t.y - Math.floor(t.y)
                    }
                this.flipY && (t.y = 1 - t.y)
            }
        }
    }),
    Object.defineProperty(d.prototype, "needsUpdate", {
        set: function(t) {
            !0 === t && this.version++
        }
    }),
    Object.assign(Et.prototype, {
        isVector4: !0,
        set: function(t, e, n, i) {
            return this.x = t,
            this.y = e,
            this.z = n,
            this.w = i,
            this
        },
        setScalar: function(t) {
            return this.w = this.z = this.y = this.x = t,
            this
        },
        setX: function(t) {
            return this.x = t,
            this
        },
        setY: function(t) {
            return this.y = t,
            this
        },
        setZ: function(t) {
            return this.z = t,
            this
        },
        setW: function(t) {
            return this.w = t,
            this
        },
        setComponent: function(t, e) {
            switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            case 2:
                this.z = e;
                break;
            case 3:
                this.w = e;
                break;
            default:
                throw Error("index is out of range: " + t)
            }
            return this
        },
        getComponent: function(t) {
            switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw Error("index is out of range: " + t)
            }
        },
        clone: function() {
            return new this.constructor(this.x,this.y,this.z,this.w)
        },
        copy: function(t) {
            return this.x = t.x,
            this.y = t.y,
            this.z = t.z,
            this.w = void 0 !== t.w ? t.w : 1,
            this
        },
        add: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(t, e)) : (this.x += t.x,
            this.y += t.y,
            this.z += t.z,
            this.w += t.w,
            this)
        },
        addScalar: function(t) {
            return this.x += t,
            this.y += t,
            this.z += t,
            this.w += t,
            this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x,
            this.y = t.y + e.y,
            this.z = t.z + e.z,
            this.w = t.w + e.w,
            this
        },
        addScaledVector: function(t, e) {
            return this.x += t.x * e,
            this.y += t.y * e,
            this.z += t.z * e,
            this.w += t.w * e,
            this
        },
        sub: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(t, e)) : (this.x -= t.x,
            this.y -= t.y,
            this.z -= t.z,
            this.w -= t.w,
            this)
        },
        subScalar: function(t) {
            return this.x -= t,
            this.y -= t,
            this.z -= t,
            this.w -= t,
            this
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x,
            this.y = t.y - e.y,
            this.z = t.z - e.z,
            this.w = t.w - e.w,
            this
        },
        multiplyScalar: function(t) {
            return this.x *= t,
            this.y *= t,
            this.z *= t,
            this.w *= t,
            this
        },
        applyMatrix4: function(t) {
            var e = this.x
              , n = this.y
              , i = this.z
              , r = this.w;
            return t = t.elements,
            this.x = t[0] * e + t[4] * n + t[8] * i + t[12] * r,
            this.y = t[1] * e + t[5] * n + t[9] * i + t[13] * r,
            this.z = t[2] * e + t[6] * n + t[10] * i + t[14] * r,
            this.w = t[3] * e + t[7] * n + t[11] * i + t[15] * r,
            this
        },
        divideScalar: function(t) {
            return this.multiplyScalar(1 / t)
        },
        setAxisAngleFromQuaternion: function(t) {
            this.w = 2 * Math.acos(t.w);
            var e = Math.sqrt(1 - t.w * t.w);
            return e < 1e-4 ? (this.x = 1,
            this.z = this.y = 0) : (this.x = t.x / e,
            this.y = t.y / e,
            this.z = t.z / e),
            this
        },
        setAxisAngleFromRotationMatrix: function(t) {
            var e = (t = t.elements)[0]
              , n = t[4]
              , i = t[8]
              , r = t[1]
              , o = t[5]
              , a = t[9]
              , s = t[2]
              , c = t[6]
              , h = t[10];
            return Math.abs(n - r) < .01 && Math.abs(i - s) < .01 && Math.abs(a - c) < .01 ? Math.abs(n + r) < .1 && Math.abs(i + s) < .1 && Math.abs(a + c) < .1 && Math.abs(e + o + h - 3) < .1 ? this.set(1, 0, 0, 0) : (t = Math.PI,
            h = (h + 1) / 2,
            n = (n + r) / 4,
            i = (i + s) / 4,
            a = (a + c) / 4,
            (o = (o + 1) / 2) < (e = (e + 1) / 2) && h < e ? n = e < .01 ? (c = 0,
            s = .707106781) : (s = n / (c = Math.sqrt(e)),
            i / c) : h < o ? n = o < .01 ? (s = 0,
            c = .707106781) : (c = n / (s = Math.sqrt(o)),
            a / s) : h < .01 ? (s = c = .707106781,
            n = 0) : (c = i / (n = Math.sqrt(h)),
            s = a / n),
            this.set(c, s, n, t)) : (t = Math.sqrt((c - a) * (c - a) + (i - s) * (i - s) + (r - n) * (r - n)),
            Math.abs(t) < .001 && (t = 1),
            this.x = (c - a) / t,
            this.y = (i - s) / t,
            this.z = (r - n) / t,
            this.w = Math.acos((e + o + h - 1) / 2)),
            this
        },
        min: function(t) {
            return this.x = Math.min(this.x, t.x),
            this.y = Math.min(this.y, t.y),
            this.z = Math.min(this.z, t.z),
            this.w = Math.min(this.w, t.w),
            this
        },
        max: function(t) {
            return this.x = Math.max(this.x, t.x),
            this.y = Math.max(this.y, t.y),
            this.z = Math.max(this.z, t.z),
            this.w = Math.max(this.w, t.w),
            this
        },
        clamp: function(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)),
            this.y = Math.max(t.y, Math.min(e.y, this.y)),
            this.z = Math.max(t.z, Math.min(e.z, this.z)),
            this.w = Math.max(t.w, Math.min(e.w, this.w)),
            this
        },
        clampScalar: function(t, e) {
            return void 0 === ro && (ro = new Et,
            oo = new Et),
            ro.set(t, t, t, t),
            oo.set(e, e, e, e),
            this.clamp(ro, oo)
        },
        clampLength: function(t, e) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this.w = Math.floor(this.w),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this.w = Math.ceil(this.w),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this.w = Math.round(this.w),
            this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this.w = -this.w,
            this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e,
            this.y += (t.y - this.y) * e,
            this.z += (t.z - this.z) * e,
            this.w += (t.w - this.w) * e,
            this
        },
        lerpVectors: function(t, e, n) {
            return this.subVectors(e, t).multiplyScalar(n).add(t)
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
        },
        fromArray: function(t, e) {
            return this.x = t[e = void 0 === e ? 0 : e],
            this.y = t[e + 1],
            this.z = t[e + 2],
            this.w = t[e + 3],
            this
        },
        toArray: function(t, e) {
            return (t = void 0 === t ? [] : t)[e = void 0 === e ? 0 : e] = this.x,
            t[e + 1] = this.y,
            t[e + 2] = this.z,
            t[e + 3] = this.w,
            t
        },
        fromBufferAttribute: function(t, e, n) {
            return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),
            this.x = t.getX(e),
            this.y = t.getY(e),
            this.z = t.getZ(e),
            this.w = t.getW(e),
            this
        }
    }),
    S.prototype = Object.assign(Object.create(e.prototype), {
        constructor: S,
        isWebGLRenderTarget: !0,
        setSize: function(t, e) {
            this.width === t && this.height === e || (this.width = t,
            this.height = e,
            this.dispose()),
            this.viewport.set(0, 0, t, e),
            this.scissor.set(0, 0, t, e)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.width = t.width,
            this.height = t.height,
            this.viewport.copy(t.viewport),
            this.texture = t.texture.clone(),
            this.depthBuffer = t.depthBuffer,
            this.stencilBuffer = t.stencilBuffer,
            this.depthTexture = t.depthTexture,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    ((i.prototype = Object.create(S.prototype)).constructor = i).prototype.isWebGLRenderTargetCube = !0,
    ((Mt.prototype = Object.create(d.prototype)).constructor = Mt).prototype.isDataTexture = !0,
    Object.assign(n.prototype, {
        isBox3: !0,
        set: function(t, e) {
            return this.min.copy(t),
            this.max.copy(e),
            this
        },
        setFromArray: function(t) {
            for (var e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = t.length; s < c; s += 3) {
                var h = t[s]
                  , l = t[s + 1]
                  , u = t[s + 2];
                h < e && (e = h),
                l < n && (n = l),
                u < i && (i = u),
                r < h && (r = h),
                o < l && (o = l),
                a < u && (a = u)
            }
            return this.min.set(e, n, i),
            this.max.set(r, o, a),
            this
        },
        setFromBufferAttribute: function(t) {
            for (var e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = t.count; s < c; s++) {
                var h = t.getX(s)
                  , l = t.getY(s)
                  , u = t.getZ(s);
                h < e && (e = h),
                l < n && (n = l),
                u < i && (i = u),
                r < h && (r = h),
                o < l && (o = l),
                a < u && (a = u)
            }
            return this.min.set(e, n, i),
            this.max.set(r, o, a),
            this
        },
        setFromPoints: function(t) {
            this.makeEmpty();
            for (var e = 0, n = t.length; e < n; e++)
                this.expandByPoint(t[e]);
            return this
        },
        setFromCenterAndSize: (To = new wt,
        function(t, e) {
            return e = To.copy(e).multiplyScalar(.5),
            this.min.copy(t).sub(e),
            this.max.copy(t).add(e),
            this
        }
        ),
        setFromObject: function(t) {
            return this.makeEmpty(),
            this.expandByObject(t)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.min.copy(t.min),
            this.max.copy(t.max),
            this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = this.min.z = 1 / 0,
            this.max.x = this.max.y = this.max.z = -1 / 0,
            this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        },
        getCenter: function(t) {
            return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"),
            t = new wt),
            this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(t) {
            return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"),
            t = new wt),
            this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
        },
        expandByPoint: function(t) {
            return this.min.min(t),
            this.max.max(t),
            this
        },
        expandByVector: function(t) {
            return this.min.sub(t),
            this.max.add(t),
            this
        },
        expandByScalar: function(t) {
            return this.min.addScalar(-t),
            this.max.addScalar(t),
            this
        },
        expandByObject: (Mo = new wt,
        function(t) {
            return _o = this,
            t.updateMatrixWorld(!0),
            t.traverse(Fo),
            this
        }
        ),
        containsPoint: function(t) {
            return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
        },
        containsBox: function(t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
        },
        getParameter: function(t, e) {
            return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"),
            e = new wt),
            e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
        },
        intersectsBox: function(t) {
            return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
        },
        intersectsSphere: (bo = new wt,
        function(t) {
            return this.clampPoint(t.center, bo),
            bo.distanceToSquared(t.center) <= t.radius * t.radius
        }
        ),
        intersectsPlane: function(t) {
            var e, n = 0 < t.normal.x ? (e = t.normal.x * this.min.x,
            t.normal.x * this.max.x) : (e = t.normal.x * this.max.x,
            t.normal.x * this.min.x);
            return 0 < t.normal.y ? (e += t.normal.y * this.min.y,
            n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y,
            n += t.normal.y * this.min.y),
            0 < t.normal.z ? (e += t.normal.z * this.min.z,
            n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z,
            n += t.normal.z * this.min.z),
            e <= t.constant && n >= t.constant
        },
        intersectsTriangle: (ho = new wt,
        lo = new wt,
        uo = new wt,
        po = new wt,
        fo = new wt,
        mo = new wt,
        go = new wt,
        vo = new wt,
        yo = new wt,
        xo = new wt,
        function(t) {
            return !this.isEmpty() && (this.getCenter(vo),
            yo.subVectors(this.max, vo),
            ho.subVectors(t.a, vo),
            lo.subVectors(t.b, vo),
            uo.subVectors(t.c, vo),
            po.subVectors(lo, ho),
            fo.subVectors(uo, lo),
            mo.subVectors(ho, uo),
            !!Do(t = [0, -po.z, po.y, 0, -fo.z, fo.y, 0, -mo.z, mo.y, po.z, 0, -po.x, fo.z, 0, -fo.x, mo.z, 0, -mo.x, -po.y, po.x, 0, -fo.y, fo.x, 0, -mo.y, mo.x, 0]) && (!!Do(t = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (xo.crossVectors(po, fo),
            Do(t = [xo.x, xo.y, xo.z]))))
        }
        ),
        clampPoint: function(t, e) {
            return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"),
            e = new wt),
            e.copy(t).clamp(this.min, this.max)
        },
        distanceToPoint: (co = new wt,
        function(t) {
            return co.copy(t).clamp(this.min, this.max).sub(t).length()
        }
        ),
        getBoundingSphere: (so = new wt,
        function(t) {
            return void 0 === t && (console.warn("THREE.Box3: .getBoundingSphere() target is now required"),
            t = new a),
            this.getCenter(t.center),
            t.radius = .5 * this.getSize(so).length(),
            t
        }
        ),
        intersect: function(t) {
            return this.min.max(t.min),
            this.max.min(t.max),
            this.isEmpty() && this.makeEmpty(),
            this
        },
        union: function(t) {
            return this.min.min(t.min),
            this.max.max(t.max),
            this
        },
        applyMatrix4: (ao = [new wt, new wt, new wt, new wt, new wt, new wt, new wt, new wt],
        function(t) {
            return this.isEmpty() || (ao[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
            ao[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
            ao[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
            ao[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
            ao[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
            ao[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
            ao[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
            ao[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
            this.setFromPoints(ao)),
            this
        }
        ),
        translate: function(t) {
            return this.min.add(t),
            this.max.add(t),
            this
        },
        equals: function(t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
        }
    }),
    Object.assign(a.prototype, {
        set: function(t, e) {
            return this.center.copy(t),
            this.radius = e,
            this
        },
        setFromPoints: (So = new n,
        function(t, e) {
            var n = this.center;
            void 0 !== e ? n.copy(e) : So.setFromPoints(t).getCenter(n);
            for (var i = e = 0, r = t.length; i < r; i++)
                e = Math.max(e, n.distanceToSquared(t[i]));
            return this.radius = Math.sqrt(e),
            this
        }
        ),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.center.copy(t.center),
            this.radius = t.radius,
            this
        },
        empty: function() {
            return this.radius <= 0
        },
        containsPoint: function(t) {
            return t.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function(t) {
            return t.distanceTo(this.center) - this.radius
        },
        intersectsSphere: function(t) {
            var e = this.radius + t.radius;
            return t.center.distanceToSquared(this.center) <= e * e
        },
        intersectsBox: function(t) {
            return t.intersectsSphere(this)
        },
        intersectsPlane: function(t) {
            return Math.abs(t.distanceToPoint(this.center)) <= this.radius
        },
        clampPoint: function(t, e) {
            var n = this.center.distanceToSquared(t);
            return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"),
            e = new wt),
            e.copy(t),
            n > this.radius * this.radius && (e.sub(this.center).normalize(),
            e.multiplyScalar(this.radius).add(this.center)),
            e
        },
        getBoundingBox: function(t) {
            return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"),
            t = new n),
            t.set(this.center, this.center),
            t.expandByScalar(this.radius),
            t
        },
        applyMatrix4: function(t) {
            return this.center.applyMatrix4(t),
            this.radius *= t.getMaxScaleOnAxis(),
            this
        },
        translate: function(t) {
            return this.center.add(t),
            this
        },
        equals: function(t) {
            return t.center.equals(this.center) && t.radius === this.radius
        }
    }),
    Object.assign(v.prototype, {
        set: function(t, e) {
            return this.normal.copy(t),
            this.constant = e,
            this
        },
        setComponents: function(t, e, n, i) {
            return this.normal.set(t, e, n),
            this.constant = i,
            this
        },
        setFromNormalAndCoplanarPoint: function(t, e) {
            return this.normal.copy(t),
            this.constant = -e.dot(this.normal),
            this
        },
        setFromCoplanarPoints: (Co = new wt,
        Po = new wt,
        function(t, e, n) {
            return e = Co.subVectors(n, e).cross(Po.subVectors(t, e)).normalize(),
            this.setFromNormalAndCoplanarPoint(e, t),
            this
        }
        ),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.normal.copy(t.normal),
            this.constant = t.constant,
            this
        },
        normalize: function() {
            var t = 1 / this.normal.length();
            return this.normal.multiplyScalar(t),
            this.constant *= t,
            this
        },
        negate: function() {
            return this.constant *= -1,
            this.normal.negate(),
            this
        },
        distanceToPoint: function(t) {
            return this.normal.dot(t) + this.constant
        },
        distanceToSphere: function(t) {
            return this.distanceToPoint(t.center) - t.radius
        },
        projectPoint: function(t, e) {
            return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"),
            e = new wt),
            e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
        },
        intersectLine: (Lo = new wt,
        function(t, e) {
            void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"),
            e = new wt);
            var n = t.delta(Lo)
              , i = this.normal.dot(n);
            if (0 === i) {
                if (0 === this.distanceToPoint(t.start))
                    return e.copy(t.start)
            } else if (!((i = -(t.start.dot(this.normal) + this.constant) / i) < 0 || 1 < i))
                return e.copy(n).multiplyScalar(i).add(t.start)
        }
        ),
        intersectsLine: function(t) {
            var e = this.distanceToPoint(t.start);
            return t = this.distanceToPoint(t.end),
            e < 0 && 0 < t || t < 0 && 0 < e
        },
        intersectsBox: function(t) {
            return t.intersectsPlane(this)
        },
        intersectsSphere: function(t) {
            return t.intersectsPlane(this)
        },
        coplanarPoint: function(t) {
            return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"),
            t = new wt),
            t.copy(this.normal).multiplyScalar(-this.constant)
        },
        applyMatrix4: (Ao = new wt,
        Ro = new g,
        function(t, e) {
            return e = e || Ro.getNormalMatrix(t),
            t = this.coplanarPoint(Ao).applyMatrix4(t),
            e = this.normal.applyMatrix3(e).normalize(),
            this.constant = -t.dot(e),
            this
        }
        ),
        translate: function(t) {
            return this.constant -= t.dot(this.normal),
            this
        },
        equals: function(t) {
            return t.normal.equals(this.normal) && t.constant === this.constant
        }
    }),
    Object.assign(Tt.prototype, {
        set: function(t, e, n, i, r, o) {
            var a = this.planes;
            return a[0].copy(t),
            a[1].copy(e),
            a[2].copy(n),
            a[3].copy(i),
            a[4].copy(r),
            a[5].copy(o),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            for (var e = this.planes, n = 0; n < 6; n++)
                e[n].copy(t.planes[n]);
            return this
        },
        setFromMatrix: function(t) {
            var e = this.planes;
            t = (g = t.elements)[0];
            var n = g[1]
              , i = g[2]
              , r = g[3]
              , o = g[4]
              , a = g[5]
              , s = g[6]
              , c = g[7]
              , h = g[8]
              , l = g[9]
              , u = g[10]
              , d = g[11]
              , p = g[12]
              , f = g[13]
              , m = g[14]
              , g = g[15];
            return e[0].setComponents(r - t, c - o, d - h, g - p).normalize(),
            e[1].setComponents(r + t, c + o, d + h, g + p).normalize(),
            e[2].setComponents(r + n, c + a, d + l, g + f).normalize(),
            e[3].setComponents(r - n, c - a, d - l, g - f).normalize(),
            e[4].setComponents(r - i, c - s, d - u, g - m).normalize(),
            e[5].setComponents(r + i, c + s, d + u, g + m).normalize(),
            this
        },
        intersectsObject: (Bo = new a,
        function(t) {
            var e = t.geometry;
            return null === e.boundingSphere && e.computeBoundingSphere(),
            Bo.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
            this.intersectsSphere(Bo)
        }
        ),
        intersectsSprite: (Io = new a,
        function(t) {
            return Io.center.set(0, 0, 0),
            Io.radius = .7071067811865476,
            Io.applyMatrix4(t.matrixWorld),
            this.intersectsSphere(Io)
        }
        ),
        intersectsSphere: function(t) {
            var e = this.planes
              , n = t.center;
            t = -t.radius;
            for (var i = 0; i < 6; i++)
                if (e[i].distanceToPoint(n) < t)
                    return !1;
            return !0
        },
        intersectsBox: (No = new wt,
        Oo = new wt,
        function(t) {
            for (var e = this.planes, n = 0; n < 6; n++) {
                var i = e[n];
                No.x = (0 < i.normal.x ? t.min : t.max).x,
                Oo.x = (0 < i.normal.x ? t.max : t.min).x,
                No.y = (0 < i.normal.y ? t.min : t.max).y,
                Oo.y = (0 < i.normal.y ? t.max : t.min).y,
                No.z = (0 < i.normal.z ? t.min : t.max).z,
                Oo.z = (0 < i.normal.z ? t.max : t.min).z;
                var r = i.distanceToPoint(No)
                  , i = i.distanceToPoint(Oo);
                if (r < 0 && i < 0)
                    return !1
            }
            return !0
        }
        ),
        containsPoint: function(t) {
            for (var e = this.planes, n = 0; n < 6; n++)
                if (e[n].distanceToPoint(t) < 0)
                    return !1;
            return !0
        }
    });
    var zo, Ho = {
        alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
        alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
        aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
        aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex: "\nvec3 transformed = vec3( position );\n",
        beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n",
        bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n",
        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
        clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n",
        clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
        color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
        color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
        common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n",
        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
        defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n",
        displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
        emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
        emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
        encodings_fragment: "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
        encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n",
        envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
        envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
        envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
        envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
        fog_vertex: "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n",
        fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
        fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
        gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",
        lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
        lights_pars_begin: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n",
        lights_pars_maps: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
        lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
        lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
        lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif\n",
        lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif\n",
        lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
        logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment: "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n",
        logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif",
        logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n",
        map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
        map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
        map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n",
        metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n",
        metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
        normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n",
        normal_fragment_maps: "#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\t\tscale *= float( gl_FrontFacing ) * 2.0 - 1.0;\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n",
        packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
        project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n",
        dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",
        dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",
        roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n",
        roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
        shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
        shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
        shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
        skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
        skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n",
        skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
        tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
        uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
        uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n",
        uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
        uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
        uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n",
        cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
        cube_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n",
        depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
        depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
        distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n",
        distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n",
        equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
        equirect_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
        linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
        meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
        meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
        meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
        meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
        meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
        normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
        points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n",
        shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n"
    }, Go = {
        merge: function(t) {
            for (var e = {}, n = 0; n < t.length; n++) {
                var i, r = this.clone(t[n]);
                for (i in r)
                    e[i] = r[i]
            }
            return e
        },
        clone: function(t) {
            var e, n = {};
            for (e in t)
                for (var i in n[e] = {},
                t[e]) {
                    var r = t[e][i];
                    r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? n[e][i] = r.clone() : Array.isArray(r) ? n[e][i] = r.slice() : n[e][i] = r
                }
            return n
        }
    }, ko = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    };
    function Vo(t, e, n) {
        return n < 0 && (n += 1),
        1 < n && --n,
        n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
    }
    Object.assign(w.prototype, {
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function(t) {
            return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t),
            this
        },
        setScalar: function(t) {
            return this.b = this.g = this.r = t,
            this
        },
        setHex: function(t) {
            return t = Math.floor(t),
            this.r = (t >> 16 & 255) / 255,
            this.g = (t >> 8 & 255) / 255,
            this.b = (255 & t) / 255,
            this
        },
        setRGB: function(t, e, n) {
            return this.r = t,
            this.g = e,
            this.b = n,
            this
        },
        setHSL: function(t, e, n) {
            return t = io.euclideanModulo(t, 1),
            e = io.clamp(e, 0, 1),
            n = io.clamp(n, 0, 1),
            0 === e ? this.r = this.g = this.b = n : (this.r = Vo(n = 2 * n - (e = n <= .5 ? n * (1 + e) : n + e - n * e), e, t + 1 / 3),
            this.g = Vo(n, e, t),
            this.b = Vo(n, e, t - 1 / 3)),
            this
        },
        setStyle: function(e) {
            function t(t) {
                void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
            }
            var n;
            if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
                var i = n[2];
                switch (n[1]) {
                case "rgb":
                case "rgba":
                    if (n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(i))
                        return this.r = Math.min(255, parseInt(n[1], 10)) / 255,
                        this.g = Math.min(255, parseInt(n[2], 10)) / 255,
                        this.b = Math.min(255, parseInt(n[3], 10)) / 255,
                        t(n[5]),
                        this;
                    if (n = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(i))
                        return this.r = Math.min(100, parseInt(n[1], 10)) / 100,
                        this.g = Math.min(100, parseInt(n[2], 10)) / 100,
                        this.b = Math.min(100, parseInt(n[3], 10)) / 100,
                        t(n[5]),
                        this;
                    break;
                case "hsl":
                case "hsla":
                    if (n = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(i)) {
                        var i = parseFloat(n[1]) / 360
                          , r = parseInt(n[2], 10) / 100
                          , o = parseInt(n[3], 10) / 100;
                        return t(n[5]),
                        this.setHSL(i, r, o)
                    }
                }
            } else if (n = /^#([A-Fa-f0-9]+)$/.exec(e)) {
                if (3 === (i = (n = n[1]).length))
                    return this.r = parseInt(n.charAt(0) + n.charAt(0), 16) / 255,
                    this.g = parseInt(n.charAt(1) + n.charAt(1), 16) / 255,
                    this.b = parseInt(n.charAt(2) + n.charAt(2), 16) / 255,
                    this;
                if (6 === i)
                    return this.r = parseInt(n.charAt(0) + n.charAt(1), 16) / 255,
                    this.g = parseInt(n.charAt(2) + n.charAt(3), 16) / 255,
                    this.b = parseInt(n.charAt(4) + n.charAt(5), 16) / 255,
                    this
            }
            return e && 0 < e.length && (void 0 !== (n = ko[e]) ? this.setHex(n) : console.warn("THREE.Color: Unknown color " + e)),
            this
        },
        clone: function() {
            return new this.constructor(this.r,this.g,this.b)
        },
        copy: function(t) {
            return this.r = t.r,
            this.g = t.g,
            this.b = t.b,
            this
        },
        copyGammaToLinear: function(t, e) {
            return void 0 === e && (e = 2),
            this.r = Math.pow(t.r, e),
            this.g = Math.pow(t.g, e),
            this.b = Math.pow(t.b, e),
            this
        },
        copyLinearToGamma: function(t, e) {
            return e = 0 < (e = void 0 === e ? 2 : e) ? 1 / e : 1,
            this.r = Math.pow(t.r, e),
            this.g = Math.pow(t.g, e),
            this.b = Math.pow(t.b, e),
            this
        },
        convertGammaToLinear: function() {
            var t = this.r
              , e = this.g
              , n = this.b;
            return this.r = t * t,
            this.g = e * e,
            this.b = n * n,
            this
        },
        convertLinearToGamma: function() {
            return this.r = Math.sqrt(this.r),
            this.g = Math.sqrt(this.g),
            this.b = Math.sqrt(this.b),
            this
        },
        getHex: function() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        },
        getHexString: function() {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        },
        getHSL: function(t) {
            void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"),
            t = {
                h: 0,
                s: 0,
                l: 0
            });
            var e, n = this.r, i = this.g, r = this.b, o = Math.max(n, i, r), a = ((c = Math.min(n, i, r)) + o) / 2;
            if (c === o)
                c = e = 0;
            else {
                var s = o - c
                  , c = a <= .5 ? s / (o + c) : s / (2 - o - c);
                switch (o) {
                case n:
                    e = (i - r) / s + (i < r ? 6 : 0);
                    break;
                case i:
                    e = (r - n) / s + 2;
                    break;
                case r:
                    e = (n - i) / s + 4
                }
                e /= 6
            }
            return t.h = e,
            t.s = c,
            t.l = a,
            t
        },
        getStyle: function() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        },
        offsetHSL: (zo = {},
        function(t, e, n) {
            return this.getHSL(zo),
            zo.h += t,
            zo.s += e,
            zo.l += n,
            this.setHSL(zo.h, zo.s, zo.l),
            this
        }
        ),
        add: function(t) {
            return this.r += t.r,
            this.g += t.g,
            this.b += t.b,
            this
        },
        addColors: function(t, e) {
            return this.r = t.r + e.r,
            this.g = t.g + e.g,
            this.b = t.b + e.b,
            this
        },
        addScalar: function(t) {
            return this.r += t,
            this.g += t,
            this.b += t,
            this
        },
        sub: function(t) {
            return this.r = Math.max(0, this.r - t.r),
            this.g = Math.max(0, this.g - t.g),
            this.b = Math.max(0, this.b - t.b),
            this
        },
        multiply: function(t) {
            return this.r *= t.r,
            this.g *= t.g,
            this.b *= t.b,
            this
        },
        multiplyScalar: function(t) {
            return this.r *= t,
            this.g *= t,
            this.b *= t,
            this
        },
        lerp: function(t, e) {
            return this.r += (t.r - this.r) * e,
            this.g += (t.g - this.g) * e,
            this.b += (t.b - this.b) * e,
            this
        },
        equals: function(t) {
            return t.r === this.r && t.g === this.g && t.b === this.b
        },
        fromArray: function(t, e) {
            return this.r = t[e = void 0 === e ? 0 : e],
            this.g = t[e + 1],
            this.b = t[e + 2],
            this
        },
        toArray: function(t, e) {
            return (t = void 0 === t ? [] : t)[e = void 0 === e ? 0 : e] = this.r,
            t[e + 1] = this.g,
            t[e + 2] = this.b,
            t
        },
        toJSON: function() {
            return this.getHex()
        }
    });
    var jo, Wo, Xo = {
        common: {
            diffuse: {
                value: new w(15658734)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new g
            },
            alphaMap: {
                value: null
            }
        },
        specularmap: {
            specularMap: {
                value: null
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            refractionRatio: {
                value: .98
            },
            maxMipLevel: {
                value: 0
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: new W(1,1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new w(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: {
                value: []
            },
            spotShadowMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            }
        },
        points: {
            diffuse: {
                value: new w(15658734)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new g
            }
        }
    }, qo = {
        basic: {
            uniforms: Go.merge([Xo.common, Xo.specularmap, Xo.envmap, Xo.aomap, Xo.lightmap, Xo.fog]),
            vertexShader: Ho.meshbasic_vert,
            fragmentShader: Ho.meshbasic_frag
        },
        lambert: {
            uniforms: Go.merge([Xo.common, Xo.specularmap, Xo.envmap, Xo.aomap, Xo.lightmap, Xo.emissivemap, Xo.fog, Xo.lights, {
                emissive: {
                    value: new w(0)
                }
            }]),
            vertexShader: Ho.meshlambert_vert,
            fragmentShader: Ho.meshlambert_frag
        },
        phong: {
            uniforms: Go.merge([Xo.common, Xo.specularmap, Xo.envmap, Xo.aomap, Xo.lightmap, Xo.emissivemap, Xo.bumpmap, Xo.normalmap, Xo.displacementmap, Xo.gradientmap, Xo.fog, Xo.lights, {
                emissive: {
                    value: new w(0)
                },
                specular: {
                    value: new w(1118481)
                },
                shininess: {
                    value: 30
                }
            }]),
            vertexShader: Ho.meshphong_vert,
            fragmentShader: Ho.meshphong_frag
        },
        standard: {
            uniforms: Go.merge([Xo.common, Xo.envmap, Xo.aomap, Xo.lightmap, Xo.emissivemap, Xo.bumpmap, Xo.normalmap, Xo.displacementmap, Xo.roughnessmap, Xo.metalnessmap, Xo.fog, Xo.lights, {
                emissive: {
                    value: new w(0)
                },
                roughness: {
                    value: .5
                },
                metalness: {
                    value: .5
                },
                envMapIntensity: {
                    value: 1
                }
            }]),
            vertexShader: Ho.meshphysical_vert,
            fragmentShader: Ho.meshphysical_frag
        },
        points: {
            uniforms: Go.merge([Xo.points, Xo.fog]),
            vertexShader: Ho.points_vert,
            fragmentShader: Ho.points_frag
        },
        dashed: {
            uniforms: Go.merge([Xo.common, Xo.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }]),
            vertexShader: Ho.linedashed_vert,
            fragmentShader: Ho.linedashed_frag
        },
        depth: {
            uniforms: Go.merge([Xo.common, Xo.displacementmap]),
            vertexShader: Ho.depth_vert,
            fragmentShader: Ho.depth_frag
        },
        normal: {
            uniforms: Go.merge([Xo.common, Xo.bumpmap, Xo.normalmap, Xo.displacementmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: Ho.normal_vert,
            fragmentShader: Ho.normal_frag
        },
        cube: {
            uniforms: {
                tCube: {
                    value: null
                },
                tFlip: {
                    value: -1
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: Ho.cube_vert,
            fragmentShader: Ho.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: Ho.equirect_vert,
            fragmentShader: Ho.equirect_frag
        },
        distanceRGBA: {
            uniforms: Go.merge([Xo.common, Xo.displacementmap, {
                referencePosition: {
                    value: new wt
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1e3
                }
            }]),
            vertexShader: Ho.distanceRGBA_vert,
            fragmentShader: Ho.distanceRGBA_frag
        },
        shadow: {
            uniforms: Go.merge([Xo.lights, Xo.fog, {
                color: {
                    value: new w(0)
                },
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: Ho.shadow_vert,
            fragmentShader: Ho.shadow_frag
        }
    };
    qo.physical = {
        uniforms: Go.merge([qo.standard.uniforms, {
            clearCoat: {
                value: 0
            },
            clearCoatRoughness: {
                value: 0
            }
        }]),
        vertexShader: Ho.meshphysical_vert,
        fragmentShader: Ho.meshphysical_frag
    },
    r.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "),
    r.DefaultOrder = "XYZ",
    Object.defineProperties(r.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(t) {
                this._x = t,
                this.onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(t) {
                this._y = t,
                this.onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(t) {
                this._z = t,
                this.onChangeCallback()
            }
        },
        order: {
            get: function() {
                return this._order
            },
            set: function(t) {
                this._order = t,
                this.onChangeCallback()
            }
        }
    }),
    Object.assign(r.prototype, {
        isEuler: !0,
        set: function(t, e, n, i) {
            return this._x = t,
            this._y = e,
            this._z = n,
            this._order = i || this._order,
            this.onChangeCallback(),
            this
        },
        clone: function() {
            return new this.constructor(this._x,this._y,this._z,this._order)
        },
        copy: function(t) {
            return this._x = t._x,
            this._y = t._y,
            this._z = t._z,
            this._order = t._order,
            this.onChangeCallback(),
            this
        },
        setFromRotationMatrix: function(t, e, n) {
            var i = io.clamp;
            t = (u = t.elements)[0];
            var r = u[4]
              , o = u[8]
              , a = u[1]
              , s = u[5]
              , c = u[9]
              , h = u[2]
              , l = u[6]
              , u = u[10];
            return "XYZ" === (e = e || this._order) ? (this._y = Math.asin(i(o, -1, 1)),
            Math.abs(o) < .99999 ? (this._x = Math.atan2(-c, u),
            this._z = Math.atan2(-r, t)) : (this._x = Math.atan2(l, s),
            this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-i(c, -1, 1)),
            Math.abs(c) < .99999 ? (this._y = Math.atan2(o, u),
            this._z = Math.atan2(a, s)) : (this._y = Math.atan2(-h, t),
            this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(i(l, -1, 1)),
            Math.abs(l) < .99999 ? (this._y = Math.atan2(-h, u),
            this._z = Math.atan2(-r, s)) : (this._y = 0,
            this._z = Math.atan2(a, t))) : "ZYX" === e ? (this._y = Math.asin(-i(h, -1, 1)),
            Math.abs(h) < .99999 ? (this._x = Math.atan2(l, u),
            this._z = Math.atan2(a, t)) : (this._x = 0,
            this._z = Math.atan2(-r, s))) : "YZX" === e ? (this._z = Math.asin(i(a, -1, 1)),
            Math.abs(a) < .99999 ? (this._x = Math.atan2(-c, s),
            this._y = Math.atan2(-h, t)) : (this._x = 0,
            this._y = Math.atan2(o, u))) : "XZY" === e ? (this._z = Math.asin(-i(r, -1, 1)),
            Math.abs(r) < .99999 ? (this._x = Math.atan2(l, s),
            this._y = Math.atan2(o, t)) : (this._x = Math.atan2(-c, u),
            this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e),
            this._order = e,
            !1 !== n && this.onChangeCallback(),
            this
        },
        setFromQuaternion: (Wo = new _t,
        function(t, e, n) {
            return Wo.makeRotationFromQuaternion(t),
            this.setFromRotationMatrix(Wo, e, n)
        }
        ),
        setFromVector3: function(t, e) {
            return this.set(t.x, t.y, t.z, e || this._order)
        },
        reorder: (jo = new V,
        function(t) {
            return jo.setFromEuler(this),
            this.setFromQuaternion(jo, t)
        }
        ),
        equals: function(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
        },
        fromArray: function(t) {
            return this._x = t[0],
            this._y = t[1],
            this._z = t[2],
            void 0 !== t[3] && (this._order = t[3]),
            this.onChangeCallback(),
            this
        },
        toArray: function(t, e) {
            return (t = void 0 === t ? [] : t)[e = void 0 === e ? 0 : e] = this._x,
            t[e + 1] = this._y,
            t[e + 2] = this._z,
            t[e + 3] = this._order,
            t
        },
        toVector3: function(t) {
            return t ? t.set(this._x, this._y, this._z) : new wt(this._x,this._y,this._z)
        },
        onChange: function(t) {
            return this.onChangeCallback = t,
            this
        },
        onChangeCallback: function() {}
    }),
    Object.assign(o.prototype, {
        set: function(t) {
            this.mask = 1 << t | 0
        },
        enable: function(t) {
            this.mask = this.mask | 1 << t | 0
        },
        toggle: function(t) {
            this.mask ^= 1 << t | 0
        },
        disable: function(t) {
            this.mask &= ~(1 << t | 0)
        },
        test: function(t) {
            return 0 != (this.mask & t.mask)
        }
    });
    var Yo, Zo, Jo, Qo, Ko, $o, ta, ea, na, ia, ra, oa, aa, sa, ca, ha, la, ua, da = 0;
    l.DefaultUp = new wt(0,1,0),
    l.DefaultMatrixAutoUpdate = !0,
    l.prototype = Object.assign(Object.create(e.prototype), {
        constructor: l,
        isObject3D: !0,
        onBeforeRender: function() {},
        onAfterRender: function() {},
        applyMatrix: function(t) {
            this.matrix.multiplyMatrices(t, this.matrix),
            this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        applyQuaternion: function(t) {
            return this.quaternion.premultiply(t),
            this
        },
        setRotationFromAxisAngle: function(t, e) {
            this.quaternion.setFromAxisAngle(t, e)
        },
        setRotationFromEuler: function(t) {
            this.quaternion.setFromEuler(t, !0)
        },
        setRotationFromMatrix: function(t) {
            this.quaternion.setFromRotationMatrix(t)
        },
        setRotationFromQuaternion: function(t) {
            this.quaternion.copy(t)
        },
        rotateOnAxis: (la = new V,
        function(t, e) {
            return la.setFromAxisAngle(t, e),
            this.quaternion.multiply(la),
            this
        }
        ),
        rotateOnWorldAxis: (ha = new V,
        function(t, e) {
            return ha.setFromAxisAngle(t, e),
            this.quaternion.premultiply(ha),
            this
        }
        ),
        rotateX: (ca = new wt(1,0,0),
        function(t) {
            return this.rotateOnAxis(ca, t)
        }
        ),
        rotateY: (sa = new wt(0,1,0),
        function(t) {
            return this.rotateOnAxis(sa, t)
        }
        ),
        rotateZ: (aa = new wt(0,0,1),
        function(t) {
            return this.rotateOnAxis(aa, t)
        }
        ),
        translateOnAxis: (oa = new wt,
        function(t, e) {
            return oa.copy(t).applyQuaternion(this.quaternion),
            this.position.add(oa.multiplyScalar(e)),
            this
        }
        ),
        translateX: (ra = new wt(1,0,0),
        function(t) {
            return this.translateOnAxis(ra, t)
        }
        ),
        translateY: (ia = new wt(0,1,0),
        function(t) {
            return this.translateOnAxis(ia, t)
        }
        ),
        translateZ: (na = new wt(0,0,1),
        function(t) {
            return this.translateOnAxis(na, t)
        }
        ),
        localToWorld: function(t) {
            return t.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: (ea = new _t,
        function(t) {
            return t.applyMatrix4(ea.getInverse(this.matrixWorld))
        }
        ),
        lookAt: ($o = new _t,
        ta = new wt,
        function(t, e, n) {
            t.isVector3 ? ta.copy(t) : ta.set(t, e, n),
            this.isCamera ? $o.lookAt(this.position, ta, this.up) : $o.lookAt(ta, this.position, this.up),
            this.quaternion.setFromRotationMatrix($o)
        }
        ),
        add: function(t) {
            if (1 < arguments.length) {
                for (var e = 0; e < arguments.length; e++)
                    this.add(arguments[e]);
                return this
            }
            return t === this ? console.error("THREE.Object3D.add: object can't be added as a child of itself.", t) : t && t.isObject3D ? (null !== t.parent && t.parent.remove(t),
            t.parent = this,
            t.dispatchEvent({
                type: "added"
            }),
            this.children.push(t)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t),
            this
        },
        remove: function(t) {
            if (1 < arguments.length) {
                for (var e = 0; e < arguments.length; e++)
                    this.remove(arguments[e]);
                return this
            }
            return -1 !== (e = this.children.indexOf(t)) && (t.parent = null,
            t.dispatchEvent({
                type: "removed"
            }),
            this.children.splice(e, 1)),
            this
        },
        getObjectById: function(t) {
            return this.getObjectByProperty("id", t)
        },
        getObjectByName: function(t) {
            return this.getObjectByProperty("name", t)
        },
        getObjectByProperty: function(t, e) {
            if (this[t] === e)
                return this;
            for (var n = 0, i = this.children.length; n < i; n++) {
                var r = this.children[n].getObjectByProperty(t, e);
                if (void 0 !== r)
                    return r
            }
        },
        getWorldPosition: function(t) {
            return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"),
            t = new wt),
            this.updateMatrixWorld(!0),
            t.setFromMatrixPosition(this.matrixWorld)
        },
        getWorldQuaternion: (Qo = new wt,
        Ko = new wt,
        function(t) {
            return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),
            t = new V),
            this.updateMatrixWorld(!0),
            this.matrixWorld.decompose(Qo, t, Ko),
            t
        }
        ),
        getWorldScale: (Zo = new wt,
        Jo = new V,
        function(t) {
            return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"),
            t = new wt),
            this.updateMatrixWorld(!0),
            this.matrixWorld.decompose(Zo, Jo, t),
            t
        }
        ),
        getWorldDirection: (Yo = new V,
        function(t) {
            return void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"),
            t = new wt),
            this.getWorldQuaternion(Yo),
            t.set(0, 0, 1).applyQuaternion(Yo)
        }
        ),
        raycast: function() {},
        traverse: function(t) {
            t(this);
            for (var e = this.children, n = 0, i = e.length; n < i; n++)
                e[n].traverse(t)
        },
        traverseVisible: function(t) {
            if (!1 !== this.visible) {
                t(this);
                for (var e = this.children, n = 0, i = e.length; n < i; n++)
                    e[n].traverseVisible(t)
            }
        },
        traverseAncestors: function(t) {
            var e = this.parent;
            null !== e && (t(e),
            e.traverseAncestors(t))
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale),
            this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function(t) {
            this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            t = !(this.matrixWorldNeedsUpdate = !1));
            for (var e = this.children, n = 0, i = e.length; n < i; n++)
                e[n].updateMatrixWorld(t)
        },
        toJSON: function(n) {
            function t(t, e) {
                return void 0 === t[e.uuid] && (t[e.uuid] = e.toJSON(n)),
                e.uuid
            }
            function e(t) {
                var e, n = [];
                for (e in t) {
                    var i = t[e];
                    delete i.metadata,
                    n.push(i)
                }
                return n
            }
            var i = void 0 === n || "string" == typeof n
              , r = {};
            i && (n = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {}
            },
            r.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            var o, a = {};
            if (a.uuid = this.uuid,
            a.type = this.type,
            "" !== this.name && (a.name = this.name),
            !0 === this.castShadow && (a.castShadow = !0),
            !0 === this.receiveShadow && (a.receiveShadow = !0),
            !1 === this.visible && (a.visible = !1),
            !1 === this.frustumCulled && (a.frustumCulled = !1),
            0 !== this.renderOrder && (a.renderOrder = this.renderOrder),
            "{}" !== JSON.stringify(this.userData) && (a.userData = this.userData),
            a.matrix = this.matrix.toArray(),
            !1 === this.matrixAutoUpdate && (a.matrixAutoUpdate = !1),
            void 0 !== this.geometry) {
                a.geometry = t(n.geometries, this.geometry);
                var s = this.geometry.parameters;
                if (void 0 !== s && void 0 !== s.shapes)
                    if (s = s.shapes,
                    Array.isArray(s))
                        for (var c = 0, h = s.length; c < h; c++)
                            t(n.shapes, s[c]);
                    else
                        t(n.shapes, s)
            }
            if (void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    for (s = [],
                    c = 0,
                    h = this.material.length; c < h; c++)
                        s.push(t(n.materials, this.material[c]));
                    a.material = s
                } else
                    a.material = t(n.materials, this.material);
            if (0 < this.children.length)
                for (a.children = [],
                c = 0; c < this.children.length; c++)
                    a.children.push(this.children[c].toJSON(n).object);
            return i && (i = e(n.geometries),
            c = e(n.materials),
            h = e(n.textures),
            o = e(n.images),
            s = e(n.shapes),
            0 < i.length && (r.geometries = i),
            0 < c.length && (r.materials = c),
            0 < h.length && (r.textures = h),
            0 < o.length && (r.images = o),
            0 < s.length && (r.shapes = s)),
            r.object = a,
            r
        },
        clone: function(t) {
            return (new this.constructor).copy(this, t)
        },
        copy: function(t, e) {
            if (void 0 === e && (e = !0),
            this.name = t.name,
            this.up.copy(t.up),
            this.position.copy(t.position),
            this.quaternion.copy(t.quaternion),
            this.scale.copy(t.scale),
            this.matrix.copy(t.matrix),
            this.matrixWorld.copy(t.matrixWorld),
            this.matrixAutoUpdate = t.matrixAutoUpdate,
            this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate,
            this.layers.mask = t.layers.mask,
            this.visible = t.visible,
            this.castShadow = t.castShadow,
            this.receiveShadow = t.receiveShadow,
            this.frustumCulled = t.frustumCulled,
            this.renderOrder = t.renderOrder,
            this.userData = JSON.parse(JSON.stringify(t.userData)),
            !0 === e)
                for (e = 0; e < t.children.length; e++)
                    this.add(t.children[e].clone());
            return this
        }
    }),
    s.prototype = Object.assign(Object.create(l.prototype), {
        constructor: s,
        isCamera: !0,
        copy: function(t, e) {
            return l.prototype.copy.call(this, t, e),
            this.matrixWorldInverse.copy(t.matrixWorldInverse),
            this.projectionMatrix.copy(t.projectionMatrix),
            this
        },
        getWorldDirection: (ua = new V,
        function(t) {
            return void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"),
            t = new wt),
            this.getWorldQuaternion(ua),
            t.set(0, 0, -1).applyQuaternion(ua)
        }
        ),
        updateMatrixWorld: function(t) {
            l.prototype.updateMatrixWorld.call(this, t),
            this.matrixWorldInverse.getInverse(this.matrixWorld)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }),
    p.prototype = Object.assign(Object.create(s.prototype), {
        constructor: p,
        isOrthographicCamera: !0,
        copy: function(t, e) {
            return s.prototype.copy.call(this, t, e),
            this.left = t.left,
            this.right = t.right,
            this.top = t.top,
            this.bottom = t.bottom,
            this.near = t.near,
            this.far = t.far,
            this.zoom = t.zoom,
            this.view = null === t.view ? null : Object.assign({}, t.view),
            this
        },
        setViewOffset: function(t, e, n, i, r, o) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = t,
            this.view.fullHeight = e,
            this.view.offsetX = n,
            this.view.offsetY = i,
            this.view.width = r,
            this.view.height = o,
            this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var t, e = (this.right - this.left) / (2 * this.zoom), n = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2, o = i - e;
            i += e,
            e = r + n,
            n = r - n,
            null !== this.view && this.view.enabled && (i = this.zoom / (this.view.width / this.view.fullWidth),
            n = this.zoom / (this.view.height / this.view.fullHeight),
            t = (this.right - this.left) / this.view.width,
            r = (this.top - this.bottom) / this.view.height,
            i = (o += this.view.offsetX / i * t) + this.view.width / i * t,
            n = (e -= this.view.offsetY / n * r) - this.view.height / n * r),
            this.projectionMatrix.makeOrthographic(o, i, e, n, this.near, this.far)
        },
        toJSON: function(t) {
            return (t = l.prototype.toJSON.call(this, t)).object.zoom = this.zoom,
            t.object.left = this.left,
            t.object.right = this.right,
            t.object.top = this.top,
            t.object.bottom = this.bottom,
            t.object.near = this.near,
            t.object.far = this.far,
            null !== this.view && (t.object.view = Object.assign({}, this.view)),
            t
        }
    }),
    Object.assign(E.prototype, {
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            this.a = t.a,
            this.b = t.b,
            this.c = t.c,
            this.normal.copy(t.normal),
            this.color.copy(t.color),
            this.materialIndex = t.materialIndex;
            for (var e = 0, n = t.vertexNormals.length; e < n; e++)
                this.vertexNormals[e] = t.vertexNormals[e].clone();
            for (e = 0,
            n = t.vertexColors.length; e < n; e++)
                this.vertexColors[e] = t.vertexColors[e].clone();
            return this
        }
    });
    var pa, fa, ma, ga, va, ya, xa, ba = 0;
    M.prototype = Object.assign(Object.create(e.prototype), {
        constructor: M,
        isGeometry: !0,
        applyMatrix: function(t) {
            for (var e = (new g).getNormalMatrix(t), n = 0, i = this.vertices.length; n < i; n++)
                this.vertices[n].applyMatrix4(t);
            for (n = 0,
            i = this.faces.length; n < i; n++) {
                (t = this.faces[n]).normal.applyMatrix3(e).normalize();
                for (var r = 0, o = t.vertexNormals.length; r < o; r++)
                    t.vertexNormals[r].applyMatrix3(e).normalize()
            }
            return null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this.normalsNeedUpdate = this.verticesNeedUpdate = !0,
            this
        },
        rotateX: (xa = new _t,
        function(t) {
            return xa.makeRotationX(t),
            this.applyMatrix(xa),
            this
        }
        ),
        rotateY: (ya = new _t,
        function(t) {
            return ya.makeRotationY(t),
            this.applyMatrix(ya),
            this
        }
        ),
        rotateZ: (va = new _t,
        function(t) {
            return va.makeRotationZ(t),
            this.applyMatrix(va),
            this
        }
        ),
        translate: (ga = new _t,
        function(t, e, n) {
            return ga.makeTranslation(t, e, n),
            this.applyMatrix(ga),
            this
        }
        ),
        scale: (ma = new _t,
        function(t, e, n) {
            return ma.makeScale(t, e, n),
            this.applyMatrix(ma),
            this
        }
        ),
        lookAt: (fa = new l,
        function(t) {
            fa.lookAt(t),
            fa.updateMatrix(),
            this.applyMatrix(fa.matrix)
        }
        ),
        fromBufferGeometry: function(t) {
            function e(t, e, n, i) {
                i = new E(t,e,n,void 0 !== a ? [l[t].clone(), l[e].clone(), l[n].clone()] : [],void 0 !== s ? [r.colors[t].clone(), r.colors[e].clone(), r.colors[n].clone()] : [],i),
                r.faces.push(i),
                void 0 !== c && r.faceVertexUvs[0].push([u[t].clone(), u[e].clone(), u[n].clone()]),
                void 0 !== h && r.faceVertexUvs[1].push([d[t].clone(), d[e].clone(), d[n].clone()])
            }
            var r = this
              , n = null !== t.index ? t.index.array : void 0
              , i = t.attributes
              , o = i.position.array
              , a = void 0 !== i.normal ? i.normal.array : void 0
              , s = void 0 !== i.color ? i.color.array : void 0
              , c = void 0 !== i.uv ? i.uv.array : void 0
              , h = void 0 !== i.uv2 ? i.uv2.array : void 0;
            void 0 !== h && (this.faceVertexUvs[1] = []);
            for (var l = [], u = [], d = [], p = i = 0; i < o.length; i += 3,
            p += 2)
                r.vertices.push(new wt(o[i],o[i + 1],o[i + 2])),
                void 0 !== a && l.push(new wt(a[i],a[i + 1],a[i + 2])),
                void 0 !== s && r.colors.push(new w(s[i],s[i + 1],s[i + 2])),
                void 0 !== c && u.push(new W(c[p],c[p + 1])),
                void 0 !== h && d.push(new W(h[p],h[p + 1]));
            var f = t.groups;
            if (0 < f.length)
                for (i = 0; i < f.length; i++) {
                    var m = (o = f[i]).start
                      , p = m;
                    for (m += o.count; p < m; p += 3)
                        void 0 !== n ? e(n[p], n[p + 1], n[p + 2], o.materialIndex) : e(p, p + 1, p + 2, o.materialIndex)
                }
            else if (void 0 !== n)
                for (i = 0; i < n.length; i += 3)
                    e(n[i], n[i + 1], n[i + 2]);
            else
                for (i = 0; i < o.length / 3; i += 3)
                    e(i, i + 1, i + 2);
            return this.computeFaceNormals(),
            null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
            null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
            this
        },
        center: (pa = new wt,
        function() {
            return this.computeBoundingBox(),
            this.boundingBox.getCenter(pa).negate(),
            this.translate(pa.x, pa.y, pa.z),
            this
        }
        ),
        normalize: function() {
            this.computeBoundingSphere();
            var t = this.boundingSphere.center
              , e = 0 === (e = this.boundingSphere.radius) ? 1 : 1 / e
              , n = new _t;
            return n.set(e, 0, 0, -e * t.x, 0, e, 0, -e * t.y, 0, 0, e, -e * t.z, 0, 0, 0, 1),
            this.applyMatrix(n),
            this
        },
        computeFaceNormals: function() {
            for (var t = new wt, e = new wt, n = 0, i = this.faces.length; n < i; n++) {
                var r = this.faces[n]
                  , o = this.vertices[r.a]
                  , a = this.vertices[r.b];
                t.subVectors(this.vertices[r.c], a),
                e.subVectors(o, a),
                t.cross(e),
                t.normalize(),
                r.normal.copy(t)
            }
        },
        computeVertexNormals: function(t) {
            void 0 === t && (t = !0);
            var e = Array(this.vertices.length)
              , n = 0;
            for (o = this.vertices.length; n < o; n++)
                e[n] = new wt;
            if (t) {
                var i = new wt
                  , r = new wt;
                for (t = 0,
                n = this.faces.length; t < n; t++) {
                    var o = this.faces[t]
                      , a = this.vertices[o.a]
                      , s = this.vertices[o.b]
                      , c = this.vertices[o.c];
                    i.subVectors(c, s),
                    r.subVectors(a, s),
                    i.cross(r),
                    e[o.a].add(i),
                    e[o.b].add(i),
                    e[o.c].add(i)
                }
            } else
                for (this.computeFaceNormals(),
                t = 0,
                n = this.faces.length; t < n; t++)
                    e[(o = this.faces[t]).a].add(o.normal),
                    e[o.b].add(o.normal),
                    e[o.c].add(o.normal);
            for (n = 0,
            o = this.vertices.length; n < o; n++)
                e[n].normalize();
            for (t = 0,
            n = this.faces.length; t < n; t++)
                3 === (a = (o = this.faces[t]).vertexNormals).length ? (a[0].copy(e[o.a]),
                a[1].copy(e[o.b]),
                a[2].copy(e[o.c])) : (a[0] = e[o.a].clone(),
                a[1] = e[o.b].clone(),
                a[2] = e[o.c].clone());
            0 < this.faces.length && (this.normalsNeedUpdate = !0)
        },
        computeFlatVertexNormals: function() {
            this.computeFaceNormals();
            for (var t = 0, e = this.faces.length; t < e; t++) {
                var n = this.faces[t]
                  , i = n.vertexNormals;
                3 === i.length ? (i[0].copy(n.normal),
                i[1].copy(n.normal),
                i[2].copy(n.normal)) : (i[0] = n.normal.clone(),
                i[1] = n.normal.clone(),
                i[2] = n.normal.clone())
            }
            0 < this.faces.length && (this.normalsNeedUpdate = !0)
        },
        computeMorphNormals: function() {
            var t = 0;
            for (a = this.faces.length; t < a; t++) {
                var e = this.faces[t];
                e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone(),
                e.__originalVertexNormals || (e.__originalVertexNormals = []);
                for (var n = 0, i = e.vertexNormals.length; n < i; n++)
                    e.__originalVertexNormals[n] ? e.__originalVertexNormals[n].copy(e.vertexNormals[n]) : e.__originalVertexNormals[n] = e.vertexNormals[n].clone()
            }
            var r = new M;
            for (r.faces = this.faces,
            n = 0,
            i = this.morphTargets.length; n < i; n++) {
                if (!this.morphNormals[n]) {
                    this.morphNormals[n] = {},
                    this.morphNormals[n].faceNormals = [],
                    this.morphNormals[n].vertexNormals = [];
                    for (var e = this.morphNormals[n].faceNormals, o = this.morphNormals[n].vertexNormals, t = 0, a = this.faces.length; t < a; t++) {
                        var s = new wt
                          , c = {
                            a: new wt,
                            b: new wt,
                            c: new wt
                        };
                        e.push(s),
                        o.push(c)
                    }
                }
                for (o = this.morphNormals[n],
                r.vertices = this.morphTargets[n].vertices,
                r.computeFaceNormals(),
                r.computeVertexNormals(),
                t = 0,
                a = this.faces.length; t < a; t++)
                    e = this.faces[t],
                    s = o.faceNormals[t],
                    c = o.vertexNormals[t],
                    s.copy(e.normal),
                    c.a.copy(e.vertexNormals[0]),
                    c.b.copy(e.vertexNormals[1]),
                    c.c.copy(e.vertexNormals[2])
            }
            for (t = 0,
            a = this.faces.length; t < a; t++)
                (e = this.faces[t]).normal = e.__originalFaceNormal,
                e.vertexNormals = e.__originalVertexNormals
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new n),
            this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new a),
            this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function(t, e, n) {
            if (t && t.isGeometry) {
                var i, r = this.vertices.length, o = this.vertices, a = t.vertices, s = this.faces, c = t.faces, h = this.faceVertexUvs[0], l = t.faceVertexUvs[0], u = this.colors, d = t.colors;
                void 0 === n && (n = 0),
                void 0 !== e && (i = (new g).getNormalMatrix(e)),
                t = 0;
                for (var p = a.length; t < p; t++) {
                    var f = a[t].clone();
                    void 0 !== e && f.applyMatrix4(e),
                    o.push(f)
                }
                for (t = 0,
                p = d.length; t < p; t++)
                    u.push(d[t].clone());
                for (t = 0,
                p = c.length; t < p; t++) {
                    var m = (a = c[t]).vertexNormals
                      , d = a.vertexColors;
                    for ((u = new E(a.a + r,a.b + r,a.c + r)).normal.copy(a.normal),
                    void 0 !== i && u.normal.applyMatrix3(i).normalize(),
                    e = 0,
                    o = m.length; e < o; e++)
                        f = m[e].clone(),
                        void 0 !== i && f.applyMatrix3(i).normalize(),
                        u.vertexNormals.push(f);
                    for (u.color.copy(a.color),
                    e = 0,
                    o = d.length; e < o; e++)
                        f = d[e],
                        u.vertexColors.push(f.clone());
                    u.materialIndex = a.materialIndex + n,
                    s.push(u)
                }
                for (t = 0,
                p = l.length; t < p; t++)
                    if (i = [],
                    void 0 !== (n = l[t])) {
                        for (e = 0,
                        o = n.length; e < o; e++)
                            i.push(n[e].clone());
                        h.push(i)
                    }
            } else
                console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t)
        },
        mergeMesh: function(t) {
            t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(),
            this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t)
        },
        mergeVertices: function() {
            for (var t = {}, e = [], n = [], i = Math.pow(10, 4), r = 0, o = this.vertices.length; r < o; r++) {
                var a = this.vertices[r];
                void 0 === t[a = Math.round(a.x * i) + "_" + Math.round(a.y * i) + "_" + Math.round(a.z * i)] ? (t[a] = r,
                e.push(this.vertices[r]),
                n[r] = e.length - 1) : n[r] = n[t[a]]
            }
            for (t = [],
            r = 0,
            o = this.faces.length; r < o; r++)
                for ((i = this.faces[r]).a = n[i.a],
                i.b = n[i.b],
                i.c = n[i.c],
                i = [i.a, i.b, i.c],
                a = 0; a < 3; a++)
                    if (i[a] === i[(a + 1) % 3]) {
                        t.push(r);
                        break
                    }
            for (r = t.length - 1; 0 <= r; r--)
                for (i = t[r],
                this.faces.splice(i, 1),
                n = 0,
                o = this.faceVertexUvs.length; n < o; n++)
                    this.faceVertexUvs[n].splice(i, 1);
            return r = this.vertices.length - e.length,
            this.vertices = e,
            r
        },
        setFromPoints: function(t) {
            this.vertices = [];
            for (var e = 0, n = t.length; e < n; e++) {
                var i = t[e];
                this.vertices.push(new wt(i.x,i.y,i.z || 0))
            }
            return this
        },
        sortFacesByMaterialIndex: function() {
            for (var t = this.faces, e = t.length, n = 0; n < e; n++)
                t[n]._id = n;
            t.sort(function(t, e) {
                return t.materialIndex - e.materialIndex
            });
            var i, r, o = this.faceVertexUvs[0], a = this.faceVertexUvs[1];
            for (o && o.length === e && (i = []),
            a && a.length === e && (r = []),
            n = 0; n < e; n++) {
                var s = t[n]._id;
                i && i.push(o[s]),
                r && r.push(a[s])
            }
            i && (this.faceVertexUvs[0] = i),
            r && (this.faceVertexUvs[1] = r)
        },
        toJSON: function() {
            function t(t, e, n) {
                return n ? t | 1 << e : t & ~(1 << e)
            }
            function e(t) {
                var e = t.x.toString() + t.y.toString() + t.z.toString();
                return void 0 !== c[e] || (c[e] = s.length / 3,
                s.push(t.x, t.y, t.z)),
                c[e]
            }
            function n(t) {
                var e = t.r.toString() + t.g.toString() + t.b.toString();
                return void 0 !== l[e] || (l[e] = h.length,
                h.push(t.getHex())),
                l[e]
            }
            function i(t) {
                var e = t.x.toString() + t.y.toString();
                return void 0 !== d[e] || (d[e] = u.length / 2,
                u.push(t.x, t.y)),
                d[e]
            }
            var r = {
                metadata: {
                    version: 4.5,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            if (r.uuid = this.uuid,
            r.type = this.type,
            "" !== this.name && (r.name = this.name),
            void 0 !== this.parameters) {
                var o = this.parameters;
                for (p in o)
                    void 0 !== o[p] && (r[p] = o[p]);
                return r
            }
            for (o = [],
            p = 0; p < this.vertices.length; p++) {
                var a = this.vertices[p];
                o.push(a.x, a.y, a.z)
            }
            for (var a = [], s = [], c = {}, h = [], l = {}, u = [], d = {}, p = 0; p < this.faces.length; p++) {
                var f, m = this.faces[p], g = void 0 !== this.faceVertexUvs[0][p], v = 0 < m.normal.length(), y = 0 < m.vertexNormals.length, x = 1 !== m.color.r || 1 !== m.color.g || 1 !== m.color.b, b = 0 < m.vertexColors.length;
                f = t(2, 3, g),
                f = t(f, 4, v),
                f = t(f, 5, y),
                f = t(f, 6, x),
                f = t(f, 7, b),
                a.push(f),
                a.push(m.a, m.b, m.c),
                a.push(m.materialIndex),
                g && (g = this.faceVertexUvs[0][p],
                a.push(i(g[0]), i(g[1]), i(g[2]))),
                v && a.push(e(m.normal)),
                y && (v = m.vertexNormals,
                a.push(e(v[0]), e(v[1]), e(v[2]))),
                x && a.push(n(m.color)),
                b && (m = m.vertexColors,
                a.push(n(m[0]), n(m[1]), n(m[2])))
            }
            return r.data = {},
            r.data.vertices = o,
            r.data.normals = s,
            0 < h.length && (r.data.colors = h),
            0 < u.length && (r.data.uvs = [u]),
            r.data.faces = a,
            r
        },
        clone: function() {
            return (new M).copy(this)
        },
        copy: function(t) {
            var e;
            this.vertices = [],
            this.colors = [],
            this.faces = [],
            this.faceVertexUvs = [[]],
            this.morphTargets = [],
            this.morphNormals = [],
            this.skinWeights = [],
            this.skinIndices = [],
            this.lineDistances = [],
            this.boundingSphere = this.boundingBox = null,
            this.name = t.name;
            for (var n = t.vertices, i = 0, r = n.length; i < r; i++)
                this.vertices.push(n[i].clone());
            for (i = 0,
            r = (n = t.colors).length; i < r; i++)
                this.colors.push(n[i].clone());
            for (i = 0,
            r = (n = t.faces).length; i < r; i++)
                this.faces.push(n[i].clone());
            for (i = 0,
            r = t.faceVertexUvs.length; i < r; i++) {
                var o = t.faceVertexUvs[i];
                for (void 0 === this.faceVertexUvs[i] && (this.faceVertexUvs[i] = []),
                n = 0,
                e = o.length; n < e; n++) {
                    for (var a = o[n], s = [], c = 0, h = a.length; c < h; c++)
                        s.push(a[c].clone());
                    this.faceVertexUvs[i].push(s)
                }
            }
            for (i = 0,
            r = (c = t.morphTargets).length; i < r; i++) {
                if ((h = {}).name = c[i].name,
                void 0 !== c[i].vertices)
                    for (h.vertices = [],
                    n = 0,
                    e = c[i].vertices.length; n < e; n++)
                        h.vertices.push(c[i].vertices[n].clone());
                if (void 0 !== c[i].normals)
                    for (h.normals = [],
                    n = 0,
                    e = c[i].normals.length; n < e; n++)
                        h.normals.push(c[i].normals[n].clone());
                this.morphTargets.push(h)
            }
            for (i = 0,
            r = (c = t.morphNormals).length; i < r; i++) {
                if (h = {},
                void 0 !== c[i].vertexNormals)
                    for (h.vertexNormals = [],
                    n = 0,
                    e = c[i].vertexNormals.length; n < e; n++)
                        o = c[i].vertexNormals[n],
                        (a = {}).a = o.a.clone(),
                        a.b = o.b.clone(),
                        a.c = o.c.clone(),
                        h.vertexNormals.push(a);
                if (void 0 !== c[i].faceNormals)
                    for (h.faceNormals = [],
                    n = 0,
                    e = c[i].faceNormals.length; n < e; n++)
                        h.faceNormals.push(c[i].faceNormals[n].clone());
                this.morphNormals.push(h)
            }
            for (i = 0,
            r = (n = t.skinWeights).length; i < r; i++)
                this.skinWeights.push(n[i].clone());
            for (i = 0,
            r = (n = t.skinIndices).length; i < r; i++)
                this.skinIndices.push(n[i].clone());
            for (i = 0,
            r = (n = t.lineDistances).length; i < r; i++)
                this.lineDistances.push(n[i]);
            return null !== (i = t.boundingBox) && (this.boundingBox = i.clone()),
            null !== (i = t.boundingSphere) && (this.boundingSphere = i.clone()),
            this.elementsNeedUpdate = t.elementsNeedUpdate,
            this.verticesNeedUpdate = t.verticesNeedUpdate,
            this.uvsNeedUpdate = t.uvsNeedUpdate,
            this.normalsNeedUpdate = t.normalsNeedUpdate,
            this.colorsNeedUpdate = t.colorsNeedUpdate,
            this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate,
            this.groupsNeedUpdate = t.groupsNeedUpdate,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    Object.defineProperty(y.prototype, "needsUpdate", {
        set: function(t) {
            !0 === t && this.version++
        }
    }),
    Object.assign(y.prototype, {
        isBufferAttribute: !0,
        onUploadCallback: function() {},
        setArray: function(t) {
            if (Array.isArray(t))
                throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            return this.count = void 0 !== t ? t.length / this.itemSize : 0,
            this.array = t,
            this
        },
        setDynamic: function(t) {
            return this.dynamic = t,
            this
        },
        copy: function(t) {
            return this.name = t.name,
            this.array = new t.array.constructor(t.array),
            this.itemSize = t.itemSize,
            this.count = t.count,
            this.normalized = t.normalized,
            this.dynamic = t.dynamic,
            this
        },
        copyAt: function(t, e, n) {
            t *= this.itemSize,
            n *= e.itemSize;
            for (var i = 0, r = this.itemSize; i < r; i++)
                this.array[t + i] = e.array[n + i];
            return this
        },
        copyArray: function(t) {
            return this.array.set(t),
            this
        },
        copyColorsArray: function(t) {
            for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                var o = t[i];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i),
                o = new w),
                e[n++] = o.r,
                e[n++] = o.g,
                e[n++] = o.b
            }
            return this
        },
        copyVector2sArray: function(t) {
            for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                var o = t[i];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i),
                o = new W),
                e[n++] = o.x,
                e[n++] = o.y
            }
            return this
        },
        copyVector3sArray: function(t) {
            for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                var o = t[i];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i),
                o = new wt),
                e[n++] = o.x,
                e[n++] = o.y,
                e[n++] = o.z
            }
            return this
        },
        copyVector4sArray: function(t) {
            for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                var o = t[i];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i),
                o = new Et),
                e[n++] = o.x,
                e[n++] = o.y,
                e[n++] = o.z,
                e[n++] = o.w
            }
            return this
        },
        set: function(t, e) {
            return this.array.set(t, e = void 0 === e ? 0 : e),
            this
        },
        getX: function(t) {
            return this.array[t * this.itemSize]
        },
        setX: function(t, e) {
            return this.array[t * this.itemSize] = e,
            this
        },
        getY: function(t) {
            return this.array[t * this.itemSize + 1]
        },
        setY: function(t, e) {
            return this.array[t * this.itemSize + 1] = e,
            this
        },
        getZ: function(t) {
            return this.array[t * this.itemSize + 2]
        },
        setZ: function(t, e) {
            return this.array[t * this.itemSize + 2] = e,
            this
        },
        getW: function(t) {
            return this.array[t * this.itemSize + 3]
        },
        setW: function(t, e) {
            return this.array[t * this.itemSize + 3] = e,
            this
        },
        setXY: function(t, e, n) {
            return t *= this.itemSize,
            this.array[t + 0] = e,
            this.array[t + 1] = n,
            this
        },
        setXYZ: function(t, e, n, i) {
            return t *= this.itemSize,
            this.array[t + 0] = e,
            this.array[t + 1] = n,
            this.array[t + 2] = i,
            this
        },
        setXYZW: function(t, e, n, i, r) {
            return t *= this.itemSize,
            this.array[t + 0] = e,
            this.array[t + 1] = n,
            this.array[t + 2] = i,
            this.array[t + 3] = r,
            this
        },
        onUpload: function(t) {
            return this.onUploadCallback = t,
            this
        },
        clone: function() {
            return new this.constructor(this.array,this.itemSize).copy(this)
        }
    }),
    (c.prototype = Object.create(y.prototype)).constructor = c,
    (h.prototype = Object.create(y.prototype)).constructor = h,
    (u.prototype = Object.create(y.prototype)).constructor = u,
    (f.prototype = Object.create(y.prototype)).constructor = f,
    m.prototype = Object.create(y.prototype),
    m.prototype.constructor = m,
    (x.prototype = Object.create(y.prototype)).constructor = x,
    b.prototype = Object.create(y.prototype),
    b.prototype.constructor = b,
    (L.prototype = Object.create(y.prototype)).constructor = L,
    (_.prototype = Object.create(y.prototype)).constructor = _,
    Object.assign(T.prototype, {
        computeGroups: function(t) {
            var e = []
              , n = void 0;
            t = t.faces;
            for (var i = 0; i < t.length; i++) {
                var r, o = t[i];
                o.materialIndex !== n && (n = o.materialIndex,
                void 0 !== r && (r.count = 3 * i - r.start,
                e.push(r)),
                r = {
                    start: 3 * i,
                    materialIndex: n
                })
            }
            void 0 !== r && (r.count = 3 * i - r.start,
            e.push(r)),
            this.groups = e
        },
        fromGeometry: function(t) {
            var e = t.faces
              , n = t.vertices
              , i = t.faceVertexUvs
              , r = i[0] && 0 < i[0].length
              , o = i[1] && 0 < i[1].length
              , a = t.morphTargets
              , s = a.length;
            if (0 < s) {
                for (var c = [], h = 0; h < s; h++)
                    c[h] = [];
                this.morphTargets.position = c
            }
            var l = t.morphNormals
              , u = l.length;
            if (0 < u) {
                for (var d = [], h = 0; h < u; h++)
                    d[h] = [];
                this.morphTargets.normal = d
            }
            var p = t.skinIndices
              , f = t.skinWeights
              , m = p.length === n.length
              , g = f.length === n.length;
            for (h = 0; h < e.length; h++) {
                var v = e[h];
                this.vertices.push(n[v.a], n[v.b], n[v.c]);
                var y = v.vertexNormals;
                for (3 === y.length ? this.normals.push(y[0], y[1], y[2]) : (y = v.normal,
                this.normals.push(y, y, y)),
                3 === (y = v.vertexColors).length ? this.colors.push(y[0], y[1], y[2]) : (y = v.color,
                this.colors.push(y, y, y)),
                !0 === r && (void 0 !== (y = i[0][h]) ? this.uvs.push(y[0], y[1], y[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", h),
                this.uvs.push(new W, new W, new W))),
                !0 === o && (void 0 !== (y = i[1][h]) ? this.uvs2.push(y[0], y[1], y[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", h),
                this.uvs2.push(new W, new W, new W))),
                y = 0; y < s; y++) {
                    var x = a[y].vertices;
                    c[y].push(x[v.a], x[v.b], x[v.c])
                }
                for (y = 0; y < u; y++)
                    x = l[y].vertexNormals[h],
                    d[y].push(x.a, x.b, x.c);
                m && this.skinIndices.push(p[v.a], p[v.b], p[v.c]),
                g && this.skinWeights.push(f[v.a], f[v.b], f[v.c])
            }
            return this.computeGroups(t),
            this.verticesNeedUpdate = t.verticesNeedUpdate,
            this.normalsNeedUpdate = t.normalsNeedUpdate,
            this.colorsNeedUpdate = t.colorsNeedUpdate,
            this.uvsNeedUpdate = t.uvsNeedUpdate,
            this.groupsNeedUpdate = t.groupsNeedUpdate,
            this
        }
    });
    var _a, wa, Ea, Ma, Ta, Sa, Aa, Ra, La, Ca, Pa = 1;
    C.prototype = Object.assign(Object.create(e.prototype), {
        constructor: C,
        isBufferGeometry: !0,
        getIndex: function() {
            return this.index
        },
        setIndex: function(t) {
            Array.isArray(t) ? this.index = new (65535 < A(t) ? b : m)(t,1) : this.index = t
        },
        addAttribute: function(t, e, n) {
            if (e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute) {
                if ("index" !== t)
                    return this.attributes[t] = e,
                    this;
                console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
                this.setIndex(e)
            } else
                console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
                this.addAttribute(t, new y(e,n))
        },
        getAttribute: function(t) {
            return this.attributes[t]
        },
        removeAttribute: function(t) {
            return delete this.attributes[t],
            this
        },
        addGroup: function(t, e, n) {
            this.groups.push({
                start: t,
                count: e,
                materialIndex: void 0 !== n ? n : 0
            })
        },
        clearGroups: function() {
            this.groups = []
        },
        setDrawRange: function(t, e) {
            this.drawRange.start = t,
            this.drawRange.count = e
        },
        applyMatrix: function(t) {
            var e = this.attributes.position;
            return void 0 !== e && (t.applyToBufferAttribute(e),
            e.needsUpdate = !0),
            void 0 !== (e = this.attributes.normal) && ((new g).getNormalMatrix(t).applyToBufferAttribute(e),
            e.needsUpdate = !0),
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
        },
        rotateX: (Ca = new _t,
        function(t) {
            return Ca.makeRotationX(t),
            this.applyMatrix(Ca),
            this
        }
        ),
        rotateY: (La = new _t,
        function(t) {
            return La.makeRotationY(t),
            this.applyMatrix(La),
            this
        }
        ),
        rotateZ: (Ra = new _t,
        function(t) {
            return Ra.makeRotationZ(t),
            this.applyMatrix(Ra),
            this
        }
        ),
        translate: (Aa = new _t,
        function(t, e, n) {
            return Aa.makeTranslation(t, e, n),
            this.applyMatrix(Aa),
            this
        }
        ),
        scale: (Sa = new _t,
        function(t, e, n) {
            return Sa.makeScale(t, e, n),
            this.applyMatrix(Sa),
            this
        }
        ),
        lookAt: (Ta = new l,
        function(t) {
            Ta.lookAt(t),
            Ta.updateMatrix(),
            this.applyMatrix(Ta.matrix)
        }
        ),
        center: (Ma = new wt,
        function() {
            return this.computeBoundingBox(),
            this.boundingBox.getCenter(Ma).negate(),
            this.translate(Ma.x, Ma.y, Ma.z),
            this
        }
        ),
        setFromObject: function(t) {
            var e, n = t.geometry;
            return t.isPoints || t.isLine ? (t = new L(3 * n.vertices.length,3),
            e = new L(3 * n.colors.length,3),
            this.addAttribute("position", t.copyVector3sArray(n.vertices)),
            this.addAttribute("color", e.copyColorsArray(n.colors)),
            n.lineDistances && n.lineDistances.length === n.vertices.length && (t = new L(n.lineDistances.length,1),
            this.addAttribute("lineDistance", t.copyArray(n.lineDistances))),
            null !== n.boundingSphere && (this.boundingSphere = n.boundingSphere.clone()),
            null !== n.boundingBox && (this.boundingBox = n.boundingBox.clone())) : t.isMesh && n && n.isGeometry && this.fromGeometry(n),
            this
        },
        setFromPoints: function(t) {
            for (var e = [], n = 0, i = t.length; n < i; n++) {
                var r = t[n];
                e.push(r.x, r.y, r.z || 0)
            }
            return this.addAttribute("position", new L(e,3)),
            this
        },
        updateFromObject: function(t) {
            var e = t.geometry;
            if (t.isMesh) {
                var n = e.__directGeometry;
                if (!0 === e.elementsNeedUpdate && (n = void 0,
                e.elementsNeedUpdate = !1),
                void 0 === n)
                    return this.fromGeometry(e);
                n.verticesNeedUpdate = e.verticesNeedUpdate,
                n.normalsNeedUpdate = e.normalsNeedUpdate,
                n.colorsNeedUpdate = e.colorsNeedUpdate,
                n.uvsNeedUpdate = e.uvsNeedUpdate,
                n.groupsNeedUpdate = e.groupsNeedUpdate,
                e.verticesNeedUpdate = !1,
                e.normalsNeedUpdate = !1,
                e.colorsNeedUpdate = !1,
                e.uvsNeedUpdate = !1,
                e.groupsNeedUpdate = !1,
                e = n
            }
            return !0 === e.verticesNeedUpdate && (void 0 !== (n = this.attributes.position) && (n.copyVector3sArray(e.vertices),
            n.needsUpdate = !0),
            e.verticesNeedUpdate = !1),
            !0 === e.normalsNeedUpdate && (void 0 !== (n = this.attributes.normal) && (n.copyVector3sArray(e.normals),
            n.needsUpdate = !0),
            e.normalsNeedUpdate = !1),
            !0 === e.colorsNeedUpdate && (void 0 !== (n = this.attributes.color) && (n.copyColorsArray(e.colors),
            n.needsUpdate = !0),
            e.colorsNeedUpdate = !1),
            e.uvsNeedUpdate && (void 0 !== (n = this.attributes.uv) && (n.copyVector2sArray(e.uvs),
            n.needsUpdate = !0),
            e.uvsNeedUpdate = !1),
            e.lineDistancesNeedUpdate && (void 0 !== (n = this.attributes.lineDistance) && (n.copyArray(e.lineDistances),
            n.needsUpdate = !0),
            e.lineDistancesNeedUpdate = !1),
            e.groupsNeedUpdate && (e.computeGroups(t.geometry),
            this.groups = e.groups,
            e.groupsNeedUpdate = !1),
            this
        },
        fromGeometry: function(t) {
            return t.__directGeometry = (new T).fromGeometry(t),
            this.fromDirectGeometry(t.__directGeometry)
        },
        fromDirectGeometry: function(t) {
            var e, n = new Float32Array(3 * t.vertices.length);
            for (e in this.addAttribute("position", new y(n,3).copyVector3sArray(t.vertices)),
            0 < t.normals.length && (n = new Float32Array(3 * t.normals.length),
            this.addAttribute("normal", new y(n,3).copyVector3sArray(t.normals))),
            0 < t.colors.length && (n = new Float32Array(3 * t.colors.length),
            this.addAttribute("color", new y(n,3).copyColorsArray(t.colors))),
            0 < t.uvs.length && (n = new Float32Array(2 * t.uvs.length),
            this.addAttribute("uv", new y(n,2).copyVector2sArray(t.uvs))),
            0 < t.uvs2.length && (n = new Float32Array(2 * t.uvs2.length),
            this.addAttribute("uv2", new y(n,2).copyVector2sArray(t.uvs2))),
            this.groups = t.groups,
            t.morphTargets) {
                for (var n = [], i = t.morphTargets[e], r = 0, o = i.length; r < o; r++) {
                    var a = i[r]
                      , s = new L(3 * a.length,3);
                    n.push(s.copyVector3sArray(a))
                }
                this.morphAttributes[e] = n
            }
            return 0 < t.skinIndices.length && (e = new L(4 * t.skinIndices.length,4),
            this.addAttribute("skinIndex", e.copyVector4sArray(t.skinIndices))),
            0 < t.skinWeights.length && (e = new L(4 * t.skinWeights.length,4),
            this.addAttribute("skinWeight", e.copyVector4sArray(t.skinWeights))),
            null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
            null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
            this
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new n);
            var t = this.attributes.position;
            void 0 !== t ? this.boundingBox.setFromBufferAttribute(t) : this.boundingBox.makeEmpty(),
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        },
        computeBoundingSphere: (wa = new n,
        Ea = new wt,
        function() {
            null === this.boundingSphere && (this.boundingSphere = new a);
            var t = this.attributes.position;
            if (t) {
                var e = this.boundingSphere.center;
                wa.setFromBufferAttribute(t),
                wa.getCenter(e);
                for (var n = 0, i = 0, r = t.count; i < r; i++)
                    Ea.x = t.getX(i),
                    Ea.y = t.getY(i),
                    Ea.z = t.getZ(i),
                    n = Math.max(n, e.distanceToSquared(Ea));
                this.boundingSphere.radius = Math.sqrt(n),
                isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
            }
        }
        ),
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            var t = this.index
              , e = this.attributes
              , n = this.groups;
            if (e.position) {
                var i = e.position.array;
                if (void 0 === e.normal)
                    this.addAttribute("normal", new y(new Float32Array(i.length),3));
                else
                    for (var r = 0, o = (a = e.normal.array).length; r < o; r++)
                        a[r] = 0;
                var a = e.normal.array
                  , s = new wt
                  , c = new wt
                  , h = new wt
                  , l = new wt
                  , u = new wt;
                if (t) {
                    t = t.array,
                    0 === n.length && this.addGroup(0, t.length);
                    for (var d = 0, p = n.length; d < p; ++d) {
                        var o = (r = n[d]).start
                          , f = r.count;
                        for (r = o,
                        o += f; r < o; r += 3) {
                            var f = 3 * t[r + 0]
                              , m = 3 * t[r + 1]
                              , g = 3 * t[r + 2];
                            s.fromArray(i, f),
                            c.fromArray(i, m),
                            h.fromArray(i, g),
                            l.subVectors(h, c),
                            u.subVectors(s, c),
                            l.cross(u),
                            a[f] += l.x,
                            a[1 + f] += l.y,
                            a[2 + f] += l.z,
                            a[m] += l.x,
                            a[1 + m] += l.y,
                            a[2 + m] += l.z,
                            a[g] += l.x,
                            a[1 + g] += l.y,
                            a[2 + g] += l.z
                        }
                    }
                } else
                    for (r = 0,
                    o = i.length; r < o; r += 9)
                        s.fromArray(i, r),
                        c.fromArray(i, r + 3),
                        h.fromArray(i, r + 6),
                        l.subVectors(h, c),
                        u.subVectors(s, c),
                        l.cross(u),
                        a[r] = l.x,
                        a[r + 1] = l.y,
                        a[r + 2] = l.z,
                        a[r + 3] = l.x,
                        a[r + 4] = l.y,
                        a[r + 5] = l.z,
                        a[r + 6] = l.x,
                        a[r + 7] = l.y,
                        a[r + 8] = l.z;
                this.normalizeNormals(),
                e.normal.needsUpdate = !0
            }
        },
        merge: function(t, e) {
            if (t && t.isBufferGeometry) {
                void 0 === e && (e = 0,
                console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                var n, i = this.attributes;
                for (n in i)
                    if (void 0 !== t.attributes[n])
                        for (var r = i[n].array, o = (s = t.attributes[n]).array, a = 0, s = s.itemSize * e; a < o.length; a++,
                        s++)
                            r[s] = o[a];
                return this
            }
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t)
        },
        normalizeNormals: (_a = new wt,
        function() {
            for (var t = this.attributes.normal, e = 0, n = t.count; e < n; e++)
                _a.x = t.getX(e),
                _a.y = t.getY(e),
                _a.z = t.getZ(e),
                _a.normalize(),
                t.setXYZ(e, _a.x, _a.y, _a.z)
        }
        ),
        toNonIndexed: function() {
            if (null === this.index)
                return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),
                this;
            var t, e = new C, n = this.index.array, i = this.attributes;
            for (t in i) {
                for (var r = (c = i[t]).array, o = c.itemSize, a = new r.constructor(n.length * o), s = 0, c = 0, h = n.length; c < h; c++)
                    for (var l = n[c] * o, u = 0; u < o; u++)
                        a[s++] = r[l++];
                e.addAttribute(t, new y(a,o))
            }
            for (c = 0,
            h = (n = this.groups).length; c < h; c++)
                i = n[c],
                e.addGroup(i.start, i.count, i.materialIndex);
            return e
        },
        toJSON: function() {
            var t = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (t.uuid = this.uuid,
            t.type = this.type,
            "" !== this.name && (t.name = this.name),
            void 0 !== this.parameters) {
                var e = this.parameters;
                for (r in e)
                    void 0 !== e[r] && (t[r] = e[r]);
                return t
            }
            t.data = {
                attributes: {}
            };
            var n = this.index;
            for (r in null !== n && (e = Array.prototype.slice.call(n.array),
            t.data.index = {
                type: n.array.constructor.name,
                array: e
            }),
            n = this.attributes) {
                var i = n[r]
                  , e = Array.prototype.slice.call(i.array);
                t.data.attributes[r] = {
                    itemSize: i.itemSize,
                    type: i.array.constructor.name,
                    array: e,
                    normalized: i.normalized
                }
            }
            var r = this.groups;
            return 0 < r.length && (t.data.groups = JSON.parse(JSON.stringify(r))),
            null !== (r = this.boundingSphere) && (t.data.boundingSphere = {
                center: r.center.toArray(),
                radius: r.radius
            }),
            t
        },
        clone: function() {
            return (new C).copy(this)
        },
        copy: function(t) {
            for (a in this.index = null,
            this.attributes = {},
            this.morphAttributes = {},
            this.groups = [],
            this.boundingSphere = this.boundingBox = null,
            this.name = t.name,
            null !== (r = t.index) && this.setIndex(r.clone()),
            r = t.attributes)
                this.addAttribute(a, r[a].clone());
            var e = t.morphAttributes;
            for (a in e) {
                for (var n = [], i = e[a], r = 0, o = i.length; r < o; r++)
                    n.push(i[r].clone());
                this.morphAttributes[a] = n
            }
            var a = t.groups;
            for (r = 0,
            o = a.length; r < o; r++)
                e = a[r],
                this.addGroup(e.start, e.count, e.materialIndex);
            return null !== (a = t.boundingBox) && (this.boundingBox = a.clone()),
            null !== (a = t.boundingSphere) && (this.boundingSphere = a.clone()),
            this.drawRange.start = t.drawRange.start,
            this.drawRange.count = t.drawRange.count,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    (R.prototype = Object.create(M.prototype)).constructor = R,
    (P.prototype = Object.create(C.prototype)).constructor = P,
    (N.prototype = Object.create(M.prototype)).constructor = N,
    (O.prototype = Object.create(C.prototype)).constructor = O;
    var Na, Oa, Ia, Ba, Ua, Da, Fa, za, Ha, Ga, ka, Va, ja, Wa, Xa, qa, Ya, Za, Ja, Qa, Ka, $a, ts, es, ns, is, rs, os, as, ss, cs, hs, ls, us, ds, ps, fs, ms, gs, vs = 0;
    function ys(t, e, n, i, r, o, a) {
        return z.getBarycoord(t, e, n, i, fs),
        r.multiplyScalar(fs.x),
        o.multiplyScalar(fs.y),
        a.multiplyScalar(fs.z),
        r.add(o).add(a),
        r.clone()
    }
    function xs(t, e, n, i, r, o, a, s) {
        return null === (1 === e.side ? i.intersectTriangle(a, o, r, !0, s) : i.intersectTriangle(r, o, a, 2 !== e.side, s)) ? null : (gs.copy(s),
        gs.applyMatrix4(t.matrixWorld),
        (e = n.ray.origin.distanceTo(gs)) < n.near || e > n.far ? null : {
            distance: e,
            point: gs.clone(),
            object: t
        })
    }
    function bs(t, e, n, i, r, o, a, s) {
        return os.fromBufferAttribute(i, o),
        as.fromBufferAttribute(i, a),
        ss.fromBufferAttribute(i, s),
        (t = xs(t, t.material, e, n, os, as, ss, ms)) && (r && (us.fromBufferAttribute(r, o),
        ds.fromBufferAttribute(r, a),
        ps.fromBufferAttribute(r, s),
        t.uv = ys(ms, os, as, ss, us, ds, ps)),
        r = new E(o,a,s),
        z.getNormal(os, as, ss, r.normal),
        t.face = r,
        t.faceIndex = o),
        t
    }
    I.prototype = Object.assign(Object.create(e.prototype), {
        constructor: I,
        isMaterial: !0,
        onBeforeCompile: function() {},
        setValues: function(t) {
            if (void 0 !== t)
                for (var e in t) {
                    var n, i = t[e];
                    void 0 === i ? console.warn("THREE.Material: '" + e + "' parameter is undefined.") : "shading" === e ? (console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                    this.flatShading = 1 === i) : void 0 === (n = this[e]) ? console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.") : n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = "overdraw" === e ? Number(i) : i
                }
        },
        toJSON: function(t) {
            function e(t) {
                var e, n = [];
                for (e in t) {
                    var i = t[e];
                    delete i.metadata,
                    n.push(i)
                }
                return n
            }
            var n = void 0 === t || "string" == typeof t;
            n && (t = {
                textures: {},
                images: {}
            });
            var i = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            return i.uuid = this.uuid,
            i.type = this.type,
            "" !== this.name && (i.name = this.name),
            this.color && this.color.isColor && (i.color = this.color.getHex()),
            void 0 !== this.roughness && (i.roughness = this.roughness),
            void 0 !== this.metalness && (i.metalness = this.metalness),
            this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()),
            1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity),
            this.specular && this.specular.isColor && (i.specular = this.specular.getHex()),
            void 0 !== this.shininess && (i.shininess = this.shininess),
            void 0 !== this.clearCoat && (i.clearCoat = this.clearCoat),
            void 0 !== this.clearCoatRoughness && (i.clearCoatRoughness = this.clearCoatRoughness),
            this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid),
            this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(t).uuid),
            this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(t).uuid),
            this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(t).uuid,
            i.bumpScale = this.bumpScale),
            this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(t).uuid,
            i.normalScale = this.normalScale.toArray()),
            this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(t).uuid,
            i.displacementScale = this.displacementScale,
            i.displacementBias = this.displacementBias),
            this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(t).uuid),
            this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid),
            this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(t).uuid),
            this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid),
            this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(t).uuid,
            i.reflectivity = this.reflectivity),
            this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(t).uuid),
            void 0 !== this.size && (i.size = this.size),
            void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation),
            1 !== this.blending && (i.blending = this.blending),
            !0 === this.flatShading && (i.flatShading = this.flatShading),
            0 !== this.side && (i.side = this.side),
            0 !== this.vertexColors && (i.vertexColors = this.vertexColors),
            this.opacity < 1 && (i.opacity = this.opacity),
            !0 === this.transparent && (i.transparent = this.transparent),
            i.depthFunc = this.depthFunc,
            i.depthTest = this.depthTest,
            i.depthWrite = this.depthWrite,
            0 !== this.rotation && (i.rotation = this.rotation),
            1 !== this.linewidth && (i.linewidth = this.linewidth),
            void 0 !== this.dashSize && (i.dashSize = this.dashSize),
            void 0 !== this.gapSize && (i.gapSize = this.gapSize),
            void 0 !== this.scale && (i.scale = this.scale),
            !0 === this.dithering && (i.dithering = !0),
            0 < this.alphaTest && (i.alphaTest = this.alphaTest),
            !0 === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha),
            !0 === this.wireframe && (i.wireframe = this.wireframe),
            1 < this.wireframeLinewidth && (i.wireframeLinewidth = this.wireframeLinewidth),
            "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap),
            "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.morphTargets && (i.morphTargets = !0),
            !0 === this.skinning && (i.skinning = !0),
            !1 === this.visible && (i.visible = !1),
            "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData),
            n && (n = e(t.textures),
            t = e(t.images),
            0 < n.length && (i.textures = n),
            0 < t.length && (i.images = t)),
            i
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            this.name = t.name,
            this.fog = t.fog,
            this.lights = t.lights,
            this.blending = t.blending,
            this.side = t.side,
            this.flatShading = t.flatShading,
            this.vertexColors = t.vertexColors,
            this.opacity = t.opacity,
            this.transparent = t.transparent,
            this.blendSrc = t.blendSrc,
            this.blendDst = t.blendDst,
            this.blendEquation = t.blendEquation,
            this.blendSrcAlpha = t.blendSrcAlpha,
            this.blendDstAlpha = t.blendDstAlpha,
            this.blendEquationAlpha = t.blendEquationAlpha,
            this.depthFunc = t.depthFunc,
            this.depthTest = t.depthTest,
            this.depthWrite = t.depthWrite,
            this.colorWrite = t.colorWrite,
            this.precision = t.precision,
            this.polygonOffset = t.polygonOffset,
            this.polygonOffsetFactor = t.polygonOffsetFactor,
            this.polygonOffsetUnits = t.polygonOffsetUnits,
            this.dithering = t.dithering,
            this.alphaTest = t.alphaTest,
            this.premultipliedAlpha = t.premultipliedAlpha,
            this.overdraw = t.overdraw,
            this.visible = t.visible,
            this.userData = JSON.parse(JSON.stringify(t.userData)),
            this.clipShadows = t.clipShadows,
            this.clipIntersection = t.clipIntersection;
            var e = t.clippingPlanes
              , n = null;
            if (null !== e)
                for (var i = e.length, n = Array(i), r = 0; r !== i; ++r)
                    n[r] = e[r].clone();
            return this.clippingPlanes = n,
            this.shadowSide = t.shadowSide,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    ((B.prototype = Object.create(I.prototype)).constructor = B).prototype.isMeshBasicMaterial = !0,
    B.prototype.copy = function(t) {
        return I.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.map = t.map,
        this.lightMap = t.lightMap,
        this.lightMapIntensity = t.lightMapIntensity,
        this.aoMap = t.aoMap,
        this.aoMapIntensity = t.aoMapIntensity,
        this.specularMap = t.specularMap,
        this.alphaMap = t.alphaMap,
        this.envMap = t.envMap,
        this.combine = t.combine,
        this.reflectivity = t.reflectivity,
        this.refractionRatio = t.refractionRatio,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.wireframeLinecap = t.wireframeLinecap,
        this.wireframeLinejoin = t.wireframeLinejoin,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this
    }
    ,
    ((U.prototype = Object.create(I.prototype)).constructor = U).prototype.isShaderMaterial = !0,
    U.prototype.copy = function(t) {
        return I.prototype.copy.call(this, t),
        this.fragmentShader = t.fragmentShader,
        this.vertexShader = t.vertexShader,
        this.uniforms = Go.clone(t.uniforms),
        this.defines = Object.assign({}, t.defines),
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.lights = t.lights,
        this.clipping = t.clipping,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this.extensions = t.extensions,
        this
    }
    ,
    U.prototype.toJSON = function(t) {
        return (t = I.prototype.toJSON.call(this, t)).uniforms = this.uniforms,
        t.vertexShader = this.vertexShader,
        t.fragmentShader = this.fragmentShader,
        t
    }
    ,
    Object.assign(D.prototype, {
        set: function(t, e) {
            return this.origin.copy(t),
            this.direction.copy(e),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.origin.copy(t.origin),
            this.direction.copy(t.direction),
            this
        },
        at: function(t, e) {
            return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"),
            e = new wt),
            e.copy(this.direction).multiplyScalar(t).add(this.origin)
        },
        lookAt: function(t) {
            return this.direction.copy(t).sub(this.origin).normalize(),
            this
        },
        recast: (ka = new wt,
        function(t) {
            return this.origin.copy(this.at(t, ka)),
            this
        }
        ),
        closestPointToPoint: function(t, e) {
            return void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"),
            e = new wt),
            e.subVectors(t, this.origin),
            (t = e.dot(this.direction)) < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(t).add(this.origin)
        },
        distanceToPoint: function(t) {
            return Math.sqrt(this.distanceSqToPoint(t))
        },
        distanceSqToPoint: (Ga = new wt,
        function(t) {
            var e = Ga.subVectors(t, this.origin).dot(this.direction);
            return e < 0 ? this.origin.distanceToSquared(t) : (Ga.copy(this.direction).multiplyScalar(e).add(this.origin),
            Ga.distanceToSquared(t))
        }
        ),
        distanceSqToSegment: (Fa = new wt,
        za = new wt,
        Ha = new wt,
        function(t, e, n, i) {
            Fa.copy(t).add(e).multiplyScalar(.5),
            za.copy(e).sub(t).normalize(),
            Ha.copy(this.origin).sub(Fa);
            var r, o = .5 * t.distanceTo(e), a = -this.direction.dot(za), s = Ha.dot(this.direction), c = -Ha.dot(za), h = Ha.lengthSq(), l = Math.abs(1 - a * a);
            return a = 0 < l ? (e = a * s - c,
            r = o * l,
            0 <= (t = a * c - s) ? -r <= e ? e <= r ? (t *= o = 1 / l) * (t + a * (e *= o) + 2 * s) + e * (a * t + e + 2 * c) + h : (e = o,
            -(t = Math.max(0, -(a * e + s))) * t + e * (e + 2 * c) + h) : (e = -o,
            -(t = Math.max(0, -(a * e + s))) * t + e * (e + 2 * c) + h) : e <= -r ? -(t = Math.max(0, -(-a * o + s))) * t + (e = 0 < t ? -o : Math.min(Math.max(-o, -c), o)) * (e + 2 * c) + h : e <= r ? (t = 0,
            (e = Math.min(Math.max(-o, -c), o)) * (e + 2 * c) + h) : -(t = Math.max(0, -(a * o + s))) * t + (e = 0 < t ? o : Math.min(Math.max(-o, -c), o)) * (e + 2 * c) + h) : (e = 0 < a ? -o : o,
            -(t = Math.max(0, -(a * e + s))) * t + e * (e + 2 * c) + h),
            n && n.copy(this.direction).multiplyScalar(t).add(this.origin),
            i && i.copy(za).multiplyScalar(e).add(Fa),
            a
        }
        ),
        intersectSphere: (Da = new wt,
        function(t, e) {
            Da.subVectors(t.center, this.origin);
            var n = Da.dot(this.direction)
              , i = Da.dot(Da) - n * n;
            return (t = t.radius * t.radius) < i ? null : (i = n - (t = Math.sqrt(t - i)),
            n += t,
            i < 0 && n < 0 ? null : i < 0 ? this.at(n, e) : this.at(i, e))
        }
        ),
        intersectsSphere: function(t) {
            return this.distanceToPoint(t.center) <= t.radius
        },
        distanceToPlane: function(t) {
            var e = t.normal.dot(this.direction);
            return 0 === e ? 0 === t.distanceToPoint(this.origin) ? 0 : null : 0 <= (t = -(this.origin.dot(t.normal) + t.constant) / e) ? t : null
        },
        intersectPlane: function(t, e) {
            return null === (t = this.distanceToPlane(t)) ? null : this.at(t, e)
        },
        intersectsPlane: function(t) {
            var e = t.distanceToPoint(this.origin);
            return 0 === e || t.normal.dot(this.direction) * e < 0
        },
        intersectBox: function(t, e) {
            var n, i, r = 1 / this.direction.x, o = 1 / this.direction.y, a = 1 / this.direction.z, s = this.origin;
            return 0 <= r ? (n = (t.min.x - s.x) * r,
            r *= t.max.x - s.x) : (n = (t.max.x - s.x) * r,
            r *= t.min.x - s.x),
            0 <= o ? (i = (t.min.y - s.y) * o,
            o *= t.max.y - s.y) : (i = (t.max.y - s.y) * o,
            o *= t.min.y - s.y),
            o < n || r < i ? null : ((n < i || n != n) && (n = i),
            (o < r || r != r) && (r = o),
            (t = 0 <= a ? (i = (t.min.z - s.z) * a,
            (t.max.z - s.z) * a) : (i = (t.max.z - s.z) * a,
            (t.min.z - s.z) * a)) < n || r < i ? null : ((n < i || n != n) && (n = i),
            (r = t < r || r != r ? t : r) < 0 ? null : this.at(0 <= n ? n : r, e)))
        },
        intersectsBox: (Ua = new wt,
        function(t) {
            return null !== this.intersectBox(t, Ua)
        }
        ),
        intersectTriangle: (Na = new wt,
        Oa = new wt,
        Ia = new wt,
        Ba = new wt,
        function(t, e, n, i, r) {
            if (Oa.subVectors(e, t),
            Ia.subVectors(n, t),
            Ba.crossVectors(Oa, Ia),
            0 < (e = this.direction.dot(Ba))) {
                if (i)
                    return null;
                i = 1
            } else {
                if (!(e < 0))
                    return null;
                i = -1,
                e = -e
            }
            return Na.subVectors(this.origin, t),
            (t = i * this.direction.dot(Ia.crossVectors(Na, Ia))) < 0 || (n = i * this.direction.dot(Oa.cross(Na))) < 0 || e < t + n || (t = -i * Na.dot(Ba)) < 0 ? null : this.at(t / e, r)
        }
        ),
        applyMatrix4: function(t) {
            return this.origin.applyMatrix4(t),
            this.direction.transformDirection(t),
            this
        },
        equals: function(t) {
            return t.origin.equals(this.origin) && t.direction.equals(this.direction)
        }
    }),
    Object.assign(F.prototype, {
        set: function(t, e) {
            return this.start.copy(t),
            this.end.copy(e),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.start.copy(t.start),
            this.end.copy(t.end),
            this
        },
        getCenter: function(t) {
            return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"),
            t = new wt),
            t.addVectors(this.start, this.end).multiplyScalar(.5)
        },
        delta: function(t) {
            return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"),
            t = new wt),
            t.subVectors(this.end, this.start)
        },
        distanceSq: function() {
            return this.start.distanceToSquared(this.end)
        },
        distance: function() {
            return this.start.distanceTo(this.end)
        },
        at: function(t, e) {
            return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"),
            e = new wt),
            this.delta(e).multiplyScalar(t).add(this.start)
        },
        closestPointToPointParameter: (Va = new wt,
        ja = new wt,
        function(t, e) {
            return Va.subVectors(t, this.start),
            ja.subVectors(this.end, this.start),
            t = ja.dot(ja),
            t = ja.dot(Va) / t,
            t = e ? io.clamp(t, 0, 1) : t
        }
        ),
        closestPointToPoint: function(t, e, n) {
            return t = this.closestPointToPointParameter(t, e),
            void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"),
            n = new wt),
            this.delta(n).multiplyScalar(t).add(this.start)
        },
        applyMatrix4: function(t) {
            return this.start.applyMatrix4(t),
            this.end.applyMatrix4(t),
            this
        },
        equals: function(t) {
            return t.start.equals(this.start) && t.end.equals(this.end)
        }
    }),
    Object.assign(z, {
        getNormal: (Za = new wt,
        function(t, e, n, i) {
            return void 0 === i && (console.warn("THREE.Triangle: .getNormal() target is now required"),
            i = new wt),
            i.subVectors(n, e),
            Za.subVectors(t, e),
            i.cross(Za),
            0 < (t = i.lengthSq()) ? i.multiplyScalar(1 / Math.sqrt(t)) : i.set(0, 0, 0)
        }
        ),
        getBarycoord: (Xa = new wt,
        qa = new wt,
        Ya = new wt,
        function(t, e, n, i, r) {
            Xa.subVectors(i, e),
            qa.subVectors(n, e),
            Ya.subVectors(t, e),
            t = Xa.dot(Xa),
            e = Xa.dot(qa),
            n = Xa.dot(Ya);
            var o = qa.dot(qa);
            i = qa.dot(Ya);
            var a = t * o - e * e;
            return void 0 === r && (console.warn("THREE.Triangle: .getBarycoord() target is now required"),
            r = new wt),
            0 == a ? r.set(-2, -1, -1) : r.set(1 - (o = (o * n - e * i) * (a = 1 / a)) - (t = (t * i - e * n) * a), t, o)
        }
        ),
        containsPoint: (Wa = new wt,
        function(t, e, n, i) {
            return z.getBarycoord(t, e, n, i, Wa),
            0 <= Wa.x && 0 <= Wa.y && Wa.x + Wa.y <= 1
        }
        )
    }),
    Object.assign(z.prototype, {
        set: function(t, e, n) {
            return this.a.copy(t),
            this.b.copy(e),
            this.c.copy(n),
            this
        },
        setFromPointsAndIndices: function(t, e, n, i) {
            return this.a.copy(t[e]),
            this.b.copy(t[n]),
            this.c.copy(t[i]),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.a.copy(t.a),
            this.b.copy(t.b),
            this.c.copy(t.c),
            this
        },
        getArea: (ts = new wt,
        es = new wt,
        function() {
            return ts.subVectors(this.c, this.b),
            es.subVectors(this.a, this.b),
            .5 * ts.cross(es).length()
        }
        ),
        getMidpoint: function(t) {
            return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"),
            t = new wt),
            t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        getNormal: function(t) {
            return z.getNormal(this.a, this.b, this.c, t)
        },
        getPlane: function(t) {
            return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"),
            t = new wt),
            t.setFromCoplanarPoints(this.a, this.b, this.c)
        },
        getBarycoord: function(t, e) {
            return z.getBarycoord(t, this.a, this.b, this.c, e)
        },
        containsPoint: function(t) {
            return z.containsPoint(t, this.a, this.b, this.c)
        },
        intersectsBox: function(t) {
            return t.intersectsTriangle(this)
        },
        closestPointToPoint: (Ja = new v,
        Qa = [new F, new F, new F],
        Ka = new wt,
        $a = new wt,
        function(t, e) {
            void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),
            e = new wt);
            var n = 1 / 0;
            if (Ja.setFromCoplanarPoints(this.a, this.b, this.c),
            Ja.projectPoint(t, Ka),
            !0 === this.containsPoint(Ka))
                e.copy(Ka);
            else
                for (Qa[0].set(this.a, this.b),
                Qa[1].set(this.b, this.c),
                Qa[2].set(this.c, this.a),
                t = 0; t < Qa.length; t++) {
                    Qa[t].closestPointToPoint(Ka, !0, $a);
                    var i = Ka.distanceToSquared($a);
                    i < n && (n = i,
                    e.copy($a))
                }
            return e
        }
        ),
        equals: function(t) {
            return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
        }
    }),
    H.prototype = Object.assign(Object.create(l.prototype), {
        constructor: H,
        isMesh: !0,
        setDrawMode: function(t) {
            this.drawMode = t
        },
        copy: function(t) {
            return l.prototype.copy.call(this, t),
            this.drawMode = t.drawMode,
            void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
            void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)),
            this
        },
        updateMorphTargets: function() {
            if ((t = this.geometry).isBufferGeometry) {
                var t = t.morphAttributes
                  , e = Object.keys(t);
                if (0 < e.length) {
                    var n = t[e[0]];
                    if (void 0 !== n)
                        for (this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {},
                        t = 0,
                        e = n.length; t < e; t++) {
                            var i = n[t].name || String(t);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[i] = t
                        }
                }
            } else if (void 0 !== (n = t.morphTargets) && 0 < n.length)
                for (this.morphTargetInfluences = [],
                this.morphTargetDictionary = {},
                t = 0,
                e = n.length; t < e; t++)
                    i = n[t].name || String(t),
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[i] = t
        },
        raycast: (ns = new _t,
        is = new D,
        rs = new a,
        os = new wt,
        as = new wt,
        ss = new wt,
        cs = new wt,
        hs = new wt,
        ls = new wt,
        us = new W,
        ds = new W,
        ps = new W,
        fs = new wt,
        ms = new wt,
        gs = new wt,
        function(t, e) {
            var n = this.geometry
              , i = this.material
              , r = this.matrixWorld;
            if (void 0 !== i && (null === n.boundingSphere && n.computeBoundingSphere(),
            rs.copy(n.boundingSphere),
            rs.applyMatrix4(r),
            !1 !== t.ray.intersectsSphere(rs) && (ns.getInverse(r),
            is.copy(t.ray).applyMatrix4(ns),
            null === n.boundingBox || !1 !== is.intersectsBox(n.boundingBox))))
                if (n.isBufferGeometry) {
                    var o, i = n.index, a = n.attributes.position, n = n.attributes.uv;
                    if (null !== i)
                        for (r = 0,
                        o = i.count; r < o; r += 3) {
                            var s = i.getX(r)
                              , c = i.getX(r + 1)
                              , h = i.getX(r + 2);
                            (d = bs(this, t, is, a, n, s, c, h)) && (d.faceIndex = Math.floor(r / 3),
                            e.push(d))
                        }
                    else if (void 0 !== a)
                        for (r = 0,
                        o = a.count; r < o; r += 3)
                            (d = bs(this, t, is, a, n, s = r, c = r + 1, h = r + 2)) && e.push(d)
                } else if (n.isGeometry) {
                    r = Array.isArray(i),
                    o = n.vertices,
                    s = n.faces,
                    0 < (c = n.faceVertexUvs[0]).length && (a = c);
                    for (var l = 0, u = s.length; l < u; l++) {
                        var d, p = s[l];
                        if (void 0 !== (d = r ? i[p.materialIndex] : i)) {
                            var c = o[p.a]
                              , h = o[p.b]
                              , f = o[p.c];
                            if (!0 === d.morphTargets) {
                                var m = n.morphTargets
                                  , g = this.morphTargetInfluences;
                                os.set(0, 0, 0),
                                as.set(0, 0, 0),
                                ss.set(0, 0, 0);
                                for (var v = 0, y = m.length; v < y; v++) {
                                    var x, b = g[v];
                                    0 !== b && (x = m[v].vertices,
                                    os.addScaledVector(cs.subVectors(x[p.a], c), b),
                                    as.addScaledVector(hs.subVectors(x[p.b], h), b),
                                    ss.addScaledVector(ls.subVectors(x[p.c], f), b))
                                }
                                os.add(c),
                                as.add(h),
                                ss.add(f),
                                c = os,
                                h = as,
                                f = ss
                            }
                            (d = xs(this, d, t, is, c, h, f, ms)) && (a && a[l] && (m = a[l],
                            us.copy(m[0]),
                            ds.copy(m[1]),
                            ps.copy(m[2]),
                            d.uv = ys(ms, c, h, f, us, ds, ps)),
                            d.face = p,
                            d.faceIndex = l,
                            e.push(d))
                        }
                    }
                }
        }
        ),
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    }),
    ((k.prototype = Object.create(d.prototype)).constructor = k).prototype.isCubeTexture = !0,
    Object.defineProperty(k.prototype, "images", {
        get: function() {
            return this.image
        },
        set: function(t) {
            this.image = t
        }
    });
    var _s = new d
      , ws = new k
      , Es = []
      , Ms = []
      , Ts = new Float32Array(16)
      , Ss = new Float32Array(9);
    yt.prototype.setValue = function(t, e) {
        for (var n = this.seq, i = 0, r = n.length; i !== r; ++i) {
            var o = n[i];
            o.setValue(t, e[o.id])
        }
    }
    ;
    var As = /([\w\d_]+)(\])?(\[|\.)?/g;
    Dt.prototype.setValue = function(t, e, n) {
        void 0 !== (e = this.map[e]) && e.setValue(t, n, this.renderer)
    }
    ,
    Dt.prototype.setOptional = function(t, e, n) {
        void 0 !== (e = e[n]) && this.setValue(t, n, e)
    }
    ,
    Dt.upload = function(t, e, n, i) {
        for (var r = 0, o = e.length; r !== o; ++r) {
            var a = e[r]
              , s = n[a.id];
            !1 !== s.needsUpdate && a.setValue(t, s.value, i)
        }
    }
    ,
    Dt.seqWithValue = function(t, e) {
        for (var n = [], i = 0, r = t.length; i !== r; ++i) {
            var o = t[i];
            o.id in e && n.push(o)
        }
        return n
    }
    ;
    var Rs, Ls, Cs, Ps, Ns, Os, Is, Bs, Us, Ds, Fs, zs, Hs, Gs, ks, Vs, js, Ws, Xs = 0, qs = 0;
    ((ee.prototype = Object.create(I.prototype)).constructor = ee).prototype.isMeshDepthMaterial = !0,
    ee.prototype.copy = function(t) {
        return I.prototype.copy.call(this, t),
        this.depthPacking = t.depthPacking,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.map = t.map,
        this.alphaMap = t.alphaMap,
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this
    }
    ,
    ((ne.prototype = Object.create(I.prototype)).constructor = ne).prototype.isMeshDistanceMaterial = !0,
    ne.prototype.copy = function(t) {
        return I.prototype.copy.call(this, t),
        this.referencePosition.copy(t.referencePosition),
        this.nearDistance = t.nearDistance,
        this.farDistance = t.farDistance,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.map = t.map,
        this.alphaMap = t.alphaMap,
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this
    }
    ,
    (re.prototype = Object.create(d.prototype)).constructor = re,
    he.prototype = Object.assign(Object.create(s.prototype), {
        constructor: he,
        isPerspectiveCamera: !0,
        copy: function(t, e) {
            return s.prototype.copy.call(this, t, e),
            this.fov = t.fov,
            this.zoom = t.zoom,
            this.near = t.near,
            this.far = t.far,
            this.focus = t.focus,
            this.aspect = t.aspect,
            this.view = null === t.view ? null : Object.assign({}, t.view),
            this.filmGauge = t.filmGauge,
            this.filmOffset = t.filmOffset,
            this
        },
        setFocalLength: function(t) {
            t = .5 * this.getFilmHeight() / t,
            this.fov = 2 * io.RAD2DEG * Math.atan(t),
            this.updateProjectionMatrix()
        },
        getFocalLength: function() {
            var t = Math.tan(.5 * io.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / t
        },
        getEffectiveFOV: function() {
            return 2 * io.RAD2DEG * Math.atan(Math.tan(.5 * io.DEG2RAD * this.fov) / this.zoom)
        },
        getFilmWidth: function() {
            return this.filmGauge * Math.min(this.aspect, 1)
        },
        getFilmHeight: function() {
            return this.filmGauge / Math.max(this.aspect, 1)
        },
        setViewOffset: function(t, e, n, i, r, o) {
            this.aspect = t / e,
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = t,
            this.view.fullHeight = e,
            this.view.offsetX = n,
            this.view.offsetY = i,
            this.view.width = r,
            this.view.height = o,
            this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var t, e, n = this.near, i = n * Math.tan(.5 * io.DEG2RAD * this.fov) / this.zoom, r = 2 * i, o = this.aspect * r, a = -.5 * o, s = this.view;
            null !== this.view && this.view.enabled && (t = s.fullWidth,
            e = s.fullHeight,
            a += s.offsetX * o / t,
            i -= s.offsetY * r / e,
            o *= s.width / t,
            r *= s.height / e),
            0 !== (s = this.filmOffset) && (a += n * s / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(a, a + o, i, i - r, n, this.far)
        },
        toJSON: function(t) {
            return (t = l.prototype.toJSON.call(this, t)).object.fov = this.fov,
            t.object.zoom = this.zoom,
            t.object.near = this.near,
            t.object.far = this.far,
            t.object.focus = this.focus,
            t.object.aspect = this.aspect,
            null !== this.view && (t.object.view = Object.assign({}, this.view)),
            t.object.filmGauge = this.filmGauge,
            t.object.filmOffset = this.filmOffset,
            t
        }
    }),
    le.prototype = Object.assign(Object.create(he.prototype), {
        constructor: le,
        isArrayCamera: !0
    }),
    pe.prototype.isFogExp2 = !0,
    pe.prototype.clone = function() {
        return new pe(this.color.getHex(),this.density)
    }
    ,
    pe.prototype.toJSON = function() {
        return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
        }
    }
    ,
    fe.prototype.isFog = !0,
    fe.prototype.clone = function() {
        return new fe(this.color.getHex(),this.near,this.far)
    }
    ,
    fe.prototype.toJSON = function() {
        return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        }
    }
    ,
    me.prototype = Object.assign(Object.create(l.prototype), {
        constructor: me,
        copy: function(t, e) {
            return l.prototype.copy.call(this, t, e),
            null !== t.background && (this.background = t.background.clone()),
            null !== t.fog && (this.fog = t.fog.clone()),
            null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()),
            this.autoUpdate = t.autoUpdate,
            this.matrixAutoUpdate = t.matrixAutoUpdate,
            this
        },
        toJSON: function(t) {
            var e = l.prototype.toJSON.call(this, t);
            return null !== this.background && (e.object.background = this.background.toJSON(t)),
            null !== this.fog && (e.object.fog = this.fog.toJSON()),
            e
        }
    }),
    ((ge.prototype = Object.create(I.prototype)).constructor = ge).prototype.isSpriteMaterial = !0,
    ge.prototype.copy = function(t) {
        return I.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.map = t.map,
        this.rotation = t.rotation,
        this
    }
    ,
    ve.prototype = Object.assign(Object.create(l.prototype), {
        constructor: ve,
        isSprite: !0,
        raycast: (Rs = new wt,
        Ls = new wt,
        Cs = new wt,
        function(t, e) {
            Ls.setFromMatrixPosition(this.matrixWorld),
            t.ray.closestPointToPoint(Ls, Rs),
            Cs.setFromMatrixScale(this.matrixWorld);
            var n = Cs.x * Cs.y / 4;
            Ls.distanceToSquared(Rs) > n || ((n = t.ray.origin.distanceTo(Rs)) < t.near || n > t.far || e.push({
                distance: n,
                point: Rs.clone(),
                face: null,
                object: this
            }))
        }
        ),
        clone: function() {
            return new this.constructor(this.material).copy(this)
        },
        copy: function(t) {
            return l.prototype.copy.call(this, t),
            void 0 !== t.center && this.center.copy(t.center),
            this
        }
    }),
    ye.prototype = Object.assign(Object.create(l.prototype), {
        constructor: ye,
        copy: function(t) {
            l.prototype.copy.call(this, t, !1);
            for (var e = 0, n = (t = t.levels).length; e < n; e++) {
                var i = t[e];
                this.addLevel(i.object.clone(), i.distance)
            }
            return this
        },
        addLevel: function(t, e) {
            void 0 === e && (e = 0),
            e = Math.abs(e);
            for (var n = this.levels, i = 0; i < n.length && !(e < n[i].distance); i++)
                ;
            n.splice(i, 0, {
                distance: e,
                object: t
            }),
            this.add(t)
        },
        getObjectForDistance: function(t) {
            for (var e = this.levels, n = 1, i = e.length; n < i && !(t < e[n].distance); n++)
                ;
            return e[n - 1].object
        },
        raycast: (Os = new wt,
        function(t, e) {
            Os.setFromMatrixPosition(this.matrixWorld);
            var n = t.ray.origin.distanceTo(Os);
            this.getObjectForDistance(n).raycast(t, e)
        }
        ),
        update: (Ps = new wt,
        Ns = new wt,
        function(t) {
            var e = this.levels;
            if (1 < e.length) {
                Ps.setFromMatrixPosition(t.matrixWorld),
                Ns.setFromMatrixPosition(this.matrixWorld),
                t = Ps.distanceTo(Ns),
                e[0].object.visible = !0;
                for (var n = 1, i = e.length; n < i && t >= e[n].distance; n++)
                    e[n - 1].object.visible = !1,
                    e[n].object.visible = !0;
                for (; n < i; n++)
                    e[n].object.visible = !1
            }
        }
        ),
        toJSON: function(t) {
            (t = l.prototype.toJSON.call(this, t)).object.levels = [];
            for (var e = this.levels, n = 0, i = e.length; n < i; n++) {
                var r = e[n];
                t.object.levels.push({
                    object: r.object.uuid,
                    distance: r.distance
                })
            }
            return t
        }
    }),
    Object.assign(xe.prototype, {
        calculateInverses: function() {
            this.boneInverses = [];
            for (var t = 0, e = this.bones.length; t < e; t++) {
                var n = new _t;
                this.bones[t] && n.getInverse(this.bones[t].matrixWorld),
                this.boneInverses.push(n)
            }
        },
        pose: function() {
            for (var t, e = 0, n = this.bones.length; e < n; e++)
                (t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]);
            for (e = 0,
            n = this.bones.length; e < n; e++)
                (t = this.bones[e]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld),
                t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld),
                t.matrix.decompose(t.position, t.quaternion, t.scale))
        },
        update: (Is = new _t,
        Bs = new _t,
        function() {
            for (var t = this.bones, e = this.boneInverses, n = this.boneMatrices, i = this.boneTexture, r = 0, o = t.length; r < o; r++)
                Is.multiplyMatrices(t[r] ? t[r].matrixWorld : Bs, e[r]),
                Is.toArray(n, 16 * r);
            void 0 !== i && (i.needsUpdate = !0)
        }
        ),
        clone: function() {
            return new xe(this.bones,this.boneInverses)
        },
        getBoneByName: function(t) {
            for (var e = 0, n = this.bones.length; e < n; e++) {
                var i = this.bones[e];
                if (i.name === t)
                    return i
            }
        }
    }),
    be.prototype = Object.assign(Object.create(l.prototype), {
        constructor: be,
        isBone: !0
    }),
    _e.prototype = Object.assign(Object.create(H.prototype), {
        constructor: _e,
        isSkinnedMesh: !0,
        initBones: function() {
            var t = [];
            if (this.geometry && void 0 !== this.geometry.bones) {
                for (var e = 0, n = this.geometry.bones.length; e < n; e++) {
                    var i = this.geometry.bones[e]
                      , r = new be;
                    t.push(r),
                    r.name = i.name,
                    r.position.fromArray(i.pos),
                    r.quaternion.fromArray(i.rotq),
                    void 0 !== i.scl && r.scale.fromArray(i.scl)
                }
                for (e = 0,
                n = this.geometry.bones.length; e < n; e++)
                    (-1 !== (i = this.geometry.bones[e]).parent && null !== i.parent && void 0 !== t[i.parent] ? t[i.parent] : this).add(t[e])
            }
            return this.updateMatrixWorld(!0),
            t
        },
        bind: function(t, e) {
            this.skeleton = t,
            void 0 === e && (this.updateMatrixWorld(!0),
            this.skeleton.calculateInverses(),
            e = this.matrixWorld),
            this.bindMatrix.copy(e),
            this.bindMatrixInverse.getInverse(e)
        },
        pose: function() {
            this.skeleton.pose()
        },
        normalizeSkinWeights: function() {
            if (this.geometry && this.geometry.isGeometry)
                for (i = 0; i < this.geometry.skinWeights.length; i++) {
                    var t = this.geometry.skinWeights[i]
                      , e = 1 / t.manhattanLength();
                    1 / 0 !== e ? t.multiplyScalar(e) : t.set(1, 0, 0, 0)
                }
            else if (this.geometry && this.geometry.isBufferGeometry)
                for (var t = new Et, n = this.geometry.attributes.skinWeight, i = 0; i < n.count; i++)
                    t.x = n.getX(i),
                    t.y = n.getY(i),
                    t.z = n.getZ(i),
                    t.w = n.getW(i),
                    1 / 0 !== (e = 1 / t.manhattanLength()) ? t.multiplyScalar(e) : t.set(1, 0, 0, 0),
                    n.setXYZW(i, t.x, t.y, t.z, t.w)
        },
        updateMatrixWorld: function(t) {
            H.prototype.updateMatrixWorld.call(this, t),
            "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        },
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    }),
    ((we.prototype = Object.create(I.prototype)).constructor = we).prototype.isLineBasicMaterial = !0,
    we.prototype.copy = function(t) {
        return I.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.linewidth = t.linewidth,
        this.linecap = t.linecap,
        this.linejoin = t.linejoin,
        this
    }
    ,
    Ee.prototype = Object.assign(Object.create(l.prototype), {
        constructor: Ee,
        isLine: !0,
        computeLineDistances: (zs = new wt,
        Hs = new wt,
        function() {
            var t = this.geometry;
            if (t.isBufferGeometry)
                if (null === t.index) {
                    for (var e = t.attributes.position, n = [0], i = 1, r = e.count; i < r; i++)
                        zs.fromBufferAttribute(e, i - 1),
                        Hs.fromBufferAttribute(e, i),
                        n[i] = n[i - 1],
                        n[i] += zs.distanceTo(Hs);
                    t.addAttribute("lineDistance", new L(n,1))
                } else
                    console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else if (t.isGeometry)
                for (e = t.vertices,
                (n = t.lineDistances)[0] = 0,
                i = 1,
                r = e.length; i < r; i++)
                    n[i] = n[i - 1],
                    n[i] += e[i - 1].distanceTo(e[i]);
            return this
        }
        ),
        raycast: (Us = new _t,
        Ds = new D,
        Fs = new a,
        function(t, e) {
            var n = t.linePrecision;
            n *= n;
            var i = this.geometry
              , r = this.matrixWorld;
            if (null === i.boundingSphere && i.computeBoundingSphere(),
            Fs.copy(i.boundingSphere),
            Fs.applyMatrix4(r),
            !1 !== t.ray.intersectsSphere(Fs)) {
                Us.getInverse(r),
                Ds.copy(t.ray).applyMatrix4(Us);
                var o = new wt
                  , a = new wt
                  , r = new wt
                  , s = new wt
                  , c = this && this.isLineSegments ? 2 : 1;
                if (i.isBufferGeometry) {
                    var h = i.index
                      , l = i.attributes.position.array;
                    if (null !== h)
                        for (var i = 0, u = (h = h.array).length - 1; i < u; i += c) {
                            var d = h[i + 1];
                            o.fromArray(l, 3 * h[i]),
                            a.fromArray(l, 3 * d),
                            n < (d = Ds.distanceSqToSegment(o, a, s, r)) || (s.applyMatrix4(this.matrixWorld),
                            (d = t.ray.origin.distanceTo(s)) < t.near || d > t.far || e.push({
                                distance: d,
                                point: r.clone().applyMatrix4(this.matrixWorld),
                                index: i,
                                face: null,
                                faceIndex: null,
                                object: this
                            }))
                        }
                    else
                        for (i = 0,
                        u = l.length / 3 - 1; i < u; i += c)
                            o.fromArray(l, 3 * i),
                            a.fromArray(l, 3 * i + 3),
                            n < (d = Ds.distanceSqToSegment(o, a, s, r)) || (s.applyMatrix4(this.matrixWorld),
                            (d = t.ray.origin.distanceTo(s)) < t.near || d > t.far || e.push({
                                distance: d,
                                point: r.clone().applyMatrix4(this.matrixWorld),
                                index: i,
                                face: null,
                                faceIndex: null,
                                object: this
                            }))
                } else if (i.isGeometry)
                    for (a = (o = i.vertices).length,
                    i = 0; i < a - 1; i += c)
                        n < (d = Ds.distanceSqToSegment(o[i], o[i + 1], s, r)) || (s.applyMatrix4(this.matrixWorld),
                        (d = t.ray.origin.distanceTo(s)) < t.near || d > t.far || e.push({
                            distance: d,
                            point: r.clone().applyMatrix4(this.matrixWorld),
                            index: i,
                            face: null,
                            faceIndex: null,
                            object: this
                        }))
            }
        }
        ),
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    }),
    Me.prototype = Object.assign(Object.create(Ee.prototype), {
        constructor: Me,
        isLineSegments: !0,
        computeLineDistances: (Gs = new wt,
        ks = new wt,
        function() {
            var t = this.geometry;
            if (t.isBufferGeometry)
                if (null === t.index) {
                    for (var e = t.attributes.position, n = [], i = 0, r = e.count; i < r; i += 2)
                        Gs.fromBufferAttribute(e, i),
                        ks.fromBufferAttribute(e, i + 1),
                        n[i] = 0 === i ? 0 : n[i - 1],
                        n[i + 1] = n[i] + Gs.distanceTo(ks);
                    t.addAttribute("lineDistance", new L(n,1))
                } else
                    console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else if (t.isGeometry)
                for (e = t.vertices,
                n = t.lineDistances,
                i = 0,
                r = e.length; i < r; i += 2)
                    Gs.copy(e[i]),
                    ks.copy(e[i + 1]),
                    n[i] = 0 === i ? 0 : n[i - 1],
                    n[i + 1] = n[i] + Gs.distanceTo(ks);
            return this
        }
        )
    }),
    Te.prototype = Object.assign(Object.create(Ee.prototype), {
        constructor: Te,
        isLineLoop: !0
    }),
    ((Se.prototype = Object.create(I.prototype)).constructor = Se).prototype.isPointsMaterial = !0,
    Se.prototype.copy = function(t) {
        return I.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.map = t.map,
        this.size = t.size,
        this.sizeAttenuation = t.sizeAttenuation,
        this
    }
    ,
    Ae.prototype = Object.assign(Object.create(l.prototype), {
        constructor: Ae,
        isPoints: !0,
        raycast: (Vs = new _t,
        js = new D,
        Ws = new a,
        function(i, r) {
            function t(t, e) {
                var n = js.distanceSqToPoint(t);
                n < s && (js.closestPointToPoint(t, c),
                c.applyMatrix4(a),
                (t = i.ray.origin.distanceTo(c)) < i.near || t > i.far || r.push({
                    distance: t,
                    distanceToRay: Math.sqrt(n),
                    point: c.clone(),
                    index: e,
                    face: null,
                    object: o
                }))
            }
            var o = this
              , e = this.geometry
              , a = this.matrixWorld
              , n = i.params.Points.threshold;
            if (null === e.boundingSphere && e.computeBoundingSphere(),
            Ws.copy(e.boundingSphere),
            Ws.applyMatrix4(a),
            Ws.radius += n,
            !1 !== i.ray.intersectsSphere(Ws)) {
                Vs.getInverse(a),
                js.copy(i.ray).applyMatrix4(Vs);
                var s = (n /= (this.scale.x + this.scale.y + this.scale.z) / 3) * n
                  , n = new wt
                  , c = new wt;
                if (e.isBufferGeometry) {
                    var h = e.index
                      , e = e.attributes.position.array;
                    if (null !== h)
                        for (var l = h.array, h = 0, u = l.length; h < u; h++) {
                            var d = l[h];
                            n.fromArray(e, 3 * d),
                            t(n, d)
                        }
                    else
                        for (h = 0,
                        l = e.length / 3; h < l; h++)
                            n.fromArray(e, 3 * h),
                            t(n, h)
                } else
                    for (h = 0,
                    l = (n = e.vertices).length; h < l; h++)
                        t(n[h], h)
            }
        }
        ),
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    }),
    Re.prototype = Object.assign(Object.create(l.prototype), {
        constructor: Re,
        isGroup: !0
    }),
    Le.prototype = Object.assign(Object.create(d.prototype), {
        constructor: Le,
        isVideoTexture: !0,
        update: function() {
            var t = this.image;
            t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
        }
    }),
    ((Ce.prototype = Object.create(d.prototype)).constructor = Ce).prototype.isCompressedTexture = !0,
    ((Pe.prototype = Object.create(d.prototype)).constructor = Pe).prototype.isDepthTexture = !0,
    (Ne.prototype = Object.create(C.prototype)).constructor = Ne,
    (Oe.prototype = Object.create(M.prototype)).constructor = Oe,
    (Ie.prototype = Object.create(C.prototype)).constructor = Ie,
    (Be.prototype = Object.create(M.prototype)).constructor = Be,
    (Ue.prototype = Object.create(C.prototype)).constructor = Ue,
    (De.prototype = Object.create(M.prototype)).constructor = De,
    (Fe.prototype = Object.create(Ue.prototype)).constructor = Fe,
    (ze.prototype = Object.create(M.prototype)).constructor = ze,
    (He.prototype = Object.create(Ue.prototype)).constructor = He,
    (Ge.prototype = Object.create(M.prototype)).constructor = Ge,
    (ke.prototype = Object.create(Ue.prototype)).constructor = ke,
    (Ve.prototype = Object.create(M.prototype)).constructor = Ve,
    (je.prototype = Object.create(Ue.prototype)).constructor = je,
    (We.prototype = Object.create(M.prototype)).constructor = We,
    (Xe.prototype = Object.create(C.prototype)).constructor = Xe,
    (qe.prototype = Object.create(M.prototype)).constructor = qe,
    (Ye.prototype = Object.create(C.prototype)).constructor = Ye,
    (Ze.prototype = Object.create(M.prototype)).constructor = Ze,
    (Je.prototype = Object.create(C.prototype)).constructor = Je;
    var Ys = function(t, e, n) {
        n = n || 2;
        var i, r = (c = e && e.length) ? e[0] * n : t.length, o = Qe(t, 0, r, n, !0), a = [];
        if (!o)
            return a;
        if (c) {
            for (var s = n, c = [], h = 0, l = e.length; h < l; h++) {
                var u = e[h] * s;
                (u = Qe(t, u, h < l - 1 ? e[h + 1] * s : t.length, s, !1)) === u.next && (u.steiner = !0),
                c.push(function(t) {
                    for (var e = t, n = t; e.x < n.x && (n = e),
                    (e = e.next) !== t; )
                        ;
                    return n
                }(u))
            }
            for (c.sort($e),
            h = 0; h < c.length; h++)
                (s = function(t, e) {
                    var n = e
                      , i = t.x
                      , r = t.y
                      , o = -1 / 0;
                    do {
                        if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
                            var a = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                            if (a <= i && o < a) {
                                if ((o = a) === i) {
                                    if (r === n.y)
                                        return n;
                                    if (r === n.next.y)
                                        return n.next
                                }
                                var s = n.x < n.next.x ? n : n.next
                            }
                        }
                    } while ((n = n.next) !== e);
                    if (!s)
                        return null;
                    if (i === o)
                        return s.prev;
                    for (var c, a = (e = s).x, h = s.y, l = 1 / 0, n = s.next; n !== e; )
                        i >= n.x && n.x >= a && i !== n.x && en(r < h ? i : o, r, a, h, r < h ? o : i, r, n.x, n.y) && (((c = Math.abs(r - n.y) / (i - n.x)) < l || c === l && n.x > s.x) && an(n, t) && (s = n,
                        l = c)),
                        n = n.next;
                    return s
                }(e = c[h], s = o)) && Ke(e = sn(s, e), e.next),
                o = Ke(o, o.next)
        }
        if (t.length > 80 * n) {
            for (var d = i = t[0], p = c = t[1], s = n; s < r; s += n)
                (h = t[s]) < d && (d = h),
                (e = t[s + 1]) < p && (p = e),
                i < h && (i = h),
                c < e && (c = e);
            i = 0 !== (i = Math.max(i - d, c - p)) ? 1 / i : 0
        }
        return function t(e, n, i, r, o, a, s) {
            if (e) {
                if (!s && a) {
                    for (var c = l = e; null === c.z && (c.z = tn(c.x, c.y, r, o, a)),
                    c.prevZ = c.prev,
                    (c = c.nextZ = c.next) !== l; )
                        ;
                    c.prevZ.nextZ = null,
                    c.prevZ = null;
                    var h, l = c, u = 1;
                    do {
                        for (var c = l, d = l = null, p = 0; c; ) {
                            p++;
                            for (var f = c, m = h = 0; m < u && (h++,
                            f = f.nextZ); m++)
                                ;
                            for (g = u; 0 < h || 0 < g && f; )
                                0 !== h && (0 === g || !f || c.z <= f.z) ? (c = (m = c).nextZ,
                                h--) : (f = (m = f).nextZ,
                                g--),
                                d ? d.nextZ = m : l = m,
                                m.prevZ = d,
                                d = m;
                            c = f
                        }
                    } while (d.nextZ = null,
                    u *= 2,
                    1 < p)
                }
                for (l = e; e.prev !== e.next; ) {
                    if (c = e.prev,
                    f = e.next,
                    a)
                        t: {
                            var g = r
                              , v = o;
                            if (0 <= nn(p = (d = e).prev, h = d, u = d.next))
                                d = !1;
                            else {
                                var y = (p.x > h.x ? p.x > u.x ? p : u : h.x > u.x ? h : u).x
                                  , x = (p.y > h.y ? p.y > u.y ? p : u : h.y > u.y ? h : u).y;
                                for (m = tn((p.x < h.x ? p.x < u.x ? p : u : h.x < u.x ? h : u).x, (p.y < h.y ? p.y < u.y ? p : u : h.y < u.y ? h : u).y, g, v, a),
                                g = tn(y, x, g, v, a),
                                v = d.nextZ; v && v.z <= g; ) {
                                    if (v !== d.prev && v !== d.next && en(p.x, p.y, h.x, h.y, u.x, u.y, v.x, v.y) && 0 <= nn(v.prev, v, v.next)) {
                                        d = !1;
                                        break t
                                    }
                                    v = v.nextZ
                                }
                                for (v = d.prevZ; v && v.z >= m; ) {
                                    if (v !== d.prev && v !== d.next && en(p.x, p.y, h.x, h.y, u.x, u.y, v.x, v.y) && 0 <= nn(v.prev, v, v.next)) {
                                        d = !1;
                                        break t
                                    }
                                    v = v.prevZ
                                }
                                d = !0
                            }
                        }
                    else
                        t: if (d = e,
                        p = d.prev,
                        h = d,
                        u = d.next,
                        0 <= nn(p, h, u))
                            d = !1;
                        else {
                            for (m = d.next.next; m !== d.prev; ) {
                                if (en(p.x, p.y, h.x, h.y, u.x, u.y, m.x, m.y) && 0 <= nn(m.prev, m, m.next)) {
                                    d = !1;
                                    break t
                                }
                                m = m.next
                            }
                            d = !0
                        }
                    if (d)
                        n.push(c.i / i),
                        n.push(e.i / i),
                        n.push(f.i / i),
                        hn(e),
                        l = e = f.next;
                    else if ((e = f) === l) {
                        if (s) {
                            if (1 === s) {
                                for (s = n,
                                l = i,
                                c = e; !rn(f = c.prev, d = c.next.next) && on(f, c, c.next, d) && an(f, d) && an(d, f) && (s.push(f.i / l),
                                s.push(c.i / l),
                                s.push(d.i / l),
                                hn(c),
                                hn(c.next),
                                c = e = d),
                                (c = c.next) !== e; )
                                    ;
                                t(e = c, n, i, r, o, a, 2)
                            } else if (2 === s)
                                t: {
                                    s = e;
                                    do {
                                        for (l = s.next.next; l !== s.prev; ) {
                                            if (c = s.i !== l.i) {
                                                if (f = l,
                                                d = (c = s).next.i !== f.i && c.prev.i !== f.i) {
                                                    e: {
                                                        d = c;
                                                        do {
                                                            if (d.i !== c.i && d.next.i !== c.i && d.i !== f.i && d.next.i !== f.i && on(d, d.next, c, f)) {
                                                                d = !0;
                                                                break e
                                                            }
                                                        } while ((d = d.next) !== c);
                                                        d = !1
                                                    }
                                                    d = !d
                                                }
                                                if (d = d && an(c, f) && an(f, c)) {
                                                    for (p = !1,
                                                    h = ((d = c).x + f.x) / 2,
                                                    f = (c.y + f.y) / 2; d.y > f != d.next.y > f && d.next.y !== d.y && h < (d.next.x - d.x) * (f - d.y) / (d.next.y - d.y) + d.x && (p = !p),
                                                    (d = d.next) !== c; )
                                                        ;
                                                    d = p
                                                }
                                                c = d
                                            }
                                            if (c) {
                                                e = sn(s, l),
                                                s = Ke(s, s.next),
                                                e = Ke(e, e.next),
                                                t(s, n, i, r, o, a),
                                                t(e, n, i, r, o, a);
                                                break t
                                            }
                                            l = l.next
                                        }
                                    } while ((s = s.next) !== e)
                                }
                        } else
                            t(Ke(e), n, i, r, o, a, 1);
                        break
                    }
                }
            }
        }(o, a, n, d, p, i),
        a
    }
      , Zs = {
        area: function(t) {
            for (var e = t.length, n = 0, i = e - 1, r = 0; r < e; i = r++)
                n += t[i].x * t[r].y - t[r].x * t[i].y;
            return .5 * n
        },
        isClockWise: function(t) {
            return Zs.area(t) < 0
        },
        triangulateShape: function(t, e) {
            var n = []
              , i = []
              , r = [];
            un(t),
            dn(n, t);
            var o = t.length;
            for (e.forEach(un),
            t = 0; t < e.length; t++)
                i.push(o),
                o += e[t].length,
                dn(n, e[t]);
            for (e = Ys(n, i),
            t = 0; t < e.length; t += 3)
                r.push(e.slice(t, t + 3));
            return r
        }
    };
    (pn.prototype = Object.create(M.prototype)).constructor = pn,
    (fn.prototype = Object.create(C.prototype)).constructor = fn;
    var Js = {
        generateTopUV: function(t, e, n, i, r) {
            t = e[3 * i],
            i = e[3 * i + 1];
            var o = e[3 * r];
            return r = e[3 * r + 1],
            [new W(e[3 * n],e[3 * n + 1]), new W(t,i), new W(o,r)]
        },
        generateSideWallUV: function(t, e, n, i, r, o) {
            t = e[3 * n];
            var a = e[3 * n + 1];
            n = e[3 * n + 2];
            var s = e[3 * i]
              , c = e[3 * i + 1];
            i = e[3 * i + 2];
            var h = e[3 * r]
              , l = e[3 * r + 1];
            r = e[3 * r + 2];
            var u = e[3 * o]
              , d = e[3 * o + 1];
            return e = e[3 * o + 2],
            Math.abs(a - c) < .01 ? [new W(t,1 - n), new W(s,1 - i), new W(h,1 - r), new W(u,1 - e)] : [new W(a,1 - n), new W(c,1 - i), new W(l,1 - r), new W(d,1 - e)]
        }
    };
    (mn.prototype = Object.create(M.prototype)).constructor = mn,
    (gn.prototype = Object.create(fn.prototype)).constructor = gn,
    (vn.prototype = Object.create(M.prototype)).constructor = vn,
    (yn.prototype = Object.create(C.prototype)).constructor = yn,
    (xn.prototype = Object.create(M.prototype)).constructor = xn,
    (bn.prototype = Object.create(C.prototype)).constructor = bn,
    (_n.prototype = Object.create(M.prototype)).constructor = _n,
    (wn.prototype = Object.create(C.prototype)).constructor = wn,
    ((En.prototype = Object.create(M.prototype)).constructor = En).prototype.toJSON = function() {
        var t = M.prototype.toJSON.call(this);
        return Tn(this.parameters.shapes, t)
    }
    ,
    ((Mn.prototype = Object.create(C.prototype)).constructor = Mn).prototype.toJSON = function() {
        var t = C.prototype.toJSON.call(this);
        return Tn(this.parameters.shapes, t)
    }
    ,
    (Sn.prototype = Object.create(C.prototype)).constructor = Sn,
    (An.prototype = Object.create(M.prototype)).constructor = An,
    (Rn.prototype = Object.create(C.prototype)).constructor = Rn,
    (Ln.prototype = Object.create(An.prototype)).constructor = Ln,
    (Cn.prototype = Object.create(Rn.prototype)).constructor = Cn,
    (Pn.prototype = Object.create(M.prototype)).constructor = Pn,
    (Nn.prototype = Object.create(C.prototype)).constructor = Nn;
    var Qs = Object.freeze({
        WireframeGeometry: Ne,
        ParametricGeometry: Oe,
        ParametricBufferGeometry: Ie,
        TetrahedronGeometry: De,
        TetrahedronBufferGeometry: Fe,
        OctahedronGeometry: ze,
        OctahedronBufferGeometry: He,
        IcosahedronGeometry: Ge,
        IcosahedronBufferGeometry: ke,
        DodecahedronGeometry: Ve,
        DodecahedronBufferGeometry: je,
        PolyhedronGeometry: Be,
        PolyhedronBufferGeometry: Ue,
        TubeGeometry: We,
        TubeBufferGeometry: Xe,
        TorusKnotGeometry: qe,
        TorusKnotBufferGeometry: Ye,
        TorusGeometry: Ze,
        TorusBufferGeometry: Je,
        TextGeometry: mn,
        TextBufferGeometry: gn,
        SphereGeometry: vn,
        SphereBufferGeometry: yn,
        RingGeometry: xn,
        RingBufferGeometry: bn,
        PlaneGeometry: N,
        PlaneBufferGeometry: O,
        LatheGeometry: _n,
        LatheBufferGeometry: wn,
        ShapeGeometry: En,
        ShapeBufferGeometry: Mn,
        ExtrudeGeometry: pn,
        ExtrudeBufferGeometry: fn,
        EdgesGeometry: Sn,
        ConeGeometry: Ln,
        ConeBufferGeometry: Cn,
        CylinderGeometry: An,
        CylinderBufferGeometry: Rn,
        CircleGeometry: Pn,
        CircleBufferGeometry: Nn,
        BoxGeometry: R,
        BoxBufferGeometry: P
    });
    ((On.prototype = Object.create(I.prototype)).constructor = On).prototype.isShadowMaterial = !0,
    On.prototype.copy = function(t) {
        return I.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this
    }
    ,
    ((In.prototype = Object.create(U.prototype)).constructor = In).prototype.isRawShaderMaterial = !0,
    ((Bn.prototype = Object.create(I.prototype)).constructor = Bn).prototype.isMeshStandardMaterial = !0,
    Bn.prototype.copy = function(t) {
        return I.prototype.copy.call(this, t),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(t.color),
        this.roughness = t.roughness,
        this.metalness = t.metalness,
        this.map = t.map,
        this.lightMap = t.lightMap,
        this.lightMapIntensity = t.lightMapIntensity,
        this.aoMap = t.aoMap,
        this.aoMapIntensity = t.aoMapIntensity,
        this.emissive.copy(t.emissive),
        this.emissiveMap = t.emissiveMap,
        this.emissiveIntensity = t.emissiveIntensity,
        this.bumpMap = t.bumpMap,
        this.bumpScale = t.bumpScale,
        this.normalMap = t.normalMap,
        this.normalScale.copy(t.normalScale),
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.roughnessMap = t.roughnessMap,
        this.metalnessMap = t.metalnessMap,
        this.alphaMap = t.alphaMap,
        this.envMap = t.envMap,
        this.envMapIntensity = t.envMapIntensity,
        this.refractionRatio = t.refractionRatio,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.wireframeLinecap = t.wireframeLinecap,
        this.wireframeLinejoin = t.wireframeLinejoin,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this
    }
    ,
    ((Un.prototype = Object.create(Bn.prototype)).constructor = Un).prototype.isMeshPhysicalMaterial = !0,
    Un.prototype.copy = function(t) {
        return Bn.prototype.copy.call(this, t),
        this.defines = {
            PHYSICAL: ""
        },
        this.reflectivity = t.reflectivity,
        this.clearCoat = t.clearCoat,
        this.clearCoatRoughness = t.clearCoatRoughness,
        this
    }
    ,
    ((Dn.prototype = Object.create(I.prototype)).constructor = Dn).prototype.isMeshPhongMaterial = !0,
    Dn.prototype.copy = function(t) {
        return I.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.specular.copy(t.specular),
        this.shininess = t.shininess,
        this.map = t.map,
        this.lightMap = t.lightMap,
        this.lightMapIntensity = t.lightMapIntensity,
        this.aoMap = t.aoMap,
        this.aoMapIntensity = t.aoMapIntensity,
        this.emissive.copy(t.emissive),
        this.emissiveMap = t.emissiveMap,
        this.emissiveIntensity = t.emissiveIntensity,
        this.bumpMap = t.bumpMap,
        this.bumpScale = t.bumpScale,
        this.normalMap = t.normalMap,
        this.normalScale.copy(t.normalScale),
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.specularMap = t.specularMap,
        this.alphaMap = t.alphaMap,
        this.envMap = t.envMap,
        this.combine = t.combine,
        this.reflectivity = t.reflectivity,
        this.refractionRatio = t.refractionRatio,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.wireframeLinecap = t.wireframeLinecap,
        this.wireframeLinejoin = t.wireframeLinejoin,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this
    }
    ,
    ((Fn.prototype = Object.create(Dn.prototype)).constructor = Fn).prototype.isMeshToonMaterial = !0,
    Fn.prototype.copy = function(t) {
        return Dn.prototype.copy.call(this, t),
        this.gradientMap = t.gradientMap,
        this
    }
    ,
    ((zn.prototype = Object.create(I.prototype)).constructor = zn).prototype.isMeshNormalMaterial = !0,
    zn.prototype.copy = function(t) {
        return I.prototype.copy.call(this, t),
        this.bumpMap = t.bumpMap,
        this.bumpScale = t.bumpScale,
        this.normalMap = t.normalMap,
        this.normalScale.copy(t.normalScale),
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this
    }
    ,
    ((Hn.prototype = Object.create(I.prototype)).constructor = Hn).prototype.isMeshLambertMaterial = !0,
    Hn.prototype.copy = function(t) {
        return I.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.map = t.map,
        this.lightMap = t.lightMap,
        this.lightMapIntensity = t.lightMapIntensity,
        this.aoMap = t.aoMap,
        this.aoMapIntensity = t.aoMapIntensity,
        this.emissive.copy(t.emissive),
        this.emissiveMap = t.emissiveMap,
        this.emissiveIntensity = t.emissiveIntensity,
        this.specularMap = t.specularMap,
        this.alphaMap = t.alphaMap,
        this.envMap = t.envMap,
        this.combine = t.combine,
        this.reflectivity = t.reflectivity,
        this.refractionRatio = t.refractionRatio,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.wireframeLinecap = t.wireframeLinecap,
        this.wireframeLinejoin = t.wireframeLinejoin,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this
    }
    ,
    ((Gn.prototype = Object.create(we.prototype)).constructor = Gn).prototype.isLineDashedMaterial = !0,
    Gn.prototype.copy = function(t) {
        return we.prototype.copy.call(this, t),
        this.scale = t.scale,
        this.dashSize = t.dashSize,
        this.gapSize = t.gapSize,
        this
    }
    ;
    var Ks = Object.freeze({
        ShadowMaterial: On,
        SpriteMaterial: ge,
        RawShaderMaterial: In,
        ShaderMaterial: U,
        PointsMaterial: Se,
        MeshPhysicalMaterial: Un,
        MeshStandardMaterial: Bn,
        MeshPhongMaterial: Dn,
        MeshToonMaterial: Fn,
        MeshNormalMaterial: zn,
        MeshLambertMaterial: Hn,
        MeshDepthMaterial: ee,
        MeshDistanceMaterial: ne,
        MeshBasicMaterial: B,
        LineDashedMaterial: Gn,
        LineBasicMaterial: we,
        Material: I
    })
      , $s = {
        enabled: !1,
        files: {},
        add: function(t, e) {
            !1 !== this.enabled && (this.files[t] = e)
        },
        get: function(t) {
            if (!1 !== this.enabled)
                return this.files[t]
        },
        remove: function(t) {
            delete this.files[t]
        },
        clear: function() {
            this.files = {}
        }
    }
      , tc = new kn
      , ec = {};
    Object.assign(Vn.prototype, {
        load: function(a, t, e, n) {
            void 0 === a && (a = ""),
            void 0 !== this.path && (a = this.path + a),
            a = this.manager.resolveURL(a);
            var s = this
              , i = $s.get(a);
            if (void 0 !== i)
                return s.manager.itemStart(a),
                setTimeout(function() {
                    t && t(i),
                    s.manager.itemEnd(a)
                }, 0),
                i;
            if (void 0 === ec[a]) {
                if (o = a.match(/^data:(.*?)(;base64)?,(.*)$/)) {
                    e = o[1];
                    var r = !!o[2]
                      , o = o[3];
                    o = window.decodeURIComponent(o),
                    r && (o = window.atob(o));
                    try {
                        var c = (this.responseType || "").toLowerCase();
                        switch (c) {
                        case "arraybuffer":
                        case "blob":
                            for (var h = new Uint8Array(o.length), r = 0; r < o.length; r++)
                                h[r] = o.charCodeAt(r);
                            var l = "blob" === c ? new Blob([h.buffer],{
                                type: e
                            }) : h.buffer;
                            break;
                        case "document":
                            l = (new DOMParser).parseFromString(o, e);
                            break;
                        case "json":
                            l = JSON.parse(o);
                            break;
                        default:
                            l = o
                        }
                        window.setTimeout(function() {
                            t && t(l),
                            s.manager.itemEnd(a)
                        }, 0)
                    } catch (t) {
                        window.setTimeout(function() {
                            n && n(t),
                            s.manager.itemEnd(a),
                            s.manager.itemError(a)
                        }, 0)
                    }
                } else {
                    ec[a] = [],
                    ec[a].push({
                        onLoad: t,
                        onProgress: e,
                        onError: n
                    });
                    var u = new XMLHttpRequest;
                    for (r in u.open("GET", a, !0),
                    u.addEventListener("load", function(t) {
                        var e = this.response;
                        $s.add(a, e);
                        var n = ec[a];
                        if (delete ec[a],
                        200 === this.status) {
                            for (var i = 0, r = n.length; i < r; i++) {
                                var o = n[i];
                                o.onLoad && o.onLoad(e)
                            }
                            s.manager.itemEnd(a)
                        } else if (0 === this.status) {
                            for (console.warn("THREE.FileLoader: HTTP Status 0 received."),
                            i = 0,
                            r = n.length; i < r; i++)
                                (o = n[i]).onLoad && o.onLoad(e);
                            s.manager.itemEnd(a)
                        } else {
                            for (i = 0,
                            r = n.length; i < r; i++)
                                (o = n[i]).onError && o.onError(t);
                            s.manager.itemEnd(a),
                            s.manager.itemError(a)
                        }
                    }, !1),
                    u.addEventListener("progress", function(t) {
                        for (var e = ec[a], n = 0, i = e.length; n < i; n++) {
                            var r = e[n];
                            r.onProgress && r.onProgress(t)
                        }
                    }, !1),
                    u.addEventListener("error", function(t) {
                        var e = ec[a];
                        delete ec[a];
                        for (var n = 0, i = e.length; n < i; n++) {
                            var r = e[n];
                            r.onError && r.onError(t)
                        }
                        s.manager.itemEnd(a),
                        s.manager.itemError(a)
                    }, !1),
                    void 0 !== this.responseType && (u.responseType = this.responseType),
                    void 0 !== this.withCredentials && (u.withCredentials = this.withCredentials),
                    u.overrideMimeType && u.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"),
                    this.requestHeader)
                        u.setRequestHeader(r, this.requestHeader[r]);
                    u.send(null)
                }
                return s.manager.itemStart(a),
                u
            }
            ec[a].push({
                onLoad: t,
                onProgress: e,
                onError: n
            })
        },
        setPath: function(t) {
            return this.path = t,
            this
        },
        setResponseType: function(t) {
            return this.responseType = t,
            this
        },
        setWithCredentials: function(t) {
            return this.withCredentials = t,
            this
        },
        setMimeType: function(t) {
            return this.mimeType = t,
            this
        },
        setRequestHeader: function(t) {
            return this.requestHeader = t,
            this
        }
    }),
    Object.assign(jn.prototype, {
        load: function(t, r, n, i) {
            var o = this
              , a = []
              , s = new Ce;
            s.image = a;
            var c = new Vn(this.manager);
            if (c.setPath(this.path),
            c.setResponseType("arraybuffer"),
            Array.isArray(t))
                for (var h = 0, e = 0, l = t.length; e < l; ++e)
                    !function(e) {
                        c.load(t[e], function(t) {
                            t = o._parser(t, !0),
                            a[e] = {
                                width: t.width,
                                height: t.height,
                                format: t.format,
                                mipmaps: t.mipmaps
                            },
                            6 === (h += 1) && (1 === t.mipmapCount && (s.minFilter = 1006),
                            s.format = t.format,
                            s.needsUpdate = !0,
                            r && r(s))
                        }, n, i)
                    }(e);
            else
                c.load(t, function(t) {
                    if ((t = o._parser(t, !0)).isCubemap)
                        for (var e = t.mipmaps.length / t.mipmapCount, n = 0; n < e; n++) {
                            a[n] = {
                                mipmaps: []
                            };
                            for (var i = 0; i < t.mipmapCount; i++)
                                a[n].mipmaps.push(t.mipmaps[n * t.mipmapCount + i]),
                                a[n].format = t.format,
                                a[n].width = t.width,
                                a[n].height = t.height
                        }
                    else
                        s.image.width = t.width,
                        s.image.height = t.height,
                        s.mipmaps = t.mipmaps;
                    1 === t.mipmapCount && (s.minFilter = 1006),
                    s.format = t.format,
                    s.needsUpdate = !0,
                    r && r(s)
                }, n, i);
            return s
        },
        setPath: function(t) {
            return this.path = t,
            this
        }
    }),
    Object.assign(Wn.prototype, {
        load: function(t, e, n, i) {
            var r = this
              , o = new Mt
              , a = new Vn(this.manager);
            return a.setResponseType("arraybuffer"),
            a.load(t, function(t) {
                (t = r._parser(t)) && (void 0 !== t.image ? o.image = t.image : void 0 !== t.data && (o.image.width = t.width,
                o.image.height = t.height,
                o.image.data = t.data),
                o.wrapS = void 0 !== t.wrapS ? t.wrapS : 1001,
                o.wrapT = void 0 !== t.wrapT ? t.wrapT : 1001,
                o.magFilter = void 0 !== t.magFilter ? t.magFilter : 1006,
                o.minFilter = void 0 !== t.minFilter ? t.minFilter : 1008,
                o.anisotropy = void 0 !== t.anisotropy ? t.anisotropy : 1,
                void 0 !== t.format && (o.format = t.format),
                void 0 !== t.type && (o.type = t.type),
                void 0 !== t.mipmaps && (o.mipmaps = t.mipmaps),
                1 === t.mipmapCount && (o.minFilter = 1006),
                o.needsUpdate = !0,
                e && e(o, t))
            }, n, i),
            o
        }
    }),
    Object.assign(Xn.prototype, {
        crossOrigin: "Anonymous",
        load: function(e, t, n, i) {
            void 0 === e && (e = ""),
            void 0 !== this.path && (e = this.path + e),
            e = this.manager.resolveURL(e);
            var r = this
              , o = $s.get(e);
            return void 0 !== o ? (r.manager.itemStart(e),
            setTimeout(function() {
                t && t(o),
                r.manager.itemEnd(e)
            }, 0),
            o) : ((n = document.createElementNS("http://www.w3.org/1999/xhtml", "img")).addEventListener("load", function() {
                $s.add(e, this),
                t && t(this),
                r.manager.itemEnd(e)
            }, !1),
            n.addEventListener("error", function(t) {
                i && i(t),
                r.manager.itemEnd(e),
                r.manager.itemError(e)
            }, !1),
            "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (n.crossOrigin = this.crossOrigin),
            r.manager.itemStart(e),
            n.src = e,
            n)
        },
        setCrossOrigin: function(t) {
            return this.crossOrigin = t,
            this
        },
        setPath: function(t) {
            return this.path = t,
            this
        }
    }),
    Object.assign(qn.prototype, {
        crossOrigin: "Anonymous",
        load: function(t, n, e, i) {
            var r = new k
              , o = new Xn(this.manager);
            o.setCrossOrigin(this.crossOrigin),
            o.setPath(this.path);
            var a = 0;
            for (e = 0; e < t.length; ++e)
                !function(e) {
                    o.load(t[e], function(t) {
                        r.images[e] = t,
                        6 === ++a && (r.needsUpdate = !0,
                        n && n(r))
                    }, void 0, i)
                }(e);
            return r
        },
        setCrossOrigin: function(t) {
            return this.crossOrigin = t,
            this
        },
        setPath: function(t) {
            return this.path = t,
            this
        }
    }),
    Object.assign(Yn.prototype, {
        crossOrigin: "Anonymous",
        load: function(e, n, t, i) {
            var r = new d
              , o = new Xn(this.manager);
            return o.setCrossOrigin(this.crossOrigin),
            o.setPath(this.path),
            o.load(e, function(t) {
                r.image = t,
                t = 0 < e.search(/\.(jpg|jpeg)$/) || 0 === e.search(/^data:image\/jpeg/),
                r.format = t ? 1022 : 1023,
                r.needsUpdate = !0,
                void 0 !== n && n(r)
            }, t, i),
            r
        },
        setCrossOrigin: function(t) {
            return this.crossOrigin = t,
            this
        },
        setPath: function(t) {
            return this.path = t,
            this
        }
    }),
    Object.assign(Zn.prototype, {
        getPoint: function() {
            return console.warn("THREE.Curve: .getPoint() not implemented."),
            null
        },
        getPointAt: function(t, e) {
            return t = this.getUtoTmapping(t),
            this.getPoint(t, e)
        },
        getPoints: function(t) {
            void 0 === t && (t = 5);
            for (var e = [], n = 0; n <= t; n++)
                e.push(this.getPoint(n / t));
            return e
        },
        getSpacedPoints: function(t) {
            void 0 === t && (t = 5);
            for (var e = [], n = 0; n <= t; n++)
                e.push(this.getPointAt(n / t));
            return e
        },
        getLength: function() {
            var t = this.getLengths();
            return t[t.length - 1]
        },
        getLengths: function(t) {
            if (void 0 === t && (t = this.arcLengthDivisions),
            this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
                return this.cacheArcLengths;
            this.needsUpdate = !1;
            var e, n = [], i = this.getPoint(0), r = 0;
            for (n.push(0),
            e = 1; e <= t; e++) {
                var o = this.getPoint(e / t);
                r += o.distanceTo(i),
                n.push(r),
                i = o
            }
            return this.cacheArcLengths = n
        },
        updateArcLengths: function() {
            this.needsUpdate = !0,
            this.getLengths()
        },
        getUtoTmapping: function(t, e) {
            var n = this.getLengths()
              , i = n.length;
            e = e || t * n[i - 1];
            for (var r, o = 0, a = i - 1; o <= a; )
                if ((r = n[t = Math.floor(o + (a - o) / 2)] - e) < 0)
                    o = t + 1;
                else {
                    if (!(0 < r)) {
                        a = t;
                        break
                    }
                    a = t - 1
                }
            return n[t = a] === e ? t / (i - 1) : (t + (e - (o = n[t])) / (n[t + 1] - o)) / (i - 1)
        },
        getTangent: function(t) {
            var e = t - 1e-4;
            return 1 < (t += 1e-4) && (t = 1),
            e = this.getPoint(e = e < 0 ? 0 : e),
            this.getPoint(t).clone().sub(e).normalize()
        },
        getTangentAt: function(t) {
            return t = this.getUtoTmapping(t),
            this.getTangent(t)
        },
        computeFrenetFrames: function(t, e) {
            for (var n = new wt, i = [], r = [], o = [], a = new wt, s = new _t, c = 0; c <= t; c++) {
                var h = c / t;
                i[c] = this.getTangentAt(h),
                i[c].normalize()
            }
            r[0] = new wt,
            o[0] = new wt,
            c = Number.MAX_VALUE;
            var h = Math.abs(i[0].x)
              , l = Math.abs(i[0].y)
              , u = Math.abs(i[0].z);
            for (h <= c && (c = h,
            n.set(1, 0, 0)),
            l <= c && (c = l,
            n.set(0, 1, 0)),
            u <= c && n.set(0, 0, 1),
            a.crossVectors(i[0], n).normalize(),
            r[0].crossVectors(i[0], a),
            o[0].crossVectors(i[0], r[0]),
            c = 1; c <= t; c++)
                r[c] = r[c - 1].clone(),
                o[c] = o[c - 1].clone(),
                a.crossVectors(i[c - 1], i[c]),
                a.length() > Number.EPSILON && (a.normalize(),
                n = Math.acos(io.clamp(i[c - 1].dot(i[c]), -1, 1)),
                r[c].applyMatrix4(s.makeRotationAxis(a, n))),
                o[c].crossVectors(i[c], r[c]);
            if (!0 === e)
                for (n = Math.acos(io.clamp(r[0].dot(r[t]), -1, 1)),
                n /= t,
                0 < i[0].dot(a.crossVectors(r[0], r[t])) && (n = -n),
                c = 1; c <= t; c++)
                    r[c].applyMatrix4(s.makeRotationAxis(i[c], n * c)),
                    o[c].crossVectors(i[c], r[c]);
            return {
                tangents: i,
                normals: r,
                binormals: o
            }
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.arcLengthDivisions = t.arcLengthDivisions,
            this
        },
        toJSON: function() {
            var t = {
                metadata: {
                    version: 4.5,
                    type: "Curve",
                    generator: "Curve.toJSON"
                }
            };
            return t.arcLengthDivisions = this.arcLengthDivisions,
            t.type = this.type,
            t
        },
        fromJSON: function(t) {
            return this.arcLengthDivisions = t.arcLengthDivisions,
            this
        }
    }),
    ((Jn.prototype = Object.create(Zn.prototype)).constructor = Jn).prototype.isEllipseCurve = !0,
    Jn.prototype.getPoint = function(t, e) {
        e = e || new W;
        for (var n = 2 * Math.PI, i = this.aEndAngle - this.aStartAngle, r = Math.abs(i) < Number.EPSILON; i < 0; )
            i += n;
        for (; n < i; )
            i -= n;
        i < Number.EPSILON && (i = r ? 0 : n),
        !0 !== this.aClockwise || r || (i = i === n ? -n : i - n),
        n = this.aStartAngle + t * i,
        t = this.aX + this.xRadius * Math.cos(n);
        var o = this.aY + this.yRadius * Math.sin(n);
        return 0 !== this.aRotation && (n = Math.cos(this.aRotation),
        i = Math.sin(this.aRotation),
        t = (r = t - this.aX) * n - (o -= this.aY) * i + this.aX,
        o = r * i + o * n + this.aY),
        e.set(t, o)
    }
    ,
    Jn.prototype.copy = function(t) {
        return Zn.prototype.copy.call(this, t),
        this.aX = t.aX,
        this.aY = t.aY,
        this.xRadius = t.xRadius,
        this.yRadius = t.yRadius,
        this.aStartAngle = t.aStartAngle,
        this.aEndAngle = t.aEndAngle,
        this.aClockwise = t.aClockwise,
        this.aRotation = t.aRotation,
        this
    }
    ,
    Jn.prototype.toJSON = function() {
        var t = Zn.prototype.toJSON.call(this);
        return t.aX = this.aX,
        t.aY = this.aY,
        t.xRadius = this.xRadius,
        t.yRadius = this.yRadius,
        t.aStartAngle = this.aStartAngle,
        t.aEndAngle = this.aEndAngle,
        t.aClockwise = this.aClockwise,
        t.aRotation = this.aRotation,
        t
    }
    ,
    Jn.prototype.fromJSON = function(t) {
        return Zn.prototype.fromJSON.call(this, t),
        this.aX = t.aX,
        this.aY = t.aY,
        this.xRadius = t.xRadius,
        this.yRadius = t.yRadius,
        this.aStartAngle = t.aStartAngle,
        this.aEndAngle = t.aEndAngle,
        this.aClockwise = t.aClockwise,
        this.aRotation = t.aRotation,
        this
    }
    ,
    ((Qn.prototype = Object.create(Jn.prototype)).constructor = Qn).prototype.isArcCurve = !0;
    var nc = new wt
      , ic = new Kn
      , rc = new Kn
      , oc = new Kn;
    (($n.prototype = Object.create(Zn.prototype)).constructor = $n).prototype.isCatmullRomCurve3 = !0,
    $n.prototype.getPoint = function(t, e) {
        e = e || new wt;
        var n = (c = this.points).length;
        t *= n - (this.closed ? 0 : 1);
        var i = Math.floor(t);
        t -= i,
        this.closed ? i += 0 < i ? 0 : (Math.floor(Math.abs(i) / n) + 1) * n : 0 === t && i === n - 1 && (i = n - 2,
        t = 1);
        var r, o = this.closed || 0 < i ? c[(i - 1) % n] : (nc.subVectors(c[0], c[1]).add(c[0]),
        nc), a = c[i % n], s = c[(i + 1) % n], c = this.closed || i + 2 < n ? c[(i + 2) % n] : (nc.subVectors(c[n - 1], c[n - 2]).add(c[n - 1]),
        nc);
        return "centripetal" === this.curveType || "chordal" === this.curveType ? (r = "chordal" === this.curveType ? .5 : .25,
        n = Math.pow(o.distanceToSquared(a), r),
        (i = Math.pow(a.distanceToSquared(s), r)) < 1e-4 && (i = 1),
        n < 1e-4 && (n = i),
        (r = Math.pow(s.distanceToSquared(c), r)) < 1e-4 && (r = i),
        ic.initNonuniformCatmullRom(o.x, a.x, s.x, c.x, n, i, r),
        rc.initNonuniformCatmullRom(o.y, a.y, s.y, c.y, n, i, r),
        oc.initNonuniformCatmullRom(o.z, a.z, s.z, c.z, n, i, r)) : "catmullrom" === this.curveType && (ic.initCatmullRom(o.x, a.x, s.x, c.x, this.tension),
        rc.initCatmullRom(o.y, a.y, s.y, c.y, this.tension),
        oc.initCatmullRom(o.z, a.z, s.z, c.z, this.tension)),
        e.set(ic.calc(t), rc.calc(t), oc.calc(t)),
        e
    }
    ,
    $n.prototype.copy = function(t) {
        Zn.prototype.copy.call(this, t),
        this.points = [];
        for (var e = 0, n = t.points.length; e < n; e++)
            this.points.push(t.points[e].clone());
        return this.closed = t.closed,
        this.curveType = t.curveType,
        this.tension = t.tension,
        this
    }
    ,
    $n.prototype.toJSON = function() {
        var t = Zn.prototype.toJSON.call(this);
        t.points = [];
        for (var e = 0, n = this.points.length; e < n; e++)
            t.points.push(this.points[e].toArray());
        return t.closed = this.closed,
        t.curveType = this.curveType,
        t.tension = this.tension,
        t
    }
    ,
    $n.prototype.fromJSON = function(t) {
        Zn.prototype.fromJSON.call(this, t),
        this.points = [];
        for (var e = 0, n = t.points.length; e < n; e++) {
            var i = t.points[e];
            this.points.push((new wt).fromArray(i))
        }
        return this.closed = t.closed,
        this.curveType = t.curveType,
        this.tension = t.tension,
        this
    }
    ,
    ((ii.prototype = Object.create(Zn.prototype)).constructor = ii).prototype.isCubicBezierCurve = !0,
    ii.prototype.getPoint = function(t, e) {
        e = e || new W;
        var n = this.v0
          , i = this.v1
          , r = this.v2
          , o = this.v3;
        return e.set(ni(t, n.x, i.x, r.x, o.x), ni(t, n.y, i.y, r.y, o.y)),
        e
    }
    ,
    ii.prototype.copy = function(t) {
        return Zn.prototype.copy.call(this, t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this.v3.copy(t.v3),
        this
    }
    ,
    ii.prototype.toJSON = function() {
        var t = Zn.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(),
        t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t.v3 = this.v3.toArray(),
        t
    }
    ,
    ii.prototype.fromJSON = function(t) {
        return Zn.prototype.fromJSON.call(this, t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this.v3.fromArray(t.v3),
        this
    }
    ,
    ((ri.prototype = Object.create(Zn.prototype)).constructor = ri).prototype.isCubicBezierCurve3 = !0,
    ri.prototype.getPoint = function(t, e) {
        e = e || new wt;
        var n = this.v0
          , i = this.v1
          , r = this.v2
          , o = this.v3;
        return e.set(ni(t, n.x, i.x, r.x, o.x), ni(t, n.y, i.y, r.y, o.y), ni(t, n.z, i.z, r.z, o.z)),
        e
    }
    ,
    ri.prototype.copy = function(t) {
        return Zn.prototype.copy.call(this, t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this.v3.copy(t.v3),
        this
    }
    ,
    ri.prototype.toJSON = function() {
        var t = Zn.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(),
        t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t.v3 = this.v3.toArray(),
        t
    }
    ,
    ri.prototype.fromJSON = function(t) {
        return Zn.prototype.fromJSON.call(this, t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this.v3.fromArray(t.v3),
        this
    }
    ,
    ((oi.prototype = Object.create(Zn.prototype)).constructor = oi).prototype.isLineCurve = !0,
    oi.prototype.getPoint = function(t, e) {
        return e = e || new W,
        1 === t ? e.copy(this.v2) : (e.copy(this.v2).sub(this.v1),
        e.multiplyScalar(t).add(this.v1)),
        e
    }
    ,
    oi.prototype.getPointAt = function(t, e) {
        return this.getPoint(t, e)
    }
    ,
    oi.prototype.getTangent = function() {
        return this.v2.clone().sub(this.v1).normalize()
    }
    ,
    oi.prototype.copy = function(t) {
        return Zn.prototype.copy.call(this, t),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
    }
    ,
    oi.prototype.toJSON = function() {
        var t = Zn.prototype.toJSON.call(this);
        return t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t
    }
    ,
    oi.prototype.fromJSON = function(t) {
        return Zn.prototype.fromJSON.call(this, t),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
    }
    ,
    ((ai.prototype = Object.create(Zn.prototype)).constructor = ai).prototype.isLineCurve3 = !0,
    ai.prototype.getPoint = function(t, e) {
        return e = e || new wt,
        1 === t ? e.copy(this.v2) : (e.copy(this.v2).sub(this.v1),
        e.multiplyScalar(t).add(this.v1)),
        e
    }
    ,
    ai.prototype.getPointAt = function(t, e) {
        return this.getPoint(t, e)
    }
    ,
    ai.prototype.copy = function(t) {
        return Zn.prototype.copy.call(this, t),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
    }
    ,
    ai.prototype.toJSON = function() {
        var t = Zn.prototype.toJSON.call(this);
        return t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t
    }
    ,
    ai.prototype.fromJSON = function(t) {
        return Zn.prototype.fromJSON.call(this, t),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
    }
    ,
    ((si.prototype = Object.create(Zn.prototype)).constructor = si).prototype.isQuadraticBezierCurve = !0,
    si.prototype.getPoint = function(t, e) {
        e = e || new W;
        var n = this.v0
          , i = this.v1
          , r = this.v2;
        return e.set(ei(t, n.x, i.x, r.x), ei(t, n.y, i.y, r.y)),
        e
    }
    ,
    si.prototype.copy = function(t) {
        return Zn.prototype.copy.call(this, t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
    }
    ,
    si.prototype.toJSON = function() {
        var t = Zn.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(),
        t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t
    }
    ,
    si.prototype.fromJSON = function(t) {
        return Zn.prototype.fromJSON.call(this, t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
    }
    ,
    ((ci.prototype = Object.create(Zn.prototype)).constructor = ci).prototype.isQuadraticBezierCurve3 = !0,
    ci.prototype.getPoint = function(t, e) {
        e = e || new wt;
        var n = this.v0
          , i = this.v1
          , r = this.v2;
        return e.set(ei(t, n.x, i.x, r.x), ei(t, n.y, i.y, r.y), ei(t, n.z, i.z, r.z)),
        e
    }
    ,
    ci.prototype.copy = function(t) {
        return Zn.prototype.copy.call(this, t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
    }
    ,
    ci.prototype.toJSON = function() {
        var t = Zn.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(),
        t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t
    }
    ,
    ci.prototype.fromJSON = function(t) {
        return Zn.prototype.fromJSON.call(this, t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
    }
    ,
    ((hi.prototype = Object.create(Zn.prototype)).constructor = hi).prototype.isSplineCurve = !0,
    hi.prototype.getPoint = function(t, e) {
        e = e || new W;
        var n = ((a = this.points).length - 1) * t
          , i = a[0 === (t = Math.floor(n)) ? t : t - 1]
          , r = a[t]
          , o = a[t > a.length - 2 ? a.length - 1 : t + 1]
          , a = a[t > a.length - 3 ? a.length - 1 : t + 2];
        return e.set(ti(n -= t, i.x, r.x, o.x, a.x), ti(n, i.y, r.y, o.y, a.y)),
        e
    }
    ,
    hi.prototype.copy = function(t) {
        Zn.prototype.copy.call(this, t),
        this.points = [];
        for (var e = 0, n = t.points.length; e < n; e++)
            this.points.push(t.points[e].clone());
        return this
    }
    ,
    hi.prototype.toJSON = function() {
        var t = Zn.prototype.toJSON.call(this);
        t.points = [];
        for (var e = 0, n = this.points.length; e < n; e++)
            t.points.push(this.points[e].toArray());
        return t
    }
    ,
    hi.prototype.fromJSON = function(t) {
        Zn.prototype.fromJSON.call(this, t),
        this.points = [];
        for (var e = 0, n = t.points.length; e < n; e++) {
            var i = t.points[e];
            this.points.push((new W).fromArray(i))
        }
        return this
    }
    ;
    var ac = Object.freeze({
        ArcCurve: Qn,
        CatmullRomCurve3: $n,
        CubicBezierCurve: ii,
        CubicBezierCurve3: ri,
        EllipseCurve: Jn,
        LineCurve: oi,
        LineCurve3: ai,
        QuadraticBezierCurve: si,
        QuadraticBezierCurve3: ci,
        SplineCurve: hi
    });
    li.prototype = Object.assign(Object.create(Zn.prototype), {
        constructor: li,
        add: function(t) {
            this.curves.push(t)
        },
        closePath: function() {
            var t = this.curves[0].getPoint(0)
              , e = this.curves[this.curves.length - 1].getPoint(1);
            t.equals(e) || this.curves.push(new oi(e,t))
        },
        getPoint: function(t) {
            var e = t * this.getLength()
              , n = this.getCurveLengths();
            for (t = 0; t < n.length; ) {
                if (n[t] >= e)
                    return e = n[t] - e,
                    n = (t = this.curves[t]).getLength(),
                    t.getPointAt(0 === n ? 0 : 1 - e / n);
                t++
            }
            return null
        },
        getLength: function() {
            var t = this.getCurveLengths();
            return t[t.length - 1]
        },
        updateArcLengths: function() {
            this.needsUpdate = !0,
            this.cacheLengths = null,
            this.getCurveLengths()
        },
        getCurveLengths: function() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                return this.cacheLengths;
            for (var t = [], e = 0, n = 0, i = this.curves.length; n < i; n++)
                e += this.curves[n].getLength(),
                t.push(e);
            return this.cacheLengths = t
        },
        getSpacedPoints: function(t) {
            void 0 === t && (t = 40);
            for (var e = [], n = 0; n <= t; n++)
                e.push(this.getPoint(n / t));
            return this.autoClose && e.push(e[0]),
            e
        },
        getPoints: function(t) {
            t = t || 12;
            for (var e, n = [], i = 0, r = this.curves; i < r.length; i++)
                for (var o = (o = r[i]).getPoints(o && o.isEllipseCurve ? 2 * t : o && o.isLineCurve ? 1 : o && o.isSplineCurve ? t * o.points.length : t), a = 0; a < o.length; a++) {
                    var s = o[a];
                    e && e.equals(s) || (n.push(s),
                    e = s)
                }
            return this.autoClose && 1 < n.length && !n[n.length - 1].equals(n[0]) && n.push(n[0]),
            n
        },
        copy: function(t) {
            Zn.prototype.copy.call(this, t),
            this.curves = [];
            for (var e = 0, n = t.curves.length; e < n; e++)
                this.curves.push(t.curves[e].clone());
            return this.autoClose = t.autoClose,
            this
        },
        toJSON: function() {
            var t = Zn.prototype.toJSON.call(this);
            t.autoClose = this.autoClose,
            t.curves = [];
            for (var e = 0, n = this.curves.length; e < n; e++)
                t.curves.push(this.curves[e].toJSON());
            return t
        },
        fromJSON: function(t) {
            Zn.prototype.fromJSON.call(this, t),
            this.autoClose = t.autoClose,
            this.curves = [];
            for (var e = 0, n = t.curves.length; e < n; e++) {
                var i = t.curves[e];
                this.curves.push((new ac[i.type]).fromJSON(i))
            }
            return this
        }
    }),
    ui.prototype = Object.assign(Object.create(li.prototype), {
        constructor: ui,
        setFromPoints: function(t) {
            this.moveTo(t[0].x, t[0].y);
            for (var e = 1, n = t.length; e < n; e++)
                this.lineTo(t[e].x, t[e].y)
        },
        moveTo: function(t, e) {
            this.currentPoint.set(t, e)
        },
        lineTo: function(t, e) {
            var n = new oi(this.currentPoint.clone(),new W(t,e));
            this.curves.push(n),
            this.currentPoint.set(t, e)
        },
        quadraticCurveTo: function(t, e, n, i) {
            t = new si(this.currentPoint.clone(),new W(t,e),new W(n,i)),
            this.curves.push(t),
            this.currentPoint.set(n, i)
        },
        bezierCurveTo: function(t, e, n, i, r, o) {
            t = new ii(this.currentPoint.clone(),new W(t,e),new W(n,i),new W(r,o)),
            this.curves.push(t),
            this.currentPoint.set(r, o)
        },
        splineThru: function(t) {
            var e = new hi(e = [this.currentPoint.clone()].concat(t));
            this.curves.push(e),
            this.currentPoint.copy(t[t.length - 1])
        },
        arc: function(t, e, n, i, r, o) {
            this.absarc(t + this.currentPoint.x, e + this.currentPoint.y, n, i, r, o)
        },
        absarc: function(t, e, n, i, r, o) {
            this.absellipse(t, e, n, n, i, r, o)
        },
        ellipse: function(t, e, n, i, r, o, a, s) {
            this.absellipse(t + this.currentPoint.x, e + this.currentPoint.y, n, i, r, o, a, s)
        },
        absellipse: function(t, e, n, i, r, o, a, s) {
            t = new Jn(t,e,n,i,r,o,a,s),
            0 < this.curves.length && ((e = t.getPoint(0)).equals(this.currentPoint) || this.lineTo(e.x, e.y)),
            this.curves.push(t),
            t = t.getPoint(1),
            this.currentPoint.copy(t)
        },
        copy: function(t) {
            return li.prototype.copy.call(this, t),
            this.currentPoint.copy(t.currentPoint),
            this
        },
        toJSON: function() {
            var t = li.prototype.toJSON.call(this);
            return t.currentPoint = this.currentPoint.toArray(),
            t
        },
        fromJSON: function(t) {
            return li.prototype.fromJSON.call(this, t),
            this.currentPoint.fromArray(t.currentPoint),
            this
        }
    }),
    di.prototype = Object.assign(Object.create(ui.prototype), {
        constructor: di,
        getPointsHoles: function(t) {
            for (var e = [], n = 0, i = this.holes.length; n < i; n++)
                e[n] = this.holes[n].getPoints(t);
            return e
        },
        extractPoints: function(t) {
            return {
                shape: this.getPoints(t),
                holes: this.getPointsHoles(t)
            }
        },
        copy: function(t) {
            ui.prototype.copy.call(this, t),
            this.holes = [];
            for (var e = 0, n = t.holes.length; e < n; e++)
                this.holes.push(t.holes[e].clone());
            return this
        },
        toJSON: function() {
            var t = ui.prototype.toJSON.call(this);
            t.uuid = this.uuid,
            t.holes = [];
            for (var e = 0, n = this.holes.length; e < n; e++)
                t.holes.push(this.holes[e].toJSON());
            return t
        },
        fromJSON: function(t) {
            ui.prototype.fromJSON.call(this, t),
            this.uuid = t.uuid,
            this.holes = [];
            for (var e = 0, n = t.holes.length; e < n; e++) {
                var i = t.holes[e];
                this.holes.push((new ui).fromJSON(i))
            }
            return this
        }
    }),
    pi.prototype = Object.assign(Object.create(l.prototype), {
        constructor: pi,
        isLight: !0,
        copy: function(t) {
            return l.prototype.copy.call(this, t),
            this.color.copy(t.color),
            this.intensity = t.intensity,
            this
        },
        toJSON: function(t) {
            return (t = l.prototype.toJSON.call(this, t)).object.color = this.color.getHex(),
            t.object.intensity = this.intensity,
            void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (t.object.distance = this.distance),
            void 0 !== this.angle && (t.object.angle = this.angle),
            void 0 !== this.decay && (t.object.decay = this.decay),
            void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
            t
        }
    }),
    fi.prototype = Object.assign(Object.create(pi.prototype), {
        constructor: fi,
        isHemisphereLight: !0,
        copy: function(t) {
            return pi.prototype.copy.call(this, t),
            this.groundColor.copy(t.groundColor),
            this
        }
    }),
    Object.assign(mi.prototype, {
        copy: function(t) {
            return this.camera = t.camera.clone(),
            this.bias = t.bias,
            this.radius = t.radius,
            this.mapSize.copy(t.mapSize),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            var t = {};
            return 0 !== this.bias && (t.bias = this.bias),
            1 !== this.radius && (t.radius = this.radius),
            512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()),
            t.camera = this.camera.toJSON(!1).object,
            delete t.camera.matrix,
            t
        }
    }),
    gi.prototype = Object.assign(Object.create(mi.prototype), {
        constructor: gi,
        isSpotLightShadow: !0,
        update: function(t) {
            var e = this.camera
              , n = 2 * io.RAD2DEG * t.angle
              , i = this.mapSize.width / this.mapSize.height;
            t = t.distance || e.far,
            n === e.fov && i === e.aspect && t === e.far || (e.fov = n,
            e.aspect = i,
            e.far = t,
            e.updateProjectionMatrix())
        }
    }),
    vi.prototype = Object.assign(Object.create(pi.prototype), {
        constructor: vi,
        isSpotLight: !0,
        copy: function(t) {
            return pi.prototype.copy.call(this, t),
            this.distance = t.distance,
            this.angle = t.angle,
            this.penumbra = t.penumbra,
            this.decay = t.decay,
            this.target = t.target.clone(),
            this.shadow = t.shadow.clone(),
            this
        }
    }),
    yi.prototype = Object.assign(Object.create(pi.prototype), {
        constructor: yi,
        isPointLight: !0,
        copy: function(t) {
            return pi.prototype.copy.call(this, t),
            this.distance = t.distance,
            this.decay = t.decay,
            this.shadow = t.shadow.clone(),
            this
        }
    }),
    xi.prototype = Object.assign(Object.create(mi.prototype), {
        constructor: xi
    }),
    bi.prototype = Object.assign(Object.create(pi.prototype), {
        constructor: bi,
        isDirectionalLight: !0,
        copy: function(t) {
            return pi.prototype.copy.call(this, t),
            this.target = t.target.clone(),
            this.shadow = t.shadow.clone(),
            this
        }
    }),
    _i.prototype = Object.assign(Object.create(pi.prototype), {
        constructor: _i,
        isAmbientLight: !0
    }),
    wi.prototype = Object.assign(Object.create(pi.prototype), {
        constructor: wi,
        isRectAreaLight: !0,
        copy: function(t) {
            return pi.prototype.copy.call(this, t),
            this.width = t.width,
            this.height = t.height,
            this
        },
        toJSON: function(t) {
            return (t = pi.prototype.toJSON.call(this, t)).object.width = this.width,
            t.object.height = this.height,
            t
        }
    }),
    Ei.prototype = Object.assign(Object.create(Oi.prototype), {
        constructor: Ei,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }),
    Mi.prototype = Object.assign(Object.create(Oi.prototype), {
        constructor: Mi,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }),
    Object.assign(Ti.prototype, {
        evaluate: function(t) {
            var e = this.parameterPositions
              , n = this._cachedIndex
              , i = e[n]
              , r = e[n - 1];
            t: {
                e: {
                    n: {
                        i: if (!(t < i)) {
                            for (var o = n + 2; ; ) {
                                if (void 0 === i) {
                                    if (t < r)
                                        break i;
                                    return this._cachedIndex = n = e.length,
                                    this.afterEnd_(n - 1, t, r)
                                }
                                if (n === o)
                                    break;
                                if (r = i,
                                t < (i = e[++n]))
                                    break e
                            }
                            i = e.length;
                            break n
                        }
                        if (r <= t)
                            break t;
                        for (t < (o = e[1]) && (n = 2,
                        r = o),
                        o = n - 2; ; ) {
                            if (void 0 === r)
                                return this._cachedIndex = 0,
                                this.beforeStart_(0, t, i);
                            if (n === o)
                                break;
                            if (i = r,
                            (r = e[--n - 1]) <= t)
                                break e
                        }
                        i = n,
                        n = 0
                    }
                    for (; n < i; )
                        t < e[r = n + i >>> 1] ? i = r : n = r + 1;
                    if (i = e[n],
                    void 0 === (r = e[n - 1]))
                        return this._cachedIndex = 0,
                        this.beforeStart_(0, t, i);
                    if (void 0 === i)
                        return this._cachedIndex = n = e.length,
                        this.afterEnd_(n - 1, r, t)
                }
                this._cachedIndex = n,
                this.intervalChanged_(n, r, i)
            }
            return this.interpolate_(n, r, t, i)
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function() {
            return this.settings || this.DefaultSettings_
        },
        copySampleValue_: function(t) {
            var e = this.resultBuffer
              , n = this.sampleValues
              , i = this.valueSize;
            t *= i;
            for (var r = 0; r !== i; ++r)
                e[r] = n[t + r];
            return e
        },
        interpolate_: function() {
            throw Error("call to abstract method")
        },
        intervalChanged_: function() {}
    }),
    Object.assign(Ti.prototype, {
        beforeStart_: Ti.prototype.copySampleValue_,
        afterEnd_: Ti.prototype.copySampleValue_
    }),
    Si.prototype = Object.assign(Object.create(Ti.prototype), {
        constructor: Si,
        interpolate_: function(t, e, n, i) {
            var r = this.resultBuffer
              , o = this.sampleValues
              , a = this.valueSize;
            for (e = (n - e) / (i - e),
            n = (t *= a) + a; t !== n; t += 4)
                V.slerpFlat(r, 0, o, t - a, o, t, e);
            return r
        }
    }),
    Ai.prototype = Object.assign(Object.create(Oi.prototype), {
        constructor: Ai,
        ValueTypeName: "quaternion",
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodLinear: function(t) {
            return new Si(this.times,this.values,this.getValueSize(),t)
        },
        InterpolantFactoryMethodSmooth: void 0
    }),
    Ri.prototype = Object.assign(Object.create(Oi.prototype), {
        constructor: Ri,
        ValueTypeName: "color"
    }),
    Li.prototype = Object.assign(Object.create(Oi.prototype), {
        constructor: Li,
        ValueTypeName: "number"
    }),
    Ci.prototype = Object.assign(Object.create(Ti.prototype), {
        constructor: Ci,
        DefaultSettings_: {
            endingStart: 2400,
            endingEnd: 2400
        },
        intervalChanged_: function(t, e, n) {
            var i = this.parameterPositions
              , r = t - 2
              , o = t + 1
              , a = i[r]
              , s = i[o];
            if (void 0 === a)
                switch (this.getSettings_().endingStart) {
                case 2401:
                    r = t,
                    a = 2 * e - n;
                    break;
                case 2402:
                    a = e + i[r = i.length - 2] - i[r + 1];
                    break;
                default:
                    r = t,
                    a = n
                }
            if (void 0 === s)
                switch (this.getSettings_().endingEnd) {
                case 2401:
                    o = t,
                    s = 2 * n - e;
                    break;
                case 2402:
                    s = n + i[o = 1] - i[0];
                    break;
                default:
                    o = t - 1,
                    s = e
                }
            i = this.valueSize,
            this._weightPrev = (t = .5 * (n - e)) / (e - a),
            this._weightNext = t / (s - n),
            this._offsetPrev = r * i,
            this._offsetNext = o * i
        },
        interpolate_: function(t, e, n, i) {
            var r = this.resultBuffer
              , o = this.sampleValues
              , a = this.valueSize
              , s = (t *= a) - a
              , c = this._offsetPrev
              , h = this._offsetNext
              , l = this._weightPrev
              , u = this._weightNext
              , d = (n - e) / (i - e);
            for (e = -l * (i = (n = d * d) * d) + 2 * l * n - l * d,
            l = (1 + l) * i + (-1.5 - 2 * l) * n + (-.5 + l) * d + 1,
            d = (-1 - u) * i + (1.5 + u) * n + .5 * d,
            u = u * i - u * n,
            n = 0; n !== a; ++n)
                r[n] = e * o[c + n] + l * o[s + n] + d * o[t + n] + u * o[h + n];
            return r
        }
    }),
    Pi.prototype = Object.assign(Object.create(Ti.prototype), {
        constructor: Pi,
        interpolate_: function(t, e, n, i) {
            var r = this.resultBuffer
              , o = this.sampleValues
              , a = this.valueSize
              , s = (t *= a) - a;
            for (n = 1 - (e = (n - e) / (i - e)),
            i = 0; i !== a; ++i)
                r[i] = o[s + i] * n + o[t + i] * e;
            return r
        }
    }),
    Ni.prototype = Object.assign(Object.create(Ti.prototype), {
        constructor: Ni,
        interpolate_: function(t) {
            return this.copySampleValue_(t - 1)
        }
    });
    var sc = {
        arraySlice: function(t, e, n) {
            return sc.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
        },
        convertArray: function(t, e, n) {
            return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
        },
        isTypedArray: function(t) {
            return ArrayBuffer.isView(t) && !(t instanceof DataView)
        },
        getKeyframeOrder: function(n) {
            for (var t = n.length, e = Array(t), i = 0; i !== t; ++i)
                e[i] = i;
            return e.sort(function(t, e) {
                return n[t] - n[e]
            }),
            e
        },
        sortedArray: function(t, e, n) {
            for (var i = t.length, r = new t.constructor(i), o = 0, a = 0; a !== i; ++o)
                for (var s = n[o] * e, c = 0; c !== e; ++c)
                    r[a++] = t[s + c];
            return r
        },
        flattenJSON: function(t, e, n, i) {
            for (var r = 1, o = t[0]; void 0 !== o && void 0 === o[i]; )
                o = t[r++];
            if (void 0 !== o) {
                var a = o[i];
                if (void 0 !== a)
                    if (Array.isArray(a))
                        for (; void 0 !== (a = o[i]) && (e.push(o.time),
                        n.push.apply(n, a)),
                        void 0 !== (o = t[r++]); )
                            ;
                    else if (void 0 !== a.toArray)
                        for (; void 0 !== (a = o[i]) && (e.push(o.time),
                        a.toArray(n, n.length)),
                        void 0 !== (o = t[r++]); )
                            ;
                    else
                        for (; void 0 !== (a = o[i]) && (e.push(o.time),
                        n.push(a)),
                        void 0 !== (o = t[r++]); )
                            ;
            }
        }
    };
    Object.assign(Oi, {
        parse: function(t) {
            if (void 0 === t.type)
                throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
            var e, n, i = Oi._getTrackTypeForValueTypeName(t.type);
            return void 0 === t.times && (sc.flattenJSON(t.keys, e = [], n = [], "value"),
            t.times = e,
            t.values = n),
            void 0 !== i.parse ? i.parse(t) : new i(t.name,t.times,t.values,t.interpolation)
        },
        toJSON: function(t) {
            var e, n = t.constructor;
            return void 0 !== n.toJSON ? n = n.toJSON(t) : (n = {
                name: t.name,
                times: sc.convertArray(t.times, Array),
                values: sc.convertArray(t.values, Array)
            },
            (e = t.getInterpolation()) !== t.DefaultInterpolation && (n.interpolation = e)),
            n.type = t.ValueTypeName,
            n
        },
        _getTrackTypeForValueTypeName: function(t) {
            switch (t.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
                return Li;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
                return Ii;
            case "color":
                return Ri;
            case "quaternion":
                return Ai;
            case "bool":
            case "boolean":
                return Mi;
            case "string":
                return Ei
            }
            throw Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
        }
    }),
    Object.assign(Oi.prototype, {
        constructor: Oi,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodDiscrete: function(t) {
            return new Ni(this.times,this.values,this.getValueSize(),t)
        },
        InterpolantFactoryMethodLinear: function(t) {
            return new Pi(this.times,this.values,this.getValueSize(),t)
        },
        InterpolantFactoryMethodSmooth: function(t) {
            return new Ci(this.times,this.values,this.getValueSize(),t)
        },
        setInterpolation: function(t) {
            switch (t) {
            case 2300:
                var e = this.InterpolantFactoryMethodDiscrete;
                break;
            case 2301:
                e = this.InterpolantFactoryMethodLinear;
                break;
            case 2302:
                e = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 === e) {
                if (e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name,
                void 0 === this.createInterpolant) {
                    if (t === this.DefaultInterpolation)
                        throw Error(e);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                console.warn("THREE.KeyframeTrack:", e)
            } else
                this.createInterpolant = e
        },
        getInterpolation: function() {
            switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
                return 2300;
            case this.InterpolantFactoryMethodLinear:
                return 2301;
            case this.InterpolantFactoryMethodSmooth:
                return 2302
            }
        },
        getValueSize: function() {
            return this.values.length / this.times.length
        },
        shift: function(t) {
            if (0 !== t)
                for (var e = this.times, n = 0, i = e.length; n !== i; ++n)
                    e[n] += t;
            return this
        },
        scale: function(t) {
            if (1 !== t)
                for (var e = this.times, n = 0, i = e.length; n !== i; ++n)
                    e[n] *= t;
            return this
        },
        trim: function(t, e) {
            for (var n = this.times, i = n.length, r = 0, o = i - 1; r !== i && n[r] < t; )
                ++r;
            for (; -1 !== o && n[o] > e; )
                --o;
            return ++o,
            0 === r && o === i || (o <= r && (r = (o = Math.max(o, 1)) - 1),
            t = this.getValueSize(),
            this.times = sc.arraySlice(n, r, o),
            this.values = sc.arraySlice(this.values, r * t, o * t)),
            this
        },
        validate: function() {
            var t = !0;
            0 != (n = this.getValueSize()) - Math.floor(n) && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
            t = !1);
            var e = this.times
              , n = this.values
              , i = e.length;
            0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this),
            t = !1);
            for (var r = null, o = 0; o !== i; o++) {
                var a = e[o];
                if ("number" == typeof a && isNaN(a)) {
                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, a),
                    t = !1;
                    break
                }
                if (null !== r && a < r) {
                    console.error("THREE.KeyframeTrack: Out of order keys.", this, o, a, r),
                    t = !1;
                    break
                }
                r = a
            }
            if (void 0 !== n && sc.isTypedArray(n))
                for (o = 0,
                e = n.length; o !== e; ++o)
                    if (i = n[o],
                    isNaN(i)) {
                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, i),
                        t = !1;
                        break
                    }
            return t
        },
        optimize: function() {
            for (var t = this.times, e = this.values, n = this.getValueSize(), i = 2302 === this.getInterpolation(), r = 1, o = t.length - 1, a = 1; a < o; ++a) {
                var s = !1;
                if ((u = t[a]) !== t[a + 1] && (1 !== a || u !== u[0]))
                    if (i)
                        s = !0;
                    else
                        for (var c = a * n, h = c - n, l = c + n, u = 0; u !== n; ++u) {
                            var d = e[c + u];
                            if (d !== e[h + u] || d !== e[l + u]) {
                                s = !0;
                                break
                            }
                        }
                if (s) {
                    if (a !== r)
                        for (t[r] = t[a],
                        s = a * n,
                        c = r * n,
                        u = 0; u !== n; ++u)
                            e[c + u] = e[s + u];
                    ++r
                }
            }
            if (0 < o) {
                for (t[r] = t[o],
                s = o * n,
                c = r * n,
                u = 0; u !== n; ++u)
                    e[c + u] = e[s + u];
                ++r
            }
            return r !== t.length && (this.times = sc.arraySlice(t, 0, r),
            this.values = sc.arraySlice(e, 0, r * n)),
            this
        }
    }),
    Ii.prototype = Object.assign(Object.create(Oi.prototype), {
        constructor: Ii,
        ValueTypeName: "vector"
    }),
    Object.assign(Bi, {
        parse: function(t) {
            for (var e = [], n = t.tracks, i = 1 / (t.fps || 1), r = 0, o = n.length; r !== o; ++r)
                e.push(Oi.parse(n[r]).scale(i));
            return new Bi(t.name,t.duration,e)
        },
        toJSON: function(t) {
            var e = []
              , n = t.tracks;
            t = {
                name: t.name,
                duration: t.duration,
                tracks: e
            };
            for (var i = 0, r = n.length; i !== r; ++i)
                e.push(Oi.toJSON(n[i]));
            return t
        },
        CreateFromMorphTargetSequence: function(t, e, n, i) {
            for (var r = e.length, o = [], a = 0; a < r; a++) {
                var s = [];
                (h = []).push((a + r - 1) % r, a, (a + 1) % r),
                s.push(0, 1, 0);
                var c = sc.getKeyframeOrder(h)
                  , h = sc.sortedArray(h, 1, c)
                  , s = sc.sortedArray(s, 1, c);
                i || 0 !== h[0] || (h.push(r),
                s.push(s[0])),
                o.push(new Li(".morphTargetInfluences[" + e[a].name + "]",h,s).scale(1 / n))
            }
            return new Bi(t,-1,o)
        },
        findByName: function(t, e) {
            var n = t;
            for (Array.isArray(t) || (n = t.geometry && t.geometry.animations || t.animations),
            t = 0; t < n.length; t++)
                if (n[t].name === e)
                    return n[t];
            return null
        },
        CreateClipsFromMorphTargetSequences: function(t, e, n) {
            for (var i = {}, r = /^([\w-]*?)([\d]+)$/, o = 0, a = t.length; o < a; o++) {
                var s, c = t[o], h = c.name.match(r);
                h && 1 < h.length && ((h = i[s = h[1]]) || (i[s] = h = []),
                h.push(c))
            }
            for (s in t = [],
            i)
                t.push(Bi.CreateFromMorphTargetSequence(s, i[s], e, n));
            return t
        },
        parseAnimation: function(t, e) {
            if (!t)
                return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                null;
            function n(t, e, n, i, r) {
                var o;
                0 !== n.length && (sc.flattenJSON(n, o = [], n = [], i),
                0 !== o.length && r.push(new t(e,o,n)))
            }
            var i = []
              , r = t.name || "default"
              , o = t.length || -1
              , a = t.fps || 30;
            t = t.hierarchy || [];
            for (var s = 0; s < t.length; s++) {
                var c = t[s].keys;
                if (c && 0 !== c.length)
                    if (c[0].morphTargets) {
                        for (var h, o = {}, l = 0; l < c.length; l++)
                            if (c[l].morphTargets)
                                for (var u = 0; u < c[l].morphTargets.length; u++)
                                    o[c[l].morphTargets[u]] = -1;
                        for (h in o) {
                            for (var d = [], p = [], u = 0; u !== c[l].morphTargets.length; ++u) {
                                var f = c[l];
                                d.push(f.time),
                                p.push(f.morphTarget === h ? 1 : 0)
                            }
                            i.push(new Li(".morphTargetInfluence[" + h + "]",d,p))
                        }
                        o = o.length * (a || 1)
                    } else
                        n(Ii, (l = ".bones[" + e[s].name + "]") + ".position", c, "pos", i),
                        n(Ai, l + ".quaternion", c, "rot", i),
                        n(Ii, l + ".scale", c, "scl", i)
            }
            return 0 === i.length ? null : new Bi(r,o,i)
        }
    }),
    Object.assign(Bi.prototype, {
        resetDuration: function() {
            for (var t = 0, e = 0, n = this.tracks.length; e !== n; ++e)
                var i = this.tracks[e]
                  , t = Math.max(t, i.times[i.times.length - 1]);
            this.duration = t
        },
        trim: function() {
            for (var t = 0; t < this.tracks.length; t++)
                this.tracks[t].trim(0, this.duration);
            return this
        },
        optimize: function() {
            for (var t = 0; t < this.tracks.length; t++)
                this.tracks[t].optimize();
            return this
        }
    }),
    Object.assign(Ui.prototype, {
        load: function(t, e, n, i) {
            var r = this;
            new Vn(r.manager).load(t, function(t) {
                e(r.parse(JSON.parse(t)))
            }, n, i)
        },
        setTextures: function(t) {
            this.textures = t
        },
        parse: function(t) {
            function e(t) {
                return void 0 === i[t] && console.warn("THREE.MaterialLoader: Undefined texture", t),
                i[t]
            }
            var n, i = this.textures, r = new Ks[t.type];
            return void 0 !== t.uuid && (r.uuid = t.uuid),
            void 0 !== t.name && (r.name = t.name),
            void 0 !== t.color && r.color.setHex(t.color),
            void 0 !== t.roughness && (r.roughness = t.roughness),
            void 0 !== t.metalness && (r.metalness = t.metalness),
            void 0 !== t.emissive && r.emissive.setHex(t.emissive),
            void 0 !== t.specular && r.specular.setHex(t.specular),
            void 0 !== t.shininess && (r.shininess = t.shininess),
            void 0 !== t.clearCoat && (r.clearCoat = t.clearCoat),
            void 0 !== t.clearCoatRoughness && (r.clearCoatRoughness = t.clearCoatRoughness),
            void 0 !== t.uniforms && (r.uniforms = t.uniforms),
            void 0 !== t.vertexShader && (r.vertexShader = t.vertexShader),
            void 0 !== t.fragmentShader && (r.fragmentShader = t.fragmentShader),
            void 0 !== t.vertexColors && (r.vertexColors = t.vertexColors),
            void 0 !== t.fog && (r.fog = t.fog),
            void 0 !== t.flatShading && (r.flatShading = t.flatShading),
            void 0 !== t.blending && (r.blending = t.blending),
            void 0 !== t.side && (r.side = t.side),
            void 0 !== t.opacity && (r.opacity = t.opacity),
            void 0 !== t.transparent && (r.transparent = t.transparent),
            void 0 !== t.alphaTest && (r.alphaTest = t.alphaTest),
            void 0 !== t.depthTest && (r.depthTest = t.depthTest),
            void 0 !== t.depthWrite && (r.depthWrite = t.depthWrite),
            void 0 !== t.colorWrite && (r.colorWrite = t.colorWrite),
            void 0 !== t.wireframe && (r.wireframe = t.wireframe),
            void 0 !== t.wireframeLinewidth && (r.wireframeLinewidth = t.wireframeLinewidth),
            void 0 !== t.wireframeLinecap && (r.wireframeLinecap = t.wireframeLinecap),
            void 0 !== t.wireframeLinejoin && (r.wireframeLinejoin = t.wireframeLinejoin),
            void 0 !== t.rotation && (r.rotation = t.rotation),
            1 !== t.linewidth && (r.linewidth = t.linewidth),
            void 0 !== t.dashSize && (r.dashSize = t.dashSize),
            void 0 !== t.gapSize && (r.gapSize = t.gapSize),
            void 0 !== t.scale && (r.scale = t.scale),
            void 0 !== t.polygonOffset && (r.polygonOffset = t.polygonOffset),
            void 0 !== t.polygonOffsetFactor && (r.polygonOffsetFactor = t.polygonOffsetFactor),
            void 0 !== t.polygonOffsetUnits && (r.polygonOffsetUnits = t.polygonOffsetUnits),
            void 0 !== t.skinning && (r.skinning = t.skinning),
            void 0 !== t.morphTargets && (r.morphTargets = t.morphTargets),
            void 0 !== t.dithering && (r.dithering = t.dithering),
            void 0 !== t.visible && (r.visible = t.visible),
            void 0 !== t.userData && (r.userData = t.userData),
            void 0 !== t.shading && (r.flatShading = 1 === t.shading),
            void 0 !== t.size && (r.size = t.size),
            void 0 !== t.sizeAttenuation && (r.sizeAttenuation = t.sizeAttenuation),
            void 0 !== t.map && (r.map = e(t.map)),
            void 0 !== t.alphaMap && (r.alphaMap = e(t.alphaMap),
            r.transparent = !0),
            void 0 !== t.bumpMap && (r.bumpMap = e(t.bumpMap)),
            void 0 !== t.bumpScale && (r.bumpScale = t.bumpScale),
            void 0 !== t.normalMap && (r.normalMap = e(t.normalMap)),
            void 0 !== t.normalScale && (n = t.normalScale,
            !1 === Array.isArray(n) && (n = [n, n]),
            r.normalScale = (new W).fromArray(n)),
            void 0 !== t.displacementMap && (r.displacementMap = e(t.displacementMap)),
            void 0 !== t.displacementScale && (r.displacementScale = t.displacementScale),
            void 0 !== t.displacementBias && (r.displacementBias = t.displacementBias),
            void 0 !== t.roughnessMap && (r.roughnessMap = e(t.roughnessMap)),
            void 0 !== t.metalnessMap && (r.metalnessMap = e(t.metalnessMap)),
            void 0 !== t.emissiveMap && (r.emissiveMap = e(t.emissiveMap)),
            void 0 !== t.emissiveIntensity && (r.emissiveIntensity = t.emissiveIntensity),
            void 0 !== t.specularMap && (r.specularMap = e(t.specularMap)),
            void 0 !== t.envMap && (r.envMap = e(t.envMap)),
            void 0 !== t.reflectivity && (r.reflectivity = t.reflectivity),
            void 0 !== t.lightMap && (r.lightMap = e(t.lightMap)),
            void 0 !== t.lightMapIntensity && (r.lightMapIntensity = t.lightMapIntensity),
            void 0 !== t.aoMap && (r.aoMap = e(t.aoMap)),
            void 0 !== t.aoMapIntensity && (r.aoMapIntensity = t.aoMapIntensity),
            void 0 !== t.gradientMap && (r.gradientMap = e(t.gradientMap)),
            r
        }
    }),
    Object.assign(Di.prototype, {
        load: function(t, e, n, i) {
            var r = this;
            new Vn(r.manager).load(t, function(t) {
                e(r.parse(JSON.parse(t)))
            }, n, i)
        },
        parse: function(t) {
            var e = new C;
            void 0 !== (r = t.data.index) && (r = new dc[r.type](r.array),
            e.setIndex(new y(r,1)));
            var n = t.data.attributes;
            for (o in n) {
                var i = n[o]
                  , r = new dc[i.type](i.array);
                e.addAttribute(o, new y(r,i.itemSize,i.normalized))
            }
            var o = t.data.groups || t.data.drawcalls || t.data.offsets;
            if (void 0 !== o)
                for (r = 0,
                n = o.length; r !== n; ++r)
                    i = o[r],
                    e.addGroup(i.start, i.count, i.materialIndex);
            return void 0 !== (t = t.data.boundingSphere) && (o = new wt,
            void 0 !== t.center && o.fromArray(t.center),
            e.boundingSphere = new a(o,t.radius)),
            e
        }
    });
    var cc, hc, lc, uc, dc = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };
    Fi.Handlers = {
        handlers: [],
        add: function(t, e) {
            this.handlers.push(t, e)
        },
        get: function(t) {
            for (var e = this.handlers, n = 0, i = e.length; n < i; n += 2) {
                var r = e[n + 1];
                if (e[n].test(t))
                    return r
            }
            return null
        }
    },
    Object.assign(Fi.prototype, {
        crossOrigin: void 0,
        onLoadStart: function() {},
        onLoadProgress: function() {},
        onLoadComplete: function() {},
        initMaterials: function(t, e, n) {
            for (var i = [], r = 0; r < t.length; ++r)
                i[r] = this.createMaterial(t[r], e, n);
            return i
        },
        createMaterial: (cc = {
            NoBlending: 0,
            NormalBlending: 1,
            AdditiveBlending: 2,
            SubtractiveBlending: 3,
            MultiplyBlending: 4,
            CustomBlending: 5
        },
        hc = new w,
        lc = new Yn,
        uc = new Ui,
        function(t, a, s) {
            function e(t, e, n, i, r) {
                var o = Fi.Handlers.get(t = a + t);
                return t = null !== o ? o.load(t) : (lc.setCrossOrigin(s),
                lc.load(t)),
                void 0 !== e && (t.repeat.fromArray(e),
                1 !== e[0] && (t.wrapS = 1e3),
                1 !== e[1] && (t.wrapT = 1e3)),
                void 0 !== n && t.offset.fromArray(n),
                void 0 !== i && ("repeat" === i[0] && (t.wrapS = 1e3),
                "mirror" === i[0] && (t.wrapS = 1002),
                "repeat" === i[1] && (t.wrapT = 1e3),
                "mirror" === i[1] && (t.wrapT = 1002)),
                void 0 !== r && (t.anisotropy = r),
                e = io.generateUUID(),
                c[e] = t,
                e
            }
            var n, c = {}, i = {
                uuid: io.generateUUID(),
                type: "MeshLambertMaterial"
            };
            for (n in t) {
                var r = t[n];
                switch (n) {
                case "DbgColor":
                case "DbgIndex":
                case "opticalDensity":
                case "illumination":
                    break;
                case "DbgName":
                    i.name = r;
                    break;
                case "blending":
                    i.blending = cc[r];
                    break;
                case "colorAmbient":
                case "mapAmbient":
                    console.warn("THREE.Loader.createMaterial:", n, "is no longer supported.");
                    break;
                case "colorDiffuse":
                    i.color = hc.fromArray(r).getHex();
                    break;
                case "colorSpecular":
                    i.specular = hc.fromArray(r).getHex();
                    break;
                case "colorEmissive":
                    i.emissive = hc.fromArray(r).getHex();
                    break;
                case "specularCoef":
                    i.shininess = r;
                    break;
                case "shading":
                    "basic" === r.toLowerCase() && (i.type = "MeshBasicMaterial"),
                    "phong" === r.toLowerCase() && (i.type = "MeshPhongMaterial"),
                    "standard" === r.toLowerCase() && (i.type = "MeshStandardMaterial");
                    break;
                case "mapDiffuse":
                    i.map = e(r, t.mapDiffuseRepeat, t.mapDiffuseOffset, t.mapDiffuseWrap, t.mapDiffuseAnisotropy);
                    break;
                case "mapDiffuseRepeat":
                case "mapDiffuseOffset":
                case "mapDiffuseWrap":
                case "mapDiffuseAnisotropy":
                    break;
                case "mapEmissive":
                    i.emissiveMap = e(r, t.mapEmissiveRepeat, t.mapEmissiveOffset, t.mapEmissiveWrap, t.mapEmissiveAnisotropy);
                    break;
                case "mapEmissiveRepeat":
                case "mapEmissiveOffset":
                case "mapEmissiveWrap":
                case "mapEmissiveAnisotropy":
                    break;
                case "mapLight":
                    i.lightMap = e(r, t.mapLightRepeat, t.mapLightOffset, t.mapLightWrap, t.mapLightAnisotropy);
                    break;
                case "mapLightRepeat":
                case "mapLightOffset":
                case "mapLightWrap":
                case "mapLightAnisotropy":
                    break;
                case "mapAO":
                    i.aoMap = e(r, t.mapAORepeat, t.mapAOOffset, t.mapAOWrap, t.mapAOAnisotropy);
                    break;
                case "mapAORepeat":
                case "mapAOOffset":
                case "mapAOWrap":
                case "mapAOAnisotropy":
                    break;
                case "mapBump":
                    i.bumpMap = e(r, t.mapBumpRepeat, t.mapBumpOffset, t.mapBumpWrap, t.mapBumpAnisotropy);
                    break;
                case "mapBumpScale":
                    i.bumpScale = r;
                    break;
                case "mapBumpRepeat":
                case "mapBumpOffset":
                case "mapBumpWrap":
                case "mapBumpAnisotropy":
                    break;
                case "mapNormal":
                    i.normalMap = e(r, t.mapNormalRepeat, t.mapNormalOffset, t.mapNormalWrap, t.mapNormalAnisotropy);
                    break;
                case "mapNormalFactor":
                    i.normalScale = r;
                    break;
                case "mapNormalRepeat":
                case "mapNormalOffset":
                case "mapNormalWrap":
                case "mapNormalAnisotropy":
                    break;
                case "mapSpecular":
                    i.specularMap = e(r, t.mapSpecularRepeat, t.mapSpecularOffset, t.mapSpecularWrap, t.mapSpecularAnisotropy);
                    break;
                case "mapSpecularRepeat":
                case "mapSpecularOffset":
                case "mapSpecularWrap":
                case "mapSpecularAnisotropy":
                    break;
                case "mapMetalness":
                    i.metalnessMap = e(r, t.mapMetalnessRepeat, t.mapMetalnessOffset, t.mapMetalnessWrap, t.mapMetalnessAnisotropy);
                    break;
                case "mapMetalnessRepeat":
                case "mapMetalnessOffset":
                case "mapMetalnessWrap":
                case "mapMetalnessAnisotropy":
                    break;
                case "mapRoughness":
                    i.roughnessMap = e(r, t.mapRoughnessRepeat, t.mapRoughnessOffset, t.mapRoughnessWrap, t.mapRoughnessAnisotropy);
                    break;
                case "mapRoughnessRepeat":
                case "mapRoughnessOffset":
                case "mapRoughnessWrap":
                case "mapRoughnessAnisotropy":
                    break;
                case "mapAlpha":
                    i.alphaMap = e(r, t.mapAlphaRepeat, t.mapAlphaOffset, t.mapAlphaWrap, t.mapAlphaAnisotropy);
                    break;
                case "mapAlphaRepeat":
                case "mapAlphaOffset":
                case "mapAlphaWrap":
                case "mapAlphaAnisotropy":
                    break;
                case "flipSided":
                    i.side = 1;
                    break;
                case "doubleSided":
                    i.side = 2;
                    break;
                case "transparency":
                    console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"),
                    i.opacity = r;
                    break;
                case "depthTest":
                case "depthWrite":
                case "colorWrite":
                case "opacity":
                case "reflectivity":
                case "transparent":
                case "visible":
                case "wireframe":
                    i[n] = r;
                    break;
                case "vertexColors":
                    !0 === r && (i.vertexColors = 2),
                    "face" === r && (i.vertexColors = 1);
                    break;
                default:
                    console.error("THREE.Loader.createMaterial: Unsupported", n, r)
                }
            }
            return "MeshBasicMaterial" === i.type && delete i.emissive,
            "MeshPhongMaterial" !== i.type && delete i.specular,
            i.opacity < 1 && (i.transparent = !0),
            uc.setTextures(c),
            uc.parse(i)
        }
        )
    });
    var pc = {
        decodeText: function(t) {
            if ("undefined" != typeof TextDecoder)
                return (new TextDecoder).decode(t);
            for (var e = "", n = 0, i = t.length; n < i; n++)
                e += String.fromCharCode(t[n]);
            return decodeURIComponent(escape(e))
        },
        extractUrlBase: function(t) {
            var e = t.lastIndexOf("/");
            return -1 === e ? "./" : t.substr(0, e + 1)
        }
    };
    Object.assign(zi.prototype, {
        load: function(n, i, t, e) {
            var r = this
              , o = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : pc.extractUrlBase(n)
              , a = new Vn(this.manager);
            a.setWithCredentials(this.withCredentials),
            a.load(n, function(t) {
                var e = (t = JSON.parse(t)).metadata;
                void 0 === e || (void 0 === (e = e.type) || "object" !== e.toLowerCase()) ? (t = r.parse(t, o),
                i(t.geometry, t.materials)) : console.error("THREE.JSONLoader: " + n + " should be loaded with THREE.ObjectLoader instead.")
            }, t, e)
        },
        setTexturePath: function(t) {
            this.texturePath = t
        },
        parse: function(t, e) {
            (t = void 0 !== t.data ? t.data : t).scale = void 0 !== t.scale ? 1 / t.scale : 1;
            var n, i = new M, r = t, o = r.faces, a = r.vertices, s = r.normals, c = r.colors, h = r.scale, l = 0;
            if (void 0 !== r.uvs) {
                for (m = 0; m < r.uvs.length; m++)
                    r.uvs[m].length && l++;
                for (m = 0; m < l; m++)
                    i.faceVertexUvs[m] = []
            }
            for (var u = 0, d = a.length; u < d; )
                (m = new wt).x = a[u++] * h,
                m.y = a[u++] * h,
                m.z = a[u++] * h,
                i.vertices.push(m);
            for (u = 0,
            d = o.length; u < d; ) {
                var p = 1 & (a = o[u++])
                  , f = 2 & a
                  , m = 8 & a
                  , g = 16 & a
                  , v = 32 & a
                  , h = 64 & a;
                if (a &= 128,
                p) {
                    (p = new E).a = o[u],
                    p.b = o[u + 1],
                    p.c = o[u + 3];
                    var y = new E;
                    if (y.a = o[u + 1],
                    y.b = o[u + 2],
                    y.c = o[u + 3],
                    u += 4,
                    f && (f = o[u++],
                    p.materialIndex = f,
                    y.materialIndex = f),
                    f = i.faces.length,
                    m)
                        for (m = 0; m < l; m++) {
                            var x = r.uvs[m];
                            for (i.faceVertexUvs[m][f] = [],
                            i.faceVertexUvs[m][f + 1] = [],
                            n = 0; n < 4; n++) {
                                var b = o[u++]
                                  , _ = new W(_ = x[2 * b],b = x[2 * b + 1]);
                                2 !== n && i.faceVertexUvs[m][f].push(_),
                                0 !== n && i.faceVertexUvs[m][f + 1].push(_)
                            }
                        }
                    if (g && (g = 3 * o[u++],
                    p.normal.set(s[g++], s[g++], s[g]),
                    y.normal.copy(p.normal)),
                    v)
                        for (m = 0; m < 4; m++)
                            g = 3 * o[u++],
                            v = new wt(s[g++],s[g++],s[g]),
                            2 !== m && p.vertexNormals.push(v),
                            0 !== m && y.vertexNormals.push(v);
                    if (h && (h = c[h = o[u++]],
                    p.color.setHex(h),
                    y.color.setHex(h)),
                    a)
                        for (m = 0; m < 4; m++)
                            h = c[h = o[u++]],
                            2 !== m && p.vertexColors.push(new w(h)),
                            0 !== m && y.vertexColors.push(new w(h));
                    i.faces.push(p),
                    i.faces.push(y)
                } else {
                    if ((p = new E).a = o[u++],
                    p.b = o[u++],
                    p.c = o[u++],
                    f && (f = o[u++],
                    p.materialIndex = f),
                    f = i.faces.length,
                    m)
                        for (m = 0; m < l; m++)
                            for (x = r.uvs[m],
                            i.faceVertexUvs[m][f] = [],
                            n = 0; n < 3; n++)
                                _ = new W(_ = x[2 * (b = o[u++])],b = x[2 * b + 1]),
                                i.faceVertexUvs[m][f].push(_);
                    if (g && (g = 3 * o[u++],
                    p.normal.set(s[g++], s[g++], s[g])),
                    v)
                        for (m = 0; m < 3; m++)
                            g = 3 * o[u++],
                            v = new wt(s[g++],s[g++],s[g]),
                            p.vertexNormals.push(v);
                    if (h && (h = o[u++],
                    p.color.setHex(c[h])),
                    a)
                        for (m = 0; m < 3; m++)
                            h = o[u++],
                            p.vertexColors.push(new w(c[h]));
                    i.faces.push(p)
                }
            }
            if (u = void 0 !== (r = t).influencesPerVertex ? r.influencesPerVertex : 2,
            r.skinWeights)
                for (d = 0,
                o = r.skinWeights.length; d < o; d += u)
                    i.skinWeights.push(new Et(r.skinWeights[d],1 < u ? r.skinWeights[d + 1] : 0,2 < u ? r.skinWeights[d + 2] : 0,3 < u ? r.skinWeights[d + 3] : 0));
            if (r.skinIndices)
                for (d = 0,
                o = r.skinIndices.length; d < o; d += u)
                    i.skinIndices.push(new Et(r.skinIndices[d],1 < u ? r.skinIndices[d + 1] : 0,2 < u ? r.skinIndices[d + 2] : 0,3 < u ? r.skinIndices[d + 3] : 0));
            if (i.bones = r.bones,
            i.bones && 0 < i.bones.length && (i.skinWeights.length !== i.skinIndices.length || i.skinIndices.length !== i.vertices.length) && console.warn("When skinning, number of vertices (" + i.vertices.length + "), skinIndices (" + i.skinIndices.length + "), and skinWeights (" + i.skinWeights.length + ") should match."),
            o = (d = t).scale,
            void 0 !== d.morphTargets)
                for (r = 0,
                u = d.morphTargets.length; r < u; r++)
                    for (i.morphTargets[r] = {},
                    i.morphTargets[r].name = d.morphTargets[r].name,
                    i.morphTargets[r].vertices = [],
                    s = i.morphTargets[r].vertices,
                    l = 0,
                    a = (c = d.morphTargets[r].vertices).length; l < a; l += 3)
                        (h = new wt).x = c[l] * o,
                        h.y = c[l + 1] * o,
                        h.z = c[l + 2] * o,
                        s.push(h);
            if (void 0 !== d.morphColors && 0 < d.morphColors.length)
                for (console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'),
                o = i.faces,
                d = d.morphColors[0].colors,
                r = 0,
                u = o.length; r < u; r++)
                    o[r].color.fromArray(d, 3 * r);
            for (r = [],
            u = [],
            void 0 !== (d = t).animation && u.push(d.animation),
            void 0 !== d.animations && (d.animations.length ? u = u.concat(d.animations) : u.push(d.animations)),
            d = 0; d < u.length; d++)
                (o = Bi.parseAnimation(u[d], i.bones)) && r.push(o);
            return i.morphTargets && (u = Bi.CreateClipsFromMorphTargetSequences(i.morphTargets, 10),
            r = r.concat(u)),
            0 < r.length && (i.animations = r),
            i.computeFaceNormals(),
            i.computeBoundingSphere(),
            void 0 === t.materials || 0 === t.materials.length ? {
                geometry: i
            } : {
                geometry: i,
                materials: t = Fi.prototype.initMaterials(t.materials, e, this.crossOrigin)
            }
        }
    }),
    Object.assign(Hi.prototype, {
        load: function(n, i, t, r) {
            "" === this.texturePath && (this.texturePath = n.substring(0, n.lastIndexOf("/") + 1));
            var o = this;
            new Vn(o.manager).load(n, function(t) {
                var e = null;
                try {
                    e = JSON.parse(t)
                } catch (t) {
                    return void 0 !== r && r(t),
                    void console.error("THREE:ObjectLoader: Can't parse " + n + ".", t.message)
                }
                void 0 === (t = e.metadata) || void 0 === t.type || "geometry" === t.type.toLowerCase() ? console.error("THREE.ObjectLoader: Can't load " + n + ". Use THREE.JSONLoader instead.") : o.parse(e, i)
            }, t, r)
        },
        setTexturePath: function(t) {
            this.texturePath = t
        },
        setCrossOrigin: function(t) {
            this.crossOrigin = t
        },
        parse: function(t, e) {
            var n = this.parseShape(t.shapes)
              , n = this.parseGeometries(t.geometries, n)
              , i = this.parseImages(t.images, function() {
                void 0 !== e && e(r)
            })
              , i = this.parseTextures(t.textures, i);
            i = this.parseMaterials(t.materials, i);
            var r = this.parseObject(t.object, n, i);
            return t.animations && (r.animations = this.parseAnimations(t.animations)),
            void 0 !== t.images && 0 !== t.images.length || void 0 === e || e(r),
            r
        },
        parseShape: function(t) {
            var e = {};
            if (void 0 !== t)
                for (var n = 0, i = t.length; n < i; n++) {
                    var r = (new di).fromJSON(t[n]);
                    e[r.uuid] = r
                }
            return e
        },
        parseGeometries: function(t, e) {
            var n = {};
            if (void 0 !== t)
                for (var i = new zi, r = new Di, o = 0, a = t.length; o < a; o++) {
                    var s = t[o];
                    switch (s.type) {
                    case "PlaneGeometry":
                    case "PlaneBufferGeometry":
                        var c = new Qs[s.type](s.width,s.height,s.widthSegments,s.heightSegments);
                        break;
                    case "BoxGeometry":
                    case "BoxBufferGeometry":
                    case "CubeGeometry":
                        c = new Qs[s.type](s.width,s.height,s.depth,s.widthSegments,s.heightSegments,s.depthSegments);
                        break;
                    case "CircleGeometry":
                    case "CircleBufferGeometry":
                        c = new Qs[s.type](s.radius,s.segments,s.thetaStart,s.thetaLength);
                        break;
                    case "CylinderGeometry":
                    case "CylinderBufferGeometry":
                        c = new Qs[s.type](s.radiusTop,s.radiusBottom,s.height,s.radialSegments,s.heightSegments,s.openEnded,s.thetaStart,s.thetaLength);
                        break;
                    case "ConeGeometry":
                    case "ConeBufferGeometry":
                        c = new Qs[s.type](s.radius,s.height,s.radialSegments,s.heightSegments,s.openEnded,s.thetaStart,s.thetaLength);
                        break;
                    case "SphereGeometry":
                    case "SphereBufferGeometry":
                        c = new Qs[s.type](s.radius,s.widthSegments,s.heightSegments,s.phiStart,s.phiLength,s.thetaStart,s.thetaLength);
                        break;
                    case "DodecahedronGeometry":
                    case "DodecahedronBufferGeometry":
                    case "IcosahedronGeometry":
                    case "IcosahedronBufferGeometry":
                    case "OctahedronGeometry":
                    case "OctahedronBufferGeometry":
                    case "TetrahedronGeometry":
                    case "TetrahedronBufferGeometry":
                        c = new Qs[s.type](s.radius,s.detail);
                        break;
                    case "RingGeometry":
                    case "RingBufferGeometry":
                        c = new Qs[s.type](s.innerRadius,s.outerRadius,s.thetaSegments,s.phiSegments,s.thetaStart,s.thetaLength);
                        break;
                    case "TorusGeometry":
                    case "TorusBufferGeometry":
                        c = new Qs[s.type](s.radius,s.tube,s.radialSegments,s.tubularSegments,s.arc);
                        break;
                    case "TorusKnotGeometry":
                    case "TorusKnotBufferGeometry":
                        c = new Qs[s.type](s.radius,s.tube,s.tubularSegments,s.radialSegments,s.p,s.q);
                        break;
                    case "LatheGeometry":
                    case "LatheBufferGeometry":
                        c = new Qs[s.type](s.points,s.segments,s.phiStart,s.phiLength);
                        break;
                    case "PolyhedronGeometry":
                    case "PolyhedronBufferGeometry":
                        c = new Qs[s.type](s.vertices,s.indices,s.radius,s.details);
                        break;
                    case "ShapeGeometry":
                    case "ShapeBufferGeometry":
                        for (var c = [], h = 0, l = s.shapes.length; h < l; h++)
                            c.push(e[s.shapes[h]]);
                        c = new Qs[s.type](c,s.curveSegments);
                        break;
                    case "BufferGeometry":
                        c = r.parse(s);
                        break;
                    case "Geometry":
                        c = i.parse(s, this.texturePath).geometry;
                        break;
                    default:
                        console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"');
                        continue
                    }
                    c.uuid = s.uuid,
                    void 0 !== s.name && (c.name = s.name),
                    n[s.uuid] = c
                }
            return n
        },
        parseMaterials: function(t, e) {
            var n = {};
            if (void 0 !== t) {
                var i = new Ui;
                i.setTextures(e),
                e = 0;
                for (var r = t.length; e < r; e++) {
                    var o = t[e];
                    if ("MultiMaterial" === o.type) {
                        for (var a = [], s = 0; s < o.materials.length; s++)
                            a.push(i.parse(o.materials[s]));
                        n[o.uuid] = a
                    } else
                        n[o.uuid] = i.parse(o)
                }
            }
            return n
        },
        parseAnimations: function(t) {
            for (var e = [], n = 0; n < t.length; n++) {
                var i = Bi.parse(t[n]);
                e.push(i)
            }
            return e
        },
        parseImages: function(t, e) {
            var n = this
              , i = {};
            if (void 0 !== t && 0 < t.length) {
                var r = new Xn(e = new kn(e));
                r.setCrossOrigin(this.crossOrigin),
                e = 0;
                for (var o = t.length; e < o; e++) {
                    var a = t[e]
                      , s = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a.url) ? a.url : n.texturePath + a.url;
                    i[a.uuid] = function(t) {
                        return n.manager.itemStart(t),
                        r.load(t, function() {
                            n.manager.itemEnd(t)
                        }, void 0, function() {
                            n.manager.itemEnd(t),
                            n.manager.itemError(t)
                        })
                    }(s)
                }
            }
            return i
        },
        parseTextures: function(t, e) {
            function n(t, e) {
                return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t),
                e[t])
            }
            var i = {};
            if (void 0 !== t)
                for (var r = 0, o = t.length; r < o; r++) {
                    var a = t[r];
                    void 0 === a.image && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid),
                    void 0 === e[a.image] && console.warn("THREE.ObjectLoader: Undefined image", a.image);
                    var s = new d(e[a.image]);
                    s.needsUpdate = !0,
                    s.uuid = a.uuid,
                    void 0 !== a.name && (s.name = a.name),
                    void 0 !== a.mapping && (s.mapping = n(a.mapping, fc)),
                    void 0 !== a.offset && s.offset.fromArray(a.offset),
                    void 0 !== a.repeat && s.repeat.fromArray(a.repeat),
                    void 0 !== a.center && s.center.fromArray(a.center),
                    void 0 !== a.rotation && (s.rotation = a.rotation),
                    void 0 !== a.wrap && (s.wrapS = n(a.wrap[0], mc),
                    s.wrapT = n(a.wrap[1], mc)),
                    void 0 !== a.format && (s.format = a.format),
                    void 0 !== a.minFilter && (s.minFilter = n(a.minFilter, gc)),
                    void 0 !== a.magFilter && (s.magFilter = n(a.magFilter, gc)),
                    void 0 !== a.anisotropy && (s.anisotropy = a.anisotropy),
                    void 0 !== a.flipY && (s.flipY = a.flipY),
                    i[a.uuid] = s
                }
            return i
        },
        parseObject: function(t, e, o) {
            function n(t) {
                return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t),
                e[t]
            }
            function i(t) {
                if (void 0 !== t) {
                    if (Array.isArray(t)) {
                        for (var e = [], n = 0, i = t.length; n < i; n++) {
                            var r = t[n];
                            void 0 === o[r] && console.warn("THREE.ObjectLoader: Undefined material", r),
                            e.push(o[r])
                        }
                        return e
                    }
                    return void 0 === o[t] && console.warn("THREE.ObjectLoader: Undefined material", t),
                    o[t]
                }
            }
            switch (t.type) {
            case "Scene":
                var r = new me;
                void 0 !== t.background && Number.isInteger(t.background) && (r.background = new w(t.background)),
                void 0 !== t.fog && ("Fog" === t.fog.type ? r.fog = new fe(t.fog.color,t.fog.near,t.fog.far) : "FogExp2" === t.fog.type && (r.fog = new pe(t.fog.color,t.fog.density)));
                break;
            case "PerspectiveCamera":
                r = new he(t.fov,t.aspect,t.near,t.far),
                void 0 !== t.focus && (r.focus = t.focus),
                void 0 !== t.zoom && (r.zoom = t.zoom),
                void 0 !== t.filmGauge && (r.filmGauge = t.filmGauge),
                void 0 !== t.filmOffset && (r.filmOffset = t.filmOffset),
                void 0 !== t.view && (r.view = Object.assign({}, t.view));
                break;
            case "OrthographicCamera":
                r = new p(t.left,t.right,t.top,t.bottom,t.near,t.far),
                void 0 !== t.zoom && (r.zoom = t.zoom),
                void 0 !== t.view && (r.view = Object.assign({}, t.view));
                break;
            case "AmbientLight":
                r = new _i(t.color,t.intensity);
                break;
            case "DirectionalLight":
                r = new bi(t.color,t.intensity);
                break;
            case "PointLight":
                r = new yi(t.color,t.intensity,t.distance,t.decay);
                break;
            case "RectAreaLight":
                r = new wi(t.color,t.intensity,t.width,t.height);
                break;
            case "SpotLight":
                r = new vi(t.color,t.intensity,t.distance,t.angle,t.penumbra,t.decay);
                break;
            case "HemisphereLight":
                r = new fi(t.color,t.groundColor,t.intensity);
                break;
            case "SkinnedMesh":
                console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
            case "Mesh":
                var r = n(t.geometry)
                  , a = i(t.material);
                r = new (r.bones && 0 < r.bones.length ? _e : H)(r,a);
                break;
            case "LOD":
                r = new ye;
                break;
            case "Line":
                r = new Ee(n(t.geometry),i(t.material),t.mode);
                break;
            case "LineLoop":
                r = new Te(n(t.geometry),i(t.material));
                break;
            case "LineSegments":
                r = new Me(n(t.geometry),i(t.material));
                break;
            case "PointCloud":
            case "Points":
                r = new Ae(n(t.geometry),i(t.material));
                break;
            case "Sprite":
                r = new ve(i(t.material));
                break;
            case "Group":
                r = new Re;
                break;
            default:
                r = new l
            }
            if (r.uuid = t.uuid,
            void 0 !== t.name && (r.name = t.name),
            void 0 !== t.matrix ? (r.matrix.fromArray(t.matrix),
            void 0 !== t.matrixAutoUpdate && (r.matrixAutoUpdate = t.matrixAutoUpdate),
            r.matrixAutoUpdate && r.matrix.decompose(r.position, r.quaternion, r.scale)) : (void 0 !== t.position && r.position.fromArray(t.position),
            void 0 !== t.rotation && r.rotation.fromArray(t.rotation),
            void 0 !== t.quaternion && r.quaternion.fromArray(t.quaternion),
            void 0 !== t.scale && r.scale.fromArray(t.scale)),
            void 0 !== t.castShadow && (r.castShadow = t.castShadow),
            void 0 !== t.receiveShadow && (r.receiveShadow = t.receiveShadow),
            t.shadow && (void 0 !== t.shadow.bias && (r.shadow.bias = t.shadow.bias),
            void 0 !== t.shadow.radius && (r.shadow.radius = t.shadow.radius),
            void 0 !== t.shadow.mapSize && r.shadow.mapSize.fromArray(t.shadow.mapSize),
            void 0 !== t.shadow.camera && (r.shadow.camera = this.parseObject(t.shadow.camera))),
            void 0 !== t.visible && (r.visible = t.visible),
            void 0 !== t.frustumCulled && (r.frustumCulled = t.frustumCulled),
            void 0 !== t.renderOrder && (r.renderOrder = t.renderOrder),
            void 0 !== t.userData && (r.userData = t.userData),
            void 0 !== t.children)
                for (var a = t.children, s = 0; s < a.length; s++)
                    r.add(this.parseObject(a[s], e, o));
            if ("LOD" === t.type)
                for (t = t.levels,
                a = 0; a < t.length; a++) {
                    var s = t[a]
                      , c = r.getObjectByProperty("uuid", s.object);
                    void 0 !== c && r.addLevel(c, s.distance)
                }
            return r
        }
    });
    var fc = {
        UVMapping: 300,
        CubeReflectionMapping: 301,
        CubeRefractionMapping: 302,
        EquirectangularReflectionMapping: 303,
        EquirectangularRefractionMapping: 304,
        SphericalReflectionMapping: 305,
        CubeUVReflectionMapping: 306,
        CubeUVRefractionMapping: 307
    }
      , mc = {
        RepeatWrapping: 1e3,
        ClampToEdgeWrapping: 1001,
        MirroredRepeatWrapping: 1002
    }
      , gc = {
        NearestFilter: 1003,
        NearestMipMapNearestFilter: 1004,
        NearestMipMapLinearFilter: 1005,
        LinearFilter: 1006,
        LinearMipMapNearestFilter: 1007,
        LinearMipMapLinearFilter: 1008
    };
    Gi.prototype = {
        constructor: Gi,
        setOptions: function(t) {
            return this.options = t,
            this
        },
        load: function(e, n, t, i) {
            void 0 === e && (e = ""),
            void 0 !== this.path && (e = this.path + e);
            var r = this
              , o = $s.get(e);
            if (void 0 !== o)
                return r.manager.itemStart(e),
                setTimeout(function() {
                    n && n(o),
                    r.manager.itemEnd(e)
                }, 0),
                o;
            fetch(e).then(function(t) {
                return t.blob()
            }).then(function(t) {
                return createImageBitmap(t, r.options)
            }).then(function(t) {
                $s.add(e, t),
                n && n(t),
                r.manager.itemEnd(e)
            }).catch(function(t) {
                i && i(t),
                r.manager.itemEnd(e),
                r.manager.itemError(e)
            })
        },
        setCrossOrigin: function() {
            return this
        },
        setPath: function(t) {
            return this.path = t,
            this
        }
    },
    Object.assign(ki.prototype, {
        moveTo: function(t, e) {
            this.currentPath = new ui,
            this.subPaths.push(this.currentPath),
            this.currentPath.moveTo(t, e)
        },
        lineTo: function(t, e) {
            this.currentPath.lineTo(t, e)
        },
        quadraticCurveTo: function(t, e, n, i) {
            this.currentPath.quadraticCurveTo(t, e, n, i)
        },
        bezierCurveTo: function(t, e, n, i, r, o) {
            this.currentPath.bezierCurveTo(t, e, n, i, r, o)
        },
        splineThru: function(t) {
            this.currentPath.splineThru(t)
        },
        toShapes: function(t, e) {
            function n(t) {
                for (var e = [], n = 0, i = t.length; n < i; n++) {
                    var r = t[n]
                      , o = new di;
                    o.curves = r.curves,
                    e.push(o)
                }
                return e
            }
            var i = Zs.isClockWise
              , r = this.subPaths;
            if (0 === r.length)
                return [];
            if (!0 === e)
                return n(r);
            if (e = [],
            1 === r.length) {
                var o = r[0]
                  , a = new di;
                return a.curves = o.curves,
                e.push(a),
                e
            }
            var s = !i(r[0].getPoints())
              , s = t ? !s : s
              , a = []
              , c = []
              , h = []
              , l = 0;
            c[l] = void 0,
            h[l] = [];
            for (var u = 0, d = r.length; u < d; u++) {
                var p = (o = r[u]).getPoints()
                  , f = i(p);
                (f = t ? !f : f) ? (!s && c[l] && l++,
                c[l] = {
                    s: new di,
                    p: p
                },
                c[l].s.curves = o.curves,
                s && l++,
                h[l] = []) : h[l].push({
                    h: o,
                    p: p[0]
                })
            }
            if (!c[0])
                return n(r);
            if (1 < c.length) {
                for (u = !1,
                t = [],
                i = 0,
                r = c.length; i < r; i++)
                    a[i] = [];
                for (i = 0,
                r = c.length; i < r; i++)
                    for (o = h[i],
                    f = 0; f < o.length; f++) {
                        for (s = o[f],
                        l = !0,
                        p = 0; p < c.length; p++)
                            !function(t, e) {
                                for (var n = e.length, i = !1, r = n - 1, o = 0; o < n; r = o++) {
                                    var a = e[r]
                                      , s = e[o]
                                      , c = s.x - a.x
                                      , h = s.y - a.y;
                                    if (Math.abs(h) > Number.EPSILON) {
                                        if (h < 0 && (a = e[o],
                                        c = -c,
                                        s = e[r],
                                        h = -h),
                                        !(t.y < a.y || t.y > s.y))
                                            if (t.y === a.y) {
                                                if (t.x === a.x)
                                                    return 1
                                            } else {
                                                if (0 === (r = h * (t.x - a.x) - c * (t.y - a.y)))
                                                    return 1;
                                                r < 0 || (i = !i)
                                            }
                                    } else if (t.y === a.y && (s.x <= t.x && t.x <= a.x || a.x <= t.x && t.x <= s.x))
                                        return 1
                                }
                                return i
                            }(s.p, c[p].p) || (i !== p && t.push({
                                froms: i,
                                tos: p,
                                hole: f
                            }),
                            l ? (l = !1,
                            a[p].push(s)) : u = !0);
                        l && a[i].push(s)
                    }
                0 < t.length && (u || (h = a))
            }
            for (u = 0,
            i = c.length; u < i; u++)
                for (a = c[u].s,
                e.push(a),
                r = 0,
                o = (t = h[u]).length; r < o; r++)
                    a.holes.push(t[r].h);
            return e
        }
    }),
    Object.assign(Vi.prototype, {
        isFont: !0,
        generateShapes: function(t, e, n) {
            n = [];
            var i = e = void 0 === e ? 100 : e;
            e = this.data;
            var r = String(t).split("");
            i /= e.resolution;
            var o = (e.boundingBox.yMax - e.boundingBox.yMin + e.underlineThickness) * i;
            t = [];
            for (var a = 0, s = 0, c = 0; c < r.length; c++) {
                var h = r[c];
                if ("\n" === h)
                    a = 0,
                    s -= o;
                else {
                    var l = i
                      , u = a
                      , d = s;
                    if (h = e.glyphs[h] || e.glyphs["?"]) {
                        var p = new ki;
                        if (h.o)
                            for (var f = h._cachedOutline || (h._cachedOutline = h.o.split(" ")), m = 0, g = f.length; m < g; )
                                switch (f[m++]) {
                                case "m":
                                    var v = f[m++] * l + u
                                      , y = f[m++] * l + d;
                                    p.moveTo(v, y);
                                    break;
                                case "l":
                                    v = f[m++] * l + u,
                                    y = f[m++] * l + d,
                                    p.lineTo(v, y);
                                    break;
                                case "q":
                                    var x = f[m++] * l + u
                                      , b = f[m++] * l + d
                                      , _ = f[m++] * l + u
                                      , w = f[m++] * l + d;
                                    p.quadraticCurveTo(_, w, x, b);
                                    break;
                                case "b":
                                    x = f[m++] * l + u,
                                    b = f[m++] * l + d,
                                    _ = f[m++] * l + u,
                                    w = f[m++] * l + d,
                                    v = f[m++] * l + u,
                                    y = f[m++] * l + d,
                                    p.bezierCurveTo(_, w, v, y, x, b)
                                }
                        l = {
                            offsetX: h.ha * l,
                            path: p
                        }
                    } else
                        l = void 0;
                    a += l.offsetX,
                    t.push(l.path)
                }
            }
            for (e = 0,
            r = t.length; e < r; e++)
                Array.prototype.push.apply(n, t[e].toShapes());
            return n
        }
    }),
    Object.assign(ji.prototype, {
        load: function(t, i, e, n) {
            var r = this
              , o = new Vn(this.manager);
            o.setPath(this.path),
            o.load(t, function(e) {
                try {
                    var n = JSON.parse(e)
                } catch (t) {
                    console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),
                    n = JSON.parse(e.substring(65, e.length - 2))
                }
                e = r.parse(n),
                i && i(e)
            }, e, n)
        },
        parse: function(t) {
            return new Vi(t)
        },
        setPath: function(t) {
            return this.path = t,
            this
        }
    });
    var vc, yc, xc, bc, _c, wc, Ec, Mc, Tc, Sc, Ac, Rc, Lc, Cc, Pc, Nc, Oc, Ic, Bc, Uc, Dc, Fc, zc, Hc, Gc, kc, Vc, jc, Wc, Xc, qc, Yc, Zc, Jc, Qc, Kc, $c, th, eh, nh, ih, rh, oh, ah, sh, ch, hh, lh, uh, dh, ph, fh, mh = {
        getContext: function() {
            return vc = void 0 === vc ? new (window.AudioContext || window.webkitAudioContext) : vc
        },
        setContext: function(t) {
            vc = t
        }
    };
    function gh(t, e, n, i) {
        if (sh.set(e, n, i).unproject(ch),
        void 0 !== (t = ah[t]))
            for (e = oh.getAttribute("position"),
            n = 0,
            i = t.length; n < i; n++)
                e.setXYZ(t[n], sh.x, sh.y, sh.z)
    }
    Object.assign(Wi.prototype, {
        load: function(t, e, n, i) {
            var r = new Vn(this.manager);
            r.setResponseType("arraybuffer"),
            r.load(t, function(t) {
                mh.getContext().decodeAudioData(t, function(t) {
                    e(t)
                })
            }, n, i)
        }
    }),
    Object.assign(Xi.prototype, {
        update: (Sc = new _t,
        Ac = new _t,
        function(t) {
            var e, n, i, r, o;
            yc === this && xc === t.focus && bc === t.fov && _c === t.aspect * this.aspect && wc === t.near && Ec === t.far && Mc === t.zoom && Tc === this.eyeSep || (yc = this,
            xc = t.focus,
            bc = t.fov,
            _c = t.aspect * this.aspect,
            wc = t.near,
            Ec = t.far,
            Mc = t.zoom,
            e = t.projectionMatrix.clone(),
            n = (Tc = this.eyeSep / 2) * wc / xc,
            i = wc * Math.tan(io.DEG2RAD * bc * .5) / Mc,
            Ac.elements[12] = -Tc,
            Sc.elements[12] = Tc,
            r = -i * _c + n,
            o = i * _c + n,
            e.elements[0] = 2 * wc / (o - r),
            e.elements[8] = (o + r) / (o - r),
            this.cameraL.projectionMatrix.copy(e),
            r = -i * _c - n,
            o = i * _c - n,
            e.elements[0] = 2 * wc / (o - r),
            e.elements[8] = (o + r) / (o - r),
            this.cameraR.projectionMatrix.copy(e)),
            this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Ac),
            this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Sc)
        }
        )
    }),
    (qi.prototype = Object.create(l.prototype)).constructor = qi,
    Yi.prototype = Object.assign(Object.create(l.prototype), {
        constructor: Yi,
        getInput: function() {
            return this.gain
        },
        removeFilter: function() {
            null !== this.filter && (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination),
            this.gain.connect(this.context.destination),
            this.filter = null)
        },
        getFilter: function() {
            return this.filter
        },
        setFilter: function(t) {
            null !== this.filter ? (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
            this.filter = t,
            this.gain.connect(this.filter),
            this.filter.connect(this.context.destination)
        },
        getMasterVolume: function() {
            return this.gain.gain.value
        },
        setMasterVolume: function(t) {
            this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01)
        },
        updateMatrixWorld: (Rc = new wt,
        Lc = new V,
        Cc = new wt,
        Pc = new wt,
        function(t) {
            l.prototype.updateMatrixWorld.call(this, t),
            t = this.context.listener;
            var e = this.up;
            this.matrixWorld.decompose(Rc, Lc, Cc),
            Pc.set(0, 0, -1).applyQuaternion(Lc),
            t.positionX ? (t.positionX.setValueAtTime(Rc.x, this.context.currentTime),
            t.positionY.setValueAtTime(Rc.y, this.context.currentTime),
            t.positionZ.setValueAtTime(Rc.z, this.context.currentTime),
            t.forwardX.setValueAtTime(Pc.x, this.context.currentTime),
            t.forwardY.setValueAtTime(Pc.y, this.context.currentTime),
            t.forwardZ.setValueAtTime(Pc.z, this.context.currentTime),
            t.upX.setValueAtTime(e.x, this.context.currentTime),
            t.upY.setValueAtTime(e.y, this.context.currentTime),
            t.upZ.setValueAtTime(e.z, this.context.currentTime)) : (t.setPosition(Rc.x, Rc.y, Rc.z),
            t.setOrientation(Pc.x, Pc.y, Pc.z, e.x, e.y, e.z))
        }
        )
    }),
    Zi.prototype = Object.assign(Object.create(l.prototype), {
        constructor: Zi,
        getOutput: function() {
            return this.gain
        },
        setNodeSource: function(t) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "audioNode",
            this.source = t,
            this.connect(),
            this
        },
        setBuffer: function(t) {
            return this.buffer = t,
            this.sourceType = "buffer",
            this.autoplay && this.play(),
            this
        },
        play: function() {
            if (!0 === this.isPlaying)
                console.warn("THREE.Audio: Audio is already playing.");
            else {
                if (!1 !== this.hasPlaybackControl) {
                    var t = this.context.createBufferSource();
                    return t.buffer = this.buffer,
                    t.loop = this.loop,
                    t.onended = this.onEnded.bind(this),
                    t.playbackRate.setValueAtTime(this.playbackRate, this.startTime),
                    this.startTime = this.context.currentTime,
                    t.start(this.startTime, this.offset),
                    this.isPlaying = !0,
                    this.source = t,
                    this.connect()
                }
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
        },
        pause: function() {
            if (!1 !== this.hasPlaybackControl)
                return !0 === this.isPlaying && (this.source.stop(),
                this.offset += (this.context.currentTime - this.startTime) * this.playbackRate,
                this.isPlaying = !1),
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        stop: function() {
            if (!1 !== this.hasPlaybackControl)
                return this.source.stop(),
                this.offset = 0,
                this.isPlaying = !1,
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        connect: function() {
            if (0 < this.filters.length) {
                this.source.connect(this.filters[0]);
                for (var t = 1, e = this.filters.length; t < e; t++)
                    this.filters[t - 1].connect(this.filters[t]);
                this.filters[this.filters.length - 1].connect(this.getOutput())
            } else
                this.source.connect(this.getOutput());
            return this
        },
        disconnect: function() {
            if (0 < this.filters.length) {
                this.source.disconnect(this.filters[0]);
                for (var t = 1, e = this.filters.length; t < e; t++)
                    this.filters[t - 1].disconnect(this.filters[t]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else
                this.source.disconnect(this.getOutput());
            return this
        },
        getFilters: function() {
            return this.filters
        },
        setFilters: function(t) {
            return t = t || [],
            !0 === this.isPlaying ? (this.disconnect(),
            this.filters = t,
            this.connect()) : this.filters = t,
            this
        },
        getFilter: function() {
            return this.getFilters()[0]
        },
        setFilter: function(t) {
            return this.setFilters(t ? [t] : [])
        },
        setPlaybackRate: function(t) {
            if (!1 !== this.hasPlaybackControl)
                return this.playbackRate = t,
                !0 === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime),
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        getPlaybackRate: function() {
            return this.playbackRate
        },
        onEnded: function() {
            this.isPlaying = !1
        },
        getLoop: function() {
            return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."),
            !1) : this.loop
        },
        setLoop: function(t) {
            if (!1 !== this.hasPlaybackControl)
                return this.loop = t,
                !0 === this.isPlaying && (this.source.loop = this.loop),
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        getVolume: function() {
            return this.gain.gain.value
        },
        setVolume: function(t) {
            return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01),
            this
        }
    }),
    Ji.prototype = Object.assign(Object.create(Zi.prototype), {
        constructor: Ji,
        getOutput: function() {
            return this.panner
        },
        getRefDistance: function() {
            return this.panner.refDistance
        },
        setRefDistance: function(t) {
            this.panner.refDistance = t
        },
        getRolloffFactor: function() {
            return this.panner.rolloffFactor
        },
        setRolloffFactor: function(t) {
            this.panner.rolloffFactor = t
        },
        getDistanceModel: function() {
            return this.panner.distanceModel
        },
        setDistanceModel: function(t) {
            this.panner.distanceModel = t
        },
        getMaxDistance: function() {
            return this.panner.maxDistance
        },
        setMaxDistance: function(t) {
            this.panner.maxDistance = t
        },
        updateMatrixWorld: (Nc = new wt,
        function(t) {
            l.prototype.updateMatrixWorld.call(this, t),
            Nc.setFromMatrixPosition(this.matrixWorld),
            this.panner.setPosition(Nc.x, Nc.y, Nc.z)
        }
        )
    }),
    Object.assign(Qi.prototype, {
        getFrequencyData: function() {
            return this.analyser.getByteFrequencyData(this.data),
            this.data
        },
        getAverageFrequency: function() {
            for (var t = 0, e = this.getFrequencyData(), n = 0; n < e.length; n++)
                t += e[n];
            return t / e.length
        }
    }),
    Object.assign(Ki.prototype, {
        accumulate: function(t, e) {
            var n = this.buffer
              , i = this.valueSize;
            t = t * i + i;
            var r = this.cumulativeWeight;
            if (0 === r) {
                for (r = 0; r !== i; ++r)
                    n[t + r] = n[r];
                r = e
            } else
                this._mixBufferRegion(n, t, 0, e / (r += e), i);
            this.cumulativeWeight = r
        },
        apply: function(t) {
            var e = this.valueSize
              , n = this.buffer;
            t = t * e + e;
            var i = this.cumulativeWeight
              , r = this.binding;
            this.cumulativeWeight = 0,
            i < 1 && this._mixBufferRegion(n, t, 3 * e, 1 - i, e);
            for (var i = e, o = e + e; i !== o; ++i)
                if (n[i] !== n[i + e]) {
                    r.setValue(n, t);
                    break
                }
        },
        saveOriginalState: function() {
            var t = this.buffer
              , e = this.valueSize
              , n = 3 * e;
            this.binding.getValue(t, n);
            for (var i = e; i !== n; ++i)
                t[i] = t[n + i % e];
            this.cumulativeWeight = 0
        },
        restoreOriginalState: function() {
            this.binding.setValue(this.buffer, 3 * this.valueSize)
        },
        _select: function(t, e, n, i, r) {
            if (.5 <= i)
                for (i = 0; i !== r; ++i)
                    t[e + i] = t[n + i]
        },
        _slerp: function(t, e, n, i) {
            V.slerpFlat(t, e, t, e, t, n, i)
        },
        _lerp: function(t, e, n, i, r) {
            for (var o = 1 - i, a = 0; a !== r; ++a) {
                var s = e + a;
                t[s] = t[s] * o + t[n + a] * i
            }
        }
    }),
    Object.assign($i.prototype, {
        getValue: function(t, e) {
            this.bind();
            var n = this._bindings[this._targetGroup.nCachedObjects_];
            void 0 !== n && n.getValue(t, e)
        },
        setValue: function(t, e) {
            for (var n = this._bindings, i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
                n[i].setValue(t, e)
        },
        bind: function() {
            for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
                t[e].bind()
        },
        unbind: function() {
            for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
                t[e].unbind()
        }
    }),
    Object.assign(tr, {
        Composite: $i,
        create: function(t, e, n) {
            return new (t && t.isAnimationObjectGroup ? tr.Composite : tr)(t,e,n)
        },
        sanitizeNodeName: (zc = /[\[\]\.:\/]/g,
        function(t) {
            return t.replace(/\s/g, "_").replace(zc, "")
        }
        ),
        parseTrackName: (Oc = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
        Ic = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
        Oc = /(WCOD+)?/.source.replace("WCOD", Oc),
        Bc = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
        Uc = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
        Dc = new RegExp("^" + Ic + Oc + Bc + Uc + "$"),
        Fc = ["material", "materials", "bones"],
        function(t) {
            var e = Dc.exec(t);
            if (!e)
                throw Error("PropertyBinding: Cannot parse trackName: " + t);
            var n, i = (e = {
                nodeName: e[2],
                objectName: e[3],
                objectIndex: e[4],
                propertyName: e[5],
                propertyIndex: e[6]
            }).nodeName && e.nodeName.lastIndexOf(".");
            if (void 0 !== i && -1 !== i && (n = e.nodeName.substring(i + 1),
            -1 !== Fc.indexOf(n) && (e.nodeName = e.nodeName.substring(0, i),
            e.objectName = n)),
            null === e.propertyName || 0 === e.propertyName.length)
                throw Error("PropertyBinding: can not parse propertyName from trackName: " + t);
            return e
        }
        ),
        findNode: function(t, i) {
            if (!i || "" === i || "root" === i || "." === i || -1 === i || i === t.name || i === t.uuid)
                return t;
            if (t.skeleton) {
                var e = t.skeleton.getBoneByName(i);
                if (void 0 !== e)
                    return e
            }
            if (t.children) {
                var r = function(t) {
                    for (var e = 0; e < t.length; e++) {
                        var n = t[e];
                        if (n.name === i || n.uuid === i || (n = r(n.children)))
                            return n
                    }
                    return null
                };
                if (t = r(t.children))
                    return t
            }
            return null
        }
    }),
    Object.assign(tr.prototype, {
        _getValue_unavailable: function() {},
        _setValue_unavailable: function() {},
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [function(t, e) {
            t[e] = this.node[this.propertyName]
        }
        , function(t, e) {
            for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i)
                t[e++] = n[i]
        }
        , function(t, e) {
            t[e] = this.resolvedProperty[this.propertyIndex]
        }
        , function(t, e) {
            this.resolvedProperty.toArray(t, e)
        }
        ],
        SetterByBindingTypeAndVersioning: [[function(t, e) {
            this.targetObject[this.propertyName] = t[e]
        }
        , function(t, e) {
            this.targetObject[this.propertyName] = t[e],
            this.targetObject.needsUpdate = !0
        }
        , function(t, e) {
            this.targetObject[this.propertyName] = t[e],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(t, e) {
            for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i)
                n[i] = t[e++]
        }
        , function(t, e) {
            for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i)
                n[i] = t[e++];
            this.targetObject.needsUpdate = !0
        }
        , function(t, e) {
            for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i)
                n[i] = t[e++];
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e]
        }
        , function(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e],
            this.targetObject.needsUpdate = !0
        }
        , function(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(t, e) {
            this.resolvedProperty.fromArray(t, e)
        }
        , function(t, e) {
            this.resolvedProperty.fromArray(t, e),
            this.targetObject.needsUpdate = !0
        }
        , function(t, e) {
            this.resolvedProperty.fromArray(t, e),
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ]],
        getValue: function(t, e) {
            this.bind(),
            this.getValue(t, e)
        },
        setValue: function(t, e) {
            this.bind(),
            this.setValue(t, e)
        },
        bind: function() {
            var t = this.node
              , e = this.parsedPath
              , n = e.objectName
              , i = e.propertyName
              , r = e.propertyIndex;
            if (t || (this.node = t = tr.findNode(this.rootNode, e.nodeName) || this.rootNode),
            this.getValue = this._getValue_unavailable,
            this.setValue = this._setValue_unavailable,
            t) {
                if (n) {
                    var o = e.objectIndex;
                    switch (n) {
                    case "materials":
                        if (!t.material)
                            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!t.material.materials)
                            return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        t = t.material.materials;
                        break;
                    case "bones":
                        if (!t.skeleton)
                            return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        for (t = t.skeleton.bones,
                        n = 0; n < t.length; n++)
                            if (t[n].name === o) {
                                o = n;
                                break
                            }
                        break;
                    default:
                        if (void 0 === t[n])
                            return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        t = t[n]
                    }
                    if (void 0 !== o) {
                        if (void 0 === t[o])
                            return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                        t = t[o]
                    }
                }
                if (void 0 === (o = t[i]))
                    console.error("THREE.PropertyBinding: Trying to update property for track: " + e.nodeName + "." + i + " but it wasn't found.", t);
                else {
                    if (e = this.Versioning.None,
                    void 0 !== t.needsUpdate ? (e = this.Versioning.NeedsUpdate,
                    this.targetObject = t) : void 0 !== t.matrixWorldNeedsUpdate && (e = this.Versioning.MatrixWorldNeedsUpdate,
                    this.targetObject = t),
                    n = this.BindingType.Direct,
                    void 0 !== r) {
                        if ("morphTargetInfluences" === i) {
                            if (!t.geometry)
                                return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (t.geometry.isBufferGeometry) {
                                if (!t.geometry.morphAttributes)
                                    return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                for (n = 0; n < this.node.geometry.morphAttributes.position.length; n++)
                                    if (t.geometry.morphAttributes.position[n].name === r) {
                                        r = n;
                                        break
                                    }
                            } else {
                                if (!t.geometry.morphTargets)
                                    return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                for (n = 0; n < this.node.geometry.morphTargets.length; n++)
                                    if (t.geometry.morphTargets[n].name === r) {
                                        r = n;
                                        break
                                    }
                            }
                        }
                        n = this.BindingType.ArrayElement,
                        this.resolvedProperty = o,
                        this.propertyIndex = r
                    } else
                        void 0 !== o.fromArray && void 0 !== o.toArray ? (n = this.BindingType.HasFromToArray,
                        this.resolvedProperty = o) : Array.isArray(o) ? (n = this.BindingType.EntireArray,
                        this.resolvedProperty = o) : this.propertyName = i;
                    this.getValue = this.GetterByBindingType[n],
                    this.setValue = this.SetterByBindingTypeAndVersioning[n][e]
                }
            } else
                console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
        },
        unbind: function() {
            this.node = null,
            this.getValue = this._getValue_unbound,
            this.setValue = this._setValue_unbound
        }
    }),
    Object.assign(tr.prototype, {
        _getValue_unbound: tr.prototype.getValue,
        _setValue_unbound: tr.prototype.setValue
    }),
    Object.assign(er.prototype, {
        isAnimationObjectGroup: !0,
        add: function() {
            for (var t = this._objects, e = t.length, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._paths, o = this._parsedPaths, a = this._bindings, s = a.length, c = void 0, h = 0, l = arguments.length; h !== l; ++h) {
                var u = arguments[h]
                  , d = i[p = u.uuid];
                if (void 0 === d) {
                    d = e++,
                    i[p] = d,
                    t.push(u);
                    for (var p = 0, f = s; p !== f; ++p)
                        a[p].push(new tr(u,r[p],o[p]))
                } else if (d < n) {
                    var c = t[d]
                      , m = --n;
                    for (t[i[(f = t[m]).uuid] = d] = f,
                    t[i[p] = m] = u,
                    p = 0,
                    f = s; p !== f; ++p) {
                        var g = a[p]
                          , v = g[d];
                        g[d] = g[m],
                        void 0 === v && (v = new tr(u,r[p],o[p])),
                        g[m] = v
                    }
                } else
                    t[d] !== c && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
            }
            this.nCachedObjects_ = n
        },
        remove: function() {
            for (var t = this._objects, e = this.nCachedObjects_, n = this._indicesByUUID, i = this._bindings, r = i.length, o = 0, a = arguments.length; o !== a; ++o) {
                var s = arguments[o]
                  , c = s.uuid
                  , h = n[c];
                if (void 0 !== h && e <= h) {
                    var l = e++;
                    for (t[n[(u = t[l]).uuid] = h] = u,
                    t[n[c] = l] = s,
                    s = 0,
                    c = r; s !== c; ++s) {
                        var u, d = (u = i[s])[h];
                        u[h] = u[l],
                        u[l] = d
                    }
                }
            }
            this.nCachedObjects_ = e
        },
        uncache: function() {
            for (var t = this._objects, e = t.length, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._bindings, o = r.length, a = 0, s = arguments.length; a !== s; ++a) {
                var c = i[h = arguments[a].uuid];
                if (void 0 !== c)
                    if (delete i[h],
                    c < n) {
                        var h, l = t[h = --n], u = --e, d = t[u];
                        for (t[i[l.uuid] = c] = l,
                        t[i[d.uuid] = h] = d,
                        t.pop(),
                        l = 0,
                        d = o; l !== d; ++l) {
                            var p = r[l]
                              , f = p[u];
                            p[c] = p[h],
                            p[h] = f,
                            p.pop()
                        }
                    } else
                        for (t[i[(d = t[u = --e]).uuid] = c] = d,
                        t.pop(),
                        l = 0,
                        d = o; l !== d; ++l)
                            (p = r[l])[c] = p[u],
                            p.pop()
            }
            this.nCachedObjects_ = n
        },
        subscribe_: function(t, e) {
            var n = this._bindingsIndicesByPath
              , i = n[t]
              , r = this._bindings;
            if (void 0 !== i)
                return r[i];
            var o = this._paths
              , a = this._parsedPaths
              , s = this._objects
              , c = this.nCachedObjects_
              , h = Array(s.length)
              , i = r.length;
            for (n[t] = i,
            o.push(t),
            a.push(e),
            r.push(h),
            n = c,
            i = s.length; n !== i; ++n)
                h[n] = new tr(s[n],t,e);
            return h
        },
        unsubscribe_: function(t) {
            var e, n, i, r, o, a = this._bindingsIndicesByPath, s = a[t];
            void 0 !== s && (e = this._paths,
            n = this._parsedPaths,
            o = (i = this._bindings)[r = i.length - 1],
            i[a[t[r]] = s] = o,
            i.pop(),
            n[s] = n[r],
            n.pop(),
            e[s] = e[r],
            e.pop())
        }
    }),
    Object.assign(nr.prototype, {
        play: function() {
            return this._mixer._activateAction(this),
            this
        },
        stop: function() {
            return this._mixer._deactivateAction(this),
            this.reset()
        },
        reset: function() {
            return this.paused = !1,
            this.enabled = !0,
            this.time = 0,
            this._loopCount = -1,
            this._startTime = null,
            this.stopFading().stopWarping()
        },
        isRunning: function() {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
        },
        isScheduled: function() {
            return this._mixer._isActiveAction(this)
        },
        startAt: function(t) {
            return this._startTime = t,
            this
        },
        setLoop: function(t, e) {
            return this.loop = t,
            this.repetitions = e,
            this
        },
        setEffectiveWeight: function(t) {
            return this.weight = t,
            this._effectiveWeight = this.enabled ? t : 0,
            this.stopFading()
        },
        getEffectiveWeight: function() {
            return this._effectiveWeight
        },
        fadeIn: function(t) {
            return this._scheduleFading(t, 0, 1)
        },
        fadeOut: function(t) {
            return this._scheduleFading(t, 1, 0)
        },
        crossFadeFrom: function(t, e, n) {
            var i, r;
            return t.fadeOut(e),
            this.fadeIn(e),
            n && (r = (n = this._clip.duration) / (i = t._clip.duration),
            t.warp(1, i / n, e),
            this.warp(r, 1, e)),
            this
        },
        crossFadeTo: function(t, e, n) {
            return t.crossFadeFrom(this, e, n)
        },
        stopFading: function() {
            var t = this._weightInterpolant;
            return null !== t && (this._weightInterpolant = null,
            this._mixer._takeBackControlInterpolant(t)),
            this
        },
        setEffectiveTimeScale: function(t) {
            return this.timeScale = t,
            this._effectiveTimeScale = this.paused ? 0 : t,
            this.stopWarping()
        },
        getEffectiveTimeScale: function() {
            return this._effectiveTimeScale
        },
        setDuration: function(t) {
            return this.timeScale = this._clip.duration / t,
            this.stopWarping()
        },
        syncWith: function(t) {
            return this.time = t.time,
            this.timeScale = t.timeScale,
            this.stopWarping()
        },
        halt: function(t) {
            return this.warp(this._effectiveTimeScale, 0, t)
        },
        warp: function(t, e, n) {
            var i = this._mixer
              , r = i.time
              , o = this._timeScaleInterpolant
              , a = this.timeScale;
            return null === o && (this._timeScaleInterpolant = o = i._lendControlInterpolant()),
            i = o.parameterPositions,
            o = o.sampleValues,
            i[0] = r,
            i[1] = r + n,
            o[0] = t / a,
            o[1] = e / a,
            this
        },
        stopWarping: function() {
            var t = this._timeScaleInterpolant;
            return null !== t && (this._timeScaleInterpolant = null,
            this._mixer._takeBackControlInterpolant(t)),
            this
        },
        getMixer: function() {
            return this._mixer
        },
        getClip: function() {
            return this._clip
        },
        getRoot: function() {
            return this._localRoot || this._mixer._root
        },
        _update: function(t, e, n, i) {
            if (this.enabled) {
                if (null !== (r = this._startTime)) {
                    if ((e = (t - r) * n) < 0 || 0 === n)
                        return;
                    this._startTime = null,
                    e *= n
                }
                if (e *= this._updateTimeScale(t),
                n = this._updateTime(e),
                0 < (t = this._updateWeight(t))) {
                    e = this._interpolants;
                    for (var r = this._propertyBindings, o = 0, a = e.length; o !== a; ++o)
                        e[o].evaluate(n),
                        r[o].accumulate(i, t)
                }
            } else
                this._updateWeight(t)
        },
        _updateWeight: function(t) {
            var e, n, i = 0;
            return this.enabled && (i = this.weight,
            null !== (e = this._weightInterpolant) && (i *= n = e.evaluate(t)[0],
            t > e.parameterPositions[1] && (this.stopFading(),
            0 === n && (this.enabled = !1)))),
            this._effectiveWeight = i
        },
        _updateTimeScale: function(t) {
            var e, n = 0;
            return this.paused || (n = this.timeScale,
            null !== (e = this._timeScaleInterpolant) && (n *= e.evaluate(t)[0],
            t > e.parameterPositions[1] && (this.stopWarping(),
            0 === n ? this.paused = !0 : this.timeScale = n))),
            this._effectiveTimeScale = n
        },
        _updateTime: function(t) {
            var e = this.time + t;
            if (0 === t)
                return e;
            var n = this._clip.duration
              , i = this.loop
              , r = this._loopCount;
            if (2200 === i)
                t: {
                    if (-1 === r && (this._loopCount = 0,
                    this._setEndings(!0, !0, !1)),
                    n <= e)
                        e = n;
                    else {
                        if (!(e < 0))
                            break t;
                        e = 0
                    }
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: t < 0 ? -1 : 1
                    })
                }
            else {
                var o, a, i = 2202 === i;
                if (-1 === r && (0 <= t ? this._setEndings(!(r = 0), 0 === this.repetitions, i) : this._setEndings(0 === this.repetitions, !0, i)),
                (n <= e || e < 0) && (e -= n * (o = Math.floor(e / n)),
                r += Math.abs(o),
                (a = this.repetitions - r) <= 0 ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                e = 0 < t ? n : 0,
                this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: 0 < t ? 1 : -1
                })) : (1 == a ? this._setEndings(t = t < 0, !t, i) : this._setEndings(!1, !1, i),
                this._loopCount = r,
                this._mixer.dispatchEvent({
                    type: "loop",
                    action: this,
                    loopDelta: o
                }))),
                i && 1 == (1 & r))
                    return n - (this.time = e)
            }
            return this.time = e
        },
        _setEndings: function(t, e, n) {
            var i = this._interpolantSettings;
            n ? (i.endingStart = 2401,
            i.endingEnd = 2401) : (i.endingStart = t ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402,
            i.endingEnd = e ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
        },
        _scheduleFading: function(t, e, n) {
            var i = this._mixer
              , r = i.time
              , o = this._weightInterpolant;
            return null === o && (this._weightInterpolant = o = i._lendControlInterpolant()),
            i = o.parameterPositions,
            o = o.sampleValues,
            i[0] = r,
            o[0] = e,
            i[1] = r + t,
            o[1] = n,
            this
        }
    }),
    ir.prototype = Object.assign(Object.create(e.prototype), {
        constructor: ir,
        _bindAction: function(t, e) {
            var n = t._localRoot || this._root
              , i = t._clip.tracks
              , r = i.length
              , o = t._propertyBindings;
            t = t._interpolants;
            var a = n.uuid
              , s = this._bindingsByRootAndName
              , c = s[a];
            for (void 0 === c && (s[a] = c = {}),
            s = 0; s !== r; ++s) {
                var h = i[s]
                  , l = h.name
                  , u = c[l];
                if (void 0 === u) {
                    if (void 0 !== (u = o[s])) {
                        null === u._cacheIndex && (++u.referenceCount,
                        this._addInactiveBinding(u, a, l));
                        continue
                    }
                    ++(u = new Ki(tr.create(n, l, e && e._propertyBindings[s].binding.parsedPath),h.ValueTypeName,h.getValueSize())).referenceCount,
                    this._addInactiveBinding(u, a, l)
                }
                o[s] = u,
                t[s].resultBuffer = u.buffer
            }
        },
        _activateAction: function(t) {
            if (!this._isActiveAction(t)) {
                var e, n, i;
                for (null === t._cacheIndex && (e = (t._localRoot || this._root).uuid,
                n = t._clip.uuid,
                i = this._actionsByClip[n],
                this._bindAction(t, i && i.knownActions[0]),
                this._addInactiveAction(t, n, e)),
                n = 0,
                i = (e = t._propertyBindings).length; n !== i; ++n) {
                    var r = e[n];
                    0 == r.useCount++ && (this._lendBinding(r),
                    r.saveOriginalState())
                }
                this._lendAction(t)
            }
        },
        _deactivateAction: function(t) {
            if (this._isActiveAction(t)) {
                for (var e = t._propertyBindings, n = 0, i = e.length; n !== i; ++n) {
                    var r = e[n];
                    0 == --r.useCount && (r.restoreOriginalState(),
                    this._takeBackBinding(r))
                }
                this._takeBackAction(t)
            }
        },
        _initMemoryManager: function() {
            this._actions = [],
            this._nActiveActions = 0,
            this._actionsByClip = {},
            this._bindings = [],
            this._nActiveBindings = 0,
            this._bindingsByRootAndName = {},
            this._controlInterpolants = [],
            this._nActiveControlInterpolants = 0;
            var t = this;
            this.stats = {
                actions: {
                    get total() {
                        return t._actions.length
                    },
                    get inUse() {
                        return t._nActiveActions
                    }
                },
                bindings: {
                    get total() {
                        return t._bindings.length
                    },
                    get inUse() {
                        return t._nActiveBindings
                    }
                },
                controlInterpolants: {
                    get total() {
                        return t._controlInterpolants.length
                    },
                    get inUse() {
                        return t._nActiveControlInterpolants
                    }
                }
            }
        },
        _isActiveAction: function(t) {
            return null !== (t = t._cacheIndex) && t < this._nActiveActions
        },
        _addInactiveAction: function(t, e, n) {
            var i = this._actions
              , r = this._actionsByClip
              , o = r[e];
            void 0 === o ? (o = {
                knownActions: [t],
                actionByRoot: {}
            },
            t._byClipCacheIndex = 0,
            r[e] = o) : (e = o.knownActions,
            t._byClipCacheIndex = e.length,
            e.push(t)),
            t._cacheIndex = i.length,
            i.push(t),
            o.actionByRoot[n] = t
        },
        _removeInactiveAction: function(t) {
            var e = (i = this._actions)[i.length - 1]
              , n = t._cacheIndex;
            i[e._cacheIndex = n] = e,
            i.pop(),
            t._cacheIndex = null;
            var i = t._clip.uuid
              , r = (n = (e = this._actionsByClip)[i]).knownActions
              , o = r[r.length - 1]
              , a = t._byClipCacheIndex;
            r[o._byClipCacheIndex = a] = o,
            r.pop(),
            t._byClipCacheIndex = null,
            delete n.actionByRoot[(t._localRoot || this._root).uuid],
            0 === r.length && delete e[i],
            this._removeInactiveBindingsForAction(t)
        },
        _removeInactiveBindingsForAction: function(t) {
            for (var e = 0, n = (t = t._propertyBindings).length; e !== n; ++e) {
                var i = t[e];
                0 == --i.referenceCount && this._removeInactiveBinding(i)
            }
        },
        _lendAction: function(t) {
            var e = this._actions
              , n = t._cacheIndex
              , i = this._nActiveActions++
              , r = e[i];
            e[t._cacheIndex = i] = t,
            e[r._cacheIndex = n] = r
        },
        _takeBackAction: function(t) {
            var e = this._actions
              , n = t._cacheIndex
              , i = --this._nActiveActions
              , r = e[i];
            e[t._cacheIndex = i] = t,
            e[r._cacheIndex = n] = r
        },
        _addInactiveBinding: function(t, e, n) {
            var i = this._bindingsByRootAndName
              , r = i[e]
              , o = this._bindings;
            void 0 === r && (i[e] = r = {}),
            (r[n] = t)._cacheIndex = o.length,
            o.push(t)
        },
        _removeInactiveBinding: function(t) {
            var e = this._bindings
              , n = (i = t.binding).rootNode.uuid
              , i = i.path
              , r = this._bindingsByRootAndName
              , o = r[n]
              , a = e[e.length - 1];
            t = t._cacheIndex,
            e[a._cacheIndex = t] = a,
            e.pop(),
            delete o[i];
            t: {
                for (var s in o)
                    break t;
                delete r[n]
            }
        },
        _lendBinding: function(t) {
            var e = this._bindings
              , n = t._cacheIndex
              , i = this._nActiveBindings++
              , r = e[i];
            e[t._cacheIndex = i] = t,
            e[r._cacheIndex = n] = r
        },
        _takeBackBinding: function(t) {
            var e = this._bindings
              , n = t._cacheIndex
              , i = --this._nActiveBindings
              , r = e[i];
            e[t._cacheIndex = i] = t,
            e[r._cacheIndex = n] = r
        },
        _lendControlInterpolant: function() {
            var t = this._controlInterpolants
              , e = this._nActiveControlInterpolants++
              , n = t[e];
            return void 0 === n && (t[(n = new Pi(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer)).__cacheIndex = e] = n),
            n
        },
        _takeBackControlInterpolant: function(t) {
            var e = this._controlInterpolants
              , n = t.__cacheIndex
              , i = --this._nActiveControlInterpolants
              , r = e[i];
            e[t.__cacheIndex = i] = t,
            e[r.__cacheIndex = n] = r
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function(t, e) {
            var n = e || this._root
              , i = n.uuid;
            t = null !== (n = "string" == typeof t ? Bi.findByName(n, t) : t) ? n.uuid : t;
            var r = this._actionsByClip[t]
              , o = null;
            if (void 0 !== r) {
                if (void 0 !== (o = r.actionByRoot[i]))
                    return o;
                o = r.knownActions[0],
                null === n && (n = o._clip)
            }
            return null === n ? null : (e = new nr(this,n,e),
            this._bindAction(e, o),
            this._addInactiveAction(e, t, i),
            e)
        },
        existingAction: function(t, e) {
            var n = e || this._root;
            return e = n.uuid,
            n = "string" == typeof t ? Bi.findByName(n, t) : t,
            void 0 !== (t = this._actionsByClip[n ? n.uuid : t]) && t.actionByRoot[e] || null
        },
        stopAllAction: function() {
            for (var t = this._actions, e = this._nActiveActions, n = this._bindings, i = this._nActiveBindings, r = this._nActiveBindings = this._nActiveActions = 0; r !== e; ++r)
                t[r].reset();
            for (r = 0; r !== i; ++r)
                n[r].useCount = 0;
            return this
        },
        update: function(t) {
            t *= this.timeScale;
            for (var e = this._actions, n = this._nActiveActions, i = this.time += t, r = Math.sign(t), o = this._accuIndex ^= 1, a = 0; a !== n; ++a)
                e[a]._update(i, t, r, o);
            for (t = this._bindings,
            e = this._nActiveBindings,
            a = 0; a !== e; ++a)
                t[a].apply(o);
            return this
        },
        getRoot: function() {
            return this._root
        },
        uncacheClip: function(t) {
            var e = this._actions;
            t = t.uuid;
            var n = this._actionsByClip;
            if (void 0 !== (i = n[t])) {
                for (var i, r = 0, o = (i = i.knownActions).length; r !== o; ++r) {
                    var a = i[r];
                    this._deactivateAction(a);
                    var s = a._cacheIndex
                      , c = e[e.length - 1];
                    a._cacheIndex = null,
                    a._byClipCacheIndex = null,
                    e[c._cacheIndex = s] = c,
                    e.pop(),
                    this._removeInactiveBindingsForAction(a)
                }
                delete n[t]
            }
        },
        uncacheRoot: function(t) {
            t = t.uuid;
            var e = this._actionsByClip;
            for (i in e) {
                var n = e[i].actionByRoot[t];
                void 0 !== n && (this._deactivateAction(n),
                this._removeInactiveAction(n))
            }
            var i = this._bindingsByRootAndName[t];
            if (void 0 !== i)
                for (var r in i)
                    t = i[r],
                    t.restoreOriginalState(),
                    this._removeInactiveBinding(t)
        },
        uncacheAction: function(t, e) {
            null !== (t = this.existingAction(t, e)) && (this._deactivateAction(t),
            this._removeInactiveAction(t))
        }
    }),
    rr.prototype.clone = function() {
        return new rr(void 0 === this.value.clone ? this.value : this.value.clone())
    }
    ,
    or.prototype = Object.assign(Object.create(C.prototype), {
        constructor: or,
        isInstancedBufferGeometry: !0,
        copy: function(t) {
            return C.prototype.copy.call(this, t),
            this.maxInstancedCount = t.maxInstancedCount,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }),
    Object.defineProperties(ar.prototype, {
        count: {
            get: function() {
                return this.data.count
            }
        },
        array: {
            get: function() {
                return this.data.array
            }
        }
    }),
    Object.assign(ar.prototype, {
        isInterleavedBufferAttribute: !0,
        setX: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset] = e,
            this
        },
        setY: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 1] = e,
            this
        },
        setZ: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 2] = e,
            this
        },
        setW: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 3] = e,
            this
        },
        getX: function(t) {
            return this.data.array[t * this.data.stride + this.offset]
        },
        getY: function(t) {
            return this.data.array[t * this.data.stride + this.offset + 1]
        },
        getZ: function(t) {
            return this.data.array[t * this.data.stride + this.offset + 2]
        },
        getW: function(t) {
            return this.data.array[t * this.data.stride + this.offset + 3]
        },
        setXY: function(t, e, n) {
            return t = t * this.data.stride + this.offset,
            this.data.array[t + 0] = e,
            this.data.array[t + 1] = n,
            this
        },
        setXYZ: function(t, e, n, i) {
            return t = t * this.data.stride + this.offset,
            this.data.array[t + 0] = e,
            this.data.array[t + 1] = n,
            this.data.array[t + 2] = i,
            this
        },
        setXYZW: function(t, e, n, i, r) {
            return t = t * this.data.stride + this.offset,
            this.data.array[t + 0] = e,
            this.data.array[t + 1] = n,
            this.data.array[t + 2] = i,
            this.data.array[t + 3] = r,
            this
        }
    }),
    Object.defineProperty(sr.prototype, "needsUpdate", {
        set: function(t) {
            !0 === t && this.version++
        }
    }),
    Object.assign(sr.prototype, {
        isInterleavedBuffer: !0,
        onUploadCallback: function() {},
        setArray: function(t) {
            if (Array.isArray(t))
                throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            return this.count = void 0 !== t ? t.length / this.stride : 0,
            this.array = t,
            this
        },
        setDynamic: function(t) {
            return this.dynamic = t,
            this
        },
        copy: function(t) {
            return this.array = new t.array.constructor(t.array),
            this.count = t.count,
            this.stride = t.stride,
            this.dynamic = t.dynamic,
            this
        },
        copyAt: function(t, e, n) {
            t *= this.stride,
            n *= e.stride;
            for (var i = 0, r = this.stride; i < r; i++)
                this.array[t + i] = e.array[n + i];
            return this
        },
        set: function(t, e) {
            return this.array.set(t, e = void 0 === e ? 0 : e),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        onUpload: function(t) {
            return this.onUploadCallback = t,
            this
        }
    }),
    cr.prototype = Object.assign(Object.create(sr.prototype), {
        constructor: cr,
        isInstancedInterleavedBuffer: !0,
        copy: function(t) {
            return sr.prototype.copy.call(this, t),
            this.meshPerAttribute = t.meshPerAttribute,
            this
        }
    }),
    hr.prototype = Object.assign(Object.create(y.prototype), {
        constructor: hr,
        isInstancedBufferAttribute: !0,
        copy: function(t) {
            return y.prototype.copy.call(this, t),
            this.meshPerAttribute = t.meshPerAttribute,
            this
        }
    }),
    Object.assign(lr.prototype, {
        linePrecision: 1,
        set: function(t, e) {
            this.ray.set(t, e)
        },
        setFromCamera: function(t, e) {
            e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
            this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e),
            this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
        },
        intersectObject: function(t, e, n) {
            return dr(t, this, n = n || [], e),
            n.sort(ur),
            n
        },
        intersectObjects: function(t, e, n) {
            if (n = n || [],
            !1 === Array.isArray(t))
                return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),
                n;
            for (var i = 0, r = t.length; i < r; i++)
                dr(t[i], this, n, e);
            return n.sort(ur),
            n
        }
    }),
    Object.assign(pr.prototype, {
        start: function() {
            this.oldTime = this.startTime = ("undefined" == typeof performance ? Date : performance).now(),
            this.elapsedTime = 0,
            this.running = !0
        },
        stop: function() {
            this.getElapsedTime(),
            this.autoStart = this.running = !1
        },
        getElapsedTime: function() {
            return this.getDelta(),
            this.elapsedTime
        },
        getDelta: function() {
            var t, e = 0;
            return this.autoStart && !this.running ? (this.start(),
            0) : (this.running && (e = ((t = ("undefined" == typeof performance ? Date : performance).now()) - this.oldTime) / 1e3,
            this.oldTime = t,
            this.elapsedTime += e),
            e)
        }
    }),
    Object.assign(fr.prototype, {
        set: function(t, e, n) {
            return this.radius = t,
            this.phi = e,
            this.theta = n,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.radius = t.radius,
            this.phi = t.phi,
            this.theta = t.theta,
            this
        },
        makeSafe: function() {
            return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)),
            this
        },
        setFromVector3: function(t) {
            return this.radius = t.length(),
            0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(t.x, t.z),
            this.phi = Math.acos(io.clamp(t.y / this.radius, -1, 1))),
            this
        }
    }),
    Object.assign(mr.prototype, {
        set: function(t, e, n) {
            return this.radius = t,
            this.theta = e,
            this.y = n,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.radius = t.radius,
            this.theta = t.theta,
            this.y = t.y,
            this
        },
        setFromVector3: function(t) {
            return this.radius = Math.sqrt(t.x * t.x + t.z * t.z),
            this.theta = Math.atan2(t.x, t.z),
            this.y = t.y,
            this
        }
    }),
    Object.assign(gr.prototype, {
        set: function(t, e) {
            return this.min.copy(t),
            this.max.copy(e),
            this
        },
        setFromPoints: function(t) {
            this.makeEmpty();
            for (var e = 0, n = t.length; e < n; e++)
                this.expandByPoint(t[e]);
            return this
        },
        setFromCenterAndSize: (Gc = new W,
        function(t, e) {
            return e = Gc.copy(e).multiplyScalar(.5),
            this.min.copy(t).sub(e),
            this.max.copy(t).add(e),
            this
        }
        ),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.min.copy(t.min),
            this.max.copy(t.max),
            this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = 1 / 0,
            this.max.x = this.max.y = -1 / 0,
            this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y
        },
        getCenter: function(t) {
            return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"),
            t = new W),
            this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(t) {
            return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"),
            t = new W),
            this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
        },
        expandByPoint: function(t) {
            return this.min.min(t),
            this.max.max(t),
            this
        },
        expandByVector: function(t) {
            return this.min.sub(t),
            this.max.add(t),
            this
        },
        expandByScalar: function(t) {
            return this.min.addScalar(-t),
            this.max.addScalar(t),
            this
        },
        containsPoint: function(t) {
            return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
        },
        containsBox: function(t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
        },
        getParameter: function(t, e) {
            return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"),
            e = new W),
            e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
        },
        intersectsBox: function(t) {
            return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
        },
        clampPoint: function(t, e) {
            return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"),
            e = new W),
            e.copy(t).clamp(this.min, this.max)
        },
        distanceToPoint: (Hc = new W,
        function(t) {
            return Hc.copy(t).clamp(this.min, this.max).sub(t).length()
        }
        ),
        intersect: function(t) {
            return this.min.max(t.min),
            this.max.min(t.max),
            this
        },
        union: function(t) {
            return this.min.min(t.min),
            this.max.max(t.max),
            this
        },
        translate: function(t) {
            return this.min.add(t),
            this.max.add(t),
            this
        },
        equals: function(t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
        }
    }),
    ((vr.prototype = Object.create(l.prototype)).constructor = vr).prototype.isImmediateRenderObject = !0,
    ((yr.prototype = Object.create(Me.prototype)).constructor = yr).prototype.update = (kc = new wt,
    Vc = new wt,
    jc = new g,
    function() {
        var t = ["a", "b", "c"];
        this.object.updateMatrixWorld(!0),
        jc.getNormalMatrix(this.object.matrixWorld);
        var e = this.object.matrixWorld
          , n = this.geometry.attributes.position
          , i = this.object.geometry;
        if (i && i.isGeometry)
            for (var r = i.vertices, o = i.faces, a = i = 0, s = o.length; a < s; a++)
                for (var c = o[a], h = 0, l = c.vertexNormals.length; h < l; h++) {
                    var u = c.vertexNormals[h];
                    kc.copy(r[c[t[h]]]).applyMatrix4(e),
                    Vc.copy(u).applyMatrix3(jc).normalize().multiplyScalar(this.size).add(kc),
                    n.setXYZ(i, kc.x, kc.y, kc.z),
                    i += 1,
                    n.setXYZ(i, Vc.x, Vc.y, Vc.z),
                    i += 1
                }
        else if (i && i.isBufferGeometry)
            for (t = i.attributes.position,
            r = i.attributes.normal,
            h = i = 0,
            l = t.count; h < l; h++)
                kc.set(t.getX(h), t.getY(h), t.getZ(h)).applyMatrix4(e),
                Vc.set(r.getX(h), r.getY(h), r.getZ(h)),
                Vc.applyMatrix3(jc).normalize().multiplyScalar(this.size).add(kc),
                n.setXYZ(i, kc.x, kc.y, kc.z),
                n.setXYZ(i += 1, Vc.x, Vc.y, Vc.z),
                i += 1;
        n.needsUpdate = !0
    }
    ),
    ((xr.prototype = Object.create(l.prototype)).constructor = xr).prototype.dispose = function() {
        this.cone.geometry.dispose(),
        this.cone.material.dispose()
    }
    ,
    xr.prototype.update = (Wc = new wt,
    Xc = new wt,
    function() {
        this.light.updateMatrixWorld();
        var t = this.light.distance || 1e3
          , e = t * Math.tan(this.light.angle);
        this.cone.scale.set(e, e, t),
        Wc.setFromMatrixPosition(this.light.matrixWorld),
        Xc.setFromMatrixPosition(this.light.target.matrixWorld),
        this.cone.lookAt(Xc.sub(Wc)),
        void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
    }
    ),
    ((br.prototype = Object.create(Me.prototype)).constructor = br).prototype.updateMatrixWorld = (qc = new wt,
    Yc = new _t,
    Zc = new _t,
    function(t) {
        var e = this.bones
          , n = this.geometry
          , i = n.getAttribute("position");
        Zc.getInverse(this.root.matrixWorld);
        for (var r = 0, o = 0; r < e.length; r++) {
            var a = e[r];
            a.parent && a.parent.isBone && (Yc.multiplyMatrices(Zc, a.matrixWorld),
            qc.setFromMatrixPosition(Yc),
            i.setXYZ(o, qc.x, qc.y, qc.z),
            Yc.multiplyMatrices(Zc, a.parent.matrixWorld),
            qc.setFromMatrixPosition(Yc),
            i.setXYZ(o + 1, qc.x, qc.y, qc.z),
            o += 2)
        }
        n.getAttribute("position").needsUpdate = !0,
        l.prototype.updateMatrixWorld.call(this, t)
    }
    ),
    ((_r.prototype = Object.create(H.prototype)).constructor = _r).prototype.dispose = function() {
        this.geometry.dispose(),
        this.material.dispose()
    }
    ,
    _r.prototype.update = function() {
        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }
    ,
    ((wr.prototype = Object.create(l.prototype)).constructor = wr).prototype.dispose = function() {
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
    ,
    wr.prototype.update = function() {
        var t = .5 * this.light.width
          , e = .5 * this.light.height
          , n = this.line.geometry.attributes.position
          , i = n.array;
        i[0] = t,
        i[1] = -e,
        i[2] = 0,
        i[3] = t,
        i[4] = e,
        i[5] = 0,
        i[6] = -t,
        i[7] = e,
        i[8] = 0,
        i[9] = -t,
        i[10] = -e,
        i[11] = 0,
        i[12] = t,
        i[13] = -e,
        i[14] = 0,
        n.needsUpdate = !0,
        void 0 !== this.color ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color)
    }
    ,
    ((Er.prototype = Object.create(l.prototype)).constructor = Er).prototype.dispose = function() {
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
    ,
    Er.prototype.update = (Jc = new wt,
    Qc = new w,
    Kc = new w,
    function() {
        var t = this.children[0];
        if (void 0 !== this.color)
            this.material.color.set(this.color);
        else {
            var e = t.geometry.getAttribute("color");
            Qc.copy(this.light.color),
            Kc.copy(this.light.groundColor);
            for (var n = 0, i = e.count; n < i; n++) {
                var r = n < i / 2 ? Qc : Kc;
                e.setXYZ(n, r.r, r.g, r.b)
            }
            e.needsUpdate = !0
        }
        t.lookAt(Jc.setFromMatrixPosition(this.light.matrixWorld).negate())
    }
    ),
    (Mr.prototype = Object.create(Me.prototype)).constructor = Mr,
    (Tr.prototype = Object.create(Me.prototype)).constructor = Tr,
    ((Sr.prototype = Object.create(Me.prototype)).constructor = Sr).prototype.update = ($c = new wt,
    th = new wt,
    eh = new g,
    function() {
        this.object.updateMatrixWorld(!0),
        eh.getNormalMatrix(this.object.matrixWorld);
        for (var t = this.object.matrixWorld, e = this.geometry.attributes.position, n = this.object.geometry, i = n.vertices, r = 0, o = 0, a = (n = n.faces).length; o < a; o++) {
            var s = n[o]
              , c = s.normal;
            $c.copy(i[s.a]).add(i[s.b]).add(i[s.c]).divideScalar(3).applyMatrix4(t),
            th.copy(c).applyMatrix3(eh).normalize().multiplyScalar(this.size).add($c),
            e.setXYZ(r, $c.x, $c.y, $c.z),
            r += 1,
            e.setXYZ(r, th.x, th.y, th.z),
            r += 1
        }
        e.needsUpdate = !0
    }
    ),
    ((Ar.prototype = Object.create(l.prototype)).constructor = Ar).prototype.dispose = function() {
        this.lightPlane.geometry.dispose(),
        this.lightPlane.material.dispose(),
        this.targetLine.geometry.dispose(),
        this.targetLine.material.dispose()
    }
    ,
    Ar.prototype.update = (nh = new wt,
    ih = new wt,
    rh = new wt,
    function() {
        nh.setFromMatrixPosition(this.light.matrixWorld),
        ih.setFromMatrixPosition(this.light.target.matrixWorld),
        rh.subVectors(ih, nh),
        this.lightPlane.lookAt(rh),
        void 0 !== this.color ? (this.lightPlane.material.color.set(this.color),
        this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
        this.targetLine.material.color.copy(this.light.color)),
        this.targetLine.lookAt(rh),
        this.targetLine.scale.z = rh.length()
    }
    ),
    ((Rr.prototype = Object.create(Me.prototype)).constructor = Rr).prototype.update = (sh = new wt,
    ch = new s,
    function() {
        oh = this.geometry,
        ah = this.pointMap,
        ch.projectionMatrix.copy(this.camera.projectionMatrix),
        gh("c", 0, 0, -1),
        gh("t", 0, 0, 1),
        gh("n1", -1, -1, -1),
        gh("n2", 1, -1, -1),
        gh("n3", -1, 1, -1),
        gh("n4", 1, 1, -1),
        gh("f1", -1, -1, 1),
        gh("f2", 1, -1, 1),
        gh("f3", -1, 1, 1),
        gh("f4", 1, 1, 1),
        gh("u1", .7, 1.1, -1),
        gh("u2", -.7, 1.1, -1),
        gh("u3", 0, 2, -1),
        gh("cf1", -1, 0, 1),
        gh("cf2", 1, 0, 1),
        gh("cf3", 0, -1, 1),
        gh("cf4", 0, 1, 1),
        gh("cn1", -1, 0, -1),
        gh("cn2", 1, 0, -1),
        gh("cn3", 0, -1, -1),
        gh("cn4", 0, 1, -1),
        oh.getAttribute("position").needsUpdate = !0
    }
    ),
    ((Lr.prototype = Object.create(Me.prototype)).constructor = Lr).prototype.update = (hh = new n,
    function(t) {
        var e, n, i;
        void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."),
        void 0 !== this.object && hh.setFromObject(this.object),
        hh.isEmpty() || (t = hh.min,
        e = hh.max,
        (i = (n = this.geometry.attributes.position).array)[0] = e.x,
        i[1] = e.y,
        i[2] = e.z,
        i[3] = t.x,
        i[4] = e.y,
        i[5] = e.z,
        i[6] = t.x,
        i[7] = t.y,
        i[8] = e.z,
        i[9] = e.x,
        i[10] = t.y,
        i[11] = e.z,
        i[12] = e.x,
        i[13] = e.y,
        i[14] = t.z,
        i[15] = t.x,
        i[16] = e.y,
        i[17] = t.z,
        i[18] = t.x,
        i[19] = t.y,
        i[20] = t.z,
        i[21] = e.x,
        i[22] = t.y,
        i[23] = t.z,
        n.needsUpdate = !0,
        this.geometry.computeBoundingSphere())
    }
    ),
    Lr.prototype.setFromObject = function(t) {
        return this.object = t,
        this.update(),
        this
    }
    ,
    ((Cr.prototype = Object.create(Me.prototype)).constructor = Cr).prototype.updateMatrixWorld = function(t) {
        var e = this.box;
        e.isEmpty() || (e.getCenter(this.position),
        e.getSize(this.scale),
        this.scale.multiplyScalar(.5),
        l.prototype.updateMatrixWorld.call(this, t))
    }
    ,
    ((Pr.prototype = Object.create(Ee.prototype)).constructor = Pr).prototype.updateMatrixWorld = function(t) {
        var e = -this.plane.constant;
        Math.abs(e) < 1e-8 && (e = 1e-8),
        this.scale.set(.5 * this.size, .5 * this.size, e),
        this.lookAt(this.plane.normal),
        l.prototype.updateMatrixWorld.call(this, t)
    }
    ,
    ((Nr.prototype = Object.create(l.prototype)).constructor = Nr).prototype.setDirection = (ph = new wt,
    function(t) {
        .99999 < t.y ? this.quaternion.set(0, 0, 0, 1) : t.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (ph.set(t.z, 0, -t.x).normalize(),
        dh = Math.acos(t.y),
        this.quaternion.setFromAxisAngle(ph, dh))
    }
    ),
    Nr.prototype.setLength = function(t, e, n) {
        void 0 === e && (e = .2 * t),
        void 0 === n && (n = .2 * e),
        this.line.scale.set(1, Math.max(0, t - e), 1),
        this.line.updateMatrix(),
        this.cone.scale.set(n, e, n),
        this.cone.position.y = t,
        this.cone.updateMatrix()
    }
    ,
    Nr.prototype.setColor = function(t) {
        this.line.material.color.copy(t),
        this.cone.material.color.copy(t)
    }
    ,
    (Or.prototype = Object.create(Me.prototype)).constructor = Or,
    Zn.create = function(t, e) {
        return console.log("THREE.Curve.create() has been deprecated"),
        t.prototype = Object.create(Zn.prototype),
        (t.prototype.constructor = t).prototype.getPoint = e,
        t
    }
    ,
    Object.assign(li.prototype, {
        createPointsGeometry: function(t) {
            return console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."),
            t = this.getPoints(t),
            this.createGeometry(t)
        },
        createSpacedPointsGeometry: function(t) {
            return console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."),
            t = this.getSpacedPoints(t),
            this.createGeometry(t)
        },
        createGeometry: function(t) {
            console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            for (var e = new M, n = 0, i = t.length; n < i; n++) {
                var r = t[n];
                e.vertices.push(new wt(r.x,r.y,r.z || 0))
            }
            return e
        }
    }),
    Object.assign(ui.prototype, {
        fromPoints: function(t) {
            console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),
            this.setFromPoints(t)
        }
    }),
    Ir.prototype = Object.create($n.prototype),
    Br.prototype = Object.create($n.prototype),
    Ur.prototype = Object.create($n.prototype),
    Object.assign(Ur.prototype, {
        initFromArray: function() {
            console.error("THREE.Spline: .initFromArray() has been removed.")
        },
        getControlPointsArray: function() {
            console.error("THREE.Spline: .getControlPointsArray() has been removed.")
        },
        reparametrizeByArcLength: function() {
            console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
        }
    }),
    Mr.prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
    }
    ,
    br.prototype.update = function() {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
    }
    ,
    Object.assign(Fi.prototype, {
        extractUrlBase: function(t) {
            return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),
            pc.extractUrlBase(t)
        }
    }),
    Object.assign(gr.prototype, {
        center: function(t) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),
            this.getCenter(t)
        },
        empty: function() {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
            this.isEmpty()
        },
        isIntersectionBox: function(t) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(t)
        },
        size: function(t) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
            this.getSize(t)
        }
    }),
    Object.assign(n.prototype, {
        center: function(t) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),
            this.getCenter(t)
        },
        empty: function() {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
            this.isEmpty()
        },
        isIntersectionBox: function(t) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(t)
        },
        isIntersectionSphere: function(t) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
            this.intersectsSphere(t)
        },
        size: function(t) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
            this.getSize(t)
        }
    }),
    F.prototype.center = function(t) {
        return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),
        this.getCenter(t)
    }
    ,
    Object.assign(io, {
        random16: function() {
            return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),
            Math.random()
        },
        nearestPowerOfTwo: function(t) {
            return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),
            io.floorPowerOfTwo(t)
        },
        nextPowerOfTwo: function(t) {
            return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),
            io.ceilPowerOfTwo(t)
        }
    }),
    Object.assign(g.prototype, {
        flattenToArrayOffset: function(t, e) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
            this.toArray(t, e)
        },
        multiplyVector3: function(t) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),
            t.applyMatrix3(this)
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
        },
        applyToBuffer: function(t) {
            return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."),
            this.applyToBufferAttribute(t)
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        }
    }),
    Object.assign(_t.prototype, {
        extractPosition: function(t) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),
            this.copyPosition(t)
        },
        flattenToArrayOffset: function(t, e) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
            this.toArray(t, e)
        },
        getPosition: function() {
            return void 0 === fh && (fh = new wt),
            console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),
            fh.setFromMatrixColumn(this, 3)
        },
        setRotationFromQuaternion: function(t) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),
            this.makeRotationFromQuaternion(t)
        },
        multiplyToArray: function() {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
        },
        multiplyVector3: function(t) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            t.applyMatrix4(this)
        },
        multiplyVector4: function(t) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            t.applyMatrix4(this)
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
        },
        rotateAxis: function(t) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),
            t.transformDirection(this)
        },
        crossVector: function(t) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            t.applyMatrix4(this)
        },
        translate: function() {
            console.error("THREE.Matrix4: .translate() has been removed.")
        },
        rotateX: function() {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        },
        rotateY: function() {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        },
        rotateZ: function() {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        },
        rotateByAxis: function() {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        },
        applyToBuffer: function(t) {
            return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."),
            this.applyToBufferAttribute(t)
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        },
        makeFrustum: function(t, e, n, i, r, o) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),
            this.makePerspective(t, e, i, n, r, o)
        }
    }),
    v.prototype.isIntersectionLine = function(t) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),
        this.intersectsLine(t)
    }
    ,
    V.prototype.multiplyVector3 = function(t) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),
        t.applyQuaternion(this)
    }
    ,
    Object.assign(D.prototype, {
        isIntersectionBox: function(t) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(t)
        },
        isIntersectionPlane: function(t) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),
            this.intersectsPlane(t)
        },
        isIntersectionSphere: function(t) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
            this.intersectsSphere(t)
        }
    }),
    Object.assign(z.prototype, {
        area: function() {
            return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),
            this.getArea()
        },
        barycoordFromPoint: function(t, e) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
            this.getBarycoord(t, e)
        },
        midpoint: function(t) {
            return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),
            this.getMidpoint(t)
        },
        normal: function(t) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
            this.getNormal(t)
        },
        plane: function(t) {
            return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),
            this.getPlane(t)
        }
    }),
    Object.assign(z, {
        barycoordFromPoint: function(t, e, n, i, r) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
            z.getBarycoord(t, e, n, i, r)
        },
        normal: function(t, e, n, i) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
            z.getNormal(t, e, n, i)
        }
    }),
    Object.assign(di.prototype, {
        extractAllPoints: function(t) {
            return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),
            this.extractPoints(t)
        },
        extrude: function(t) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),
            new pn(this,t)
        },
        makeGeometry: function(t) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),
            new En(this,t)
        }
    }),
    Object.assign(W.prototype, {
        fromAttribute: function(t, e, n) {
            return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(t, e, n)
        },
        distanceToManhattan: function(t) {
            return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
            this.manhattanDistanceTo(t)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
    }),
    Object.assign(wt.prototype, {
        setEulerFromRotationMatrix: function() {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        },
        setEulerFromQuaternion: function() {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        },
        getPositionFromMatrix: function(t) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),
            this.setFromMatrixPosition(t)
        },
        getScaleFromMatrix: function(t) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),
            this.setFromMatrixScale(t)
        },
        getColumnFromMatrix: function(t, e) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),
            this.setFromMatrixColumn(e, t)
        },
        applyProjection: function(t) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),
            this.applyMatrix4(t)
        },
        fromAttribute: function(t, e, n) {
            return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(t, e, n)
        },
        distanceToManhattan: function(t) {
            return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
            this.manhattanDistanceTo(t)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
    }),
    Object.assign(Et.prototype, {
        fromAttribute: function(t, e, n) {
            return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(t, e, n)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
    }),
    Object.assign(M.prototype, {
        computeTangents: function() {
            console.error("THREE.Geometry: .computeTangents() has been removed.")
        },
        computeLineDistances: function() {
            console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
        }
    }),
    Object.assign(l.prototype, {
        getChildByName: function(t) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),
            this.getObjectByName(t)
        },
        renderDepth: function() {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        },
        translate: function(t, e) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),
            this.translateOnAxis(e, t)
        },
        getWorldRotation: function() {
            console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
        }
    }),
    Object.defineProperties(l.prototype, {
        eulerOrder: {
            get: function() {
                return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                this.rotation.order
            },
            set: function(t) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                this.rotation.order = t
            }
        },
        useQuaternion: {
            get: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            },
            set: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }
        }
    }),
    Object.defineProperties(ye.prototype, {
        objects: {
            get: function() {
                return console.warn("THREE.LOD: .objects has been renamed to .levels."),
                this.levels
            }
        }
    }),
    Object.defineProperty(xe.prototype, "useVertexTexture", {
        get: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        },
        set: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        }
    }),
    Object.defineProperty(Zn.prototype, "__arcLengthDivisions", {
        get: function() {
            return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
            this.arcLengthDivisions
        },
        set: function(t) {
            console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
            this.arcLengthDivisions = t
        }
    }),
    he.prototype.setLens = function(t, e) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),
        void 0 !== e && (this.filmGauge = e),
        this.setFocalLength(t)
    }
    ,
    Object.defineProperties(pi.prototype, {
        onlyShadow: {
            set: function() {
                console.warn("THREE.Light: .onlyShadow has been removed.")
            }
        },
        shadowCameraFov: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
                this.shadow.camera.fov = t
            }
        },
        shadowCameraLeft: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),
                this.shadow.camera.left = t
            }
        },
        shadowCameraRight: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),
                this.shadow.camera.right = t
            }
        },
        shadowCameraTop: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
                this.shadow.camera.top = t
            }
        },
        shadowCameraBottom: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),
                this.shadow.camera.bottom = t
            }
        },
        shadowCameraNear: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),
                this.shadow.camera.near = t
            }
        },
        shadowCameraFar: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
                this.shadow.camera.far = t
            }
        },
        shadowCameraVisible: {
            set: function() {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
            }
        },
        shadowBias: {
            set: function(t) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
                this.shadow.bias = t
            }
        },
        shadowDarkness: {
            set: function() {
                console.warn("THREE.Light: .shadowDarkness has been removed.")
            }
        },
        shadowMapWidth: {
            set: function(t) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),
                this.shadow.mapSize.width = t
            }
        },
        shadowMapHeight: {
            set: function(t) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),
                this.shadow.mapSize.height = t
            }
        }
    }),
    Object.defineProperties(y.prototype, {
        length: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),
                this.array.length
            }
        },
        copyIndicesArray: function() {
            console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
        }
    }),
    Object.assign(C.prototype, {
        addIndex: function(t) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),
            this.setIndex(t)
        },
        addDrawCall: function(t, e, n) {
            void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),
            console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
            this.addGroup(t, e)
        },
        clearDrawCalls: function() {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),
            this.clearGroups()
        },
        computeTangents: function() {
            console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
        },
        computeOffsets: function() {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        }
    }),
    Object.defineProperties(C.prototype, {
        drawcalls: {
            get: function() {
                return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),
                this.groups
            }
        },
        offsets: {
            get: function() {
                return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),
                this.groups
            }
        }
    }),
    Object.assign(fn.prototype, {
        getArrays: function() {
            console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
        },
        addShapeList: function() {
            console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
        },
        addShape: function() {
            console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
        }
    }),
    Object.defineProperties(rr.prototype, {
        dynamic: {
            set: function() {
                console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
            }
        },
        onUpdate: {
            value: function() {
                return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),
                this
            }
        }
    }),
    Object.defineProperties(I.prototype, {
        wrapAround: {
            get: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            }
        },
        wrapRGB: {
            get: function() {
                return console.warn("THREE.Material: .wrapRGB has been removed."),
                new w
            }
        },
        shading: {
            get: function() {
                console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
            },
            set: function(t) {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                this.flatShading = 1 === t
            }
        }
    }),
    Object.defineProperties(Dn.prototype, {
        metal: {
            get: function() {
                return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),
                !1
            },
            set: function() {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
            }
        }
    }),
    Object.defineProperties(U.prototype, {
        derivatives: {
            get: function() {
                return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                this.extensions.derivatives
            },
            set: function(t) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                this.extensions.derivatives = t
            }
        }
    }),
    Object.assign(de.prototype, {
        getCurrentRenderTarget: function() {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),
            this.getRenderTarget()
        },
        getMaxAnisotropy: function() {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),
            this.capabilities.getMaxAnisotropy()
        },
        getPrecision: function() {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),
            this.capabilities.precision
        },
        resetGLState: function() {
            return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),
            this.state.reset()
        },
        supportsFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),
            this.extensions.get("OES_texture_float")
        },
        supportsHalfFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),
            this.extensions.get("OES_texture_half_float")
        },
        supportsStandardDerivatives: function() {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),
            this.extensions.get("OES_standard_derivatives")
        },
        supportsCompressedTextureS3TC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),
            this.extensions.get("WEBGL_compressed_texture_s3tc")
        },
        supportsCompressedTexturePVRTC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),
            this.extensions.get("WEBGL_compressed_texture_pvrtc")
        },
        supportsBlendMinMax: function() {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),
            this.extensions.get("EXT_blend_minmax")
        },
        supportsVertexTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),
            this.capabilities.vertexTextures
        },
        supportsInstancedArrays: function() {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),
            this.extensions.get("ANGLE_instanced_arrays")
        },
        enableScissorTest: function(t) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),
            this.setScissorTest(t)
        },
        initMaterial: function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        },
        addPrePlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        },
        addPostPlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        },
        updateShadowMap: function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        },
        setFaceCulling: function() {
            console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
        }
    }),
    Object.defineProperties(de.prototype, {
        shadowMapEnabled: {
            get: function() {
                return this.shadowMap.enabled
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),
                this.shadowMap.enabled = t
            }
        },
        shadowMapType: {
            get: function() {
                return this.shadowMap.type
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),
                this.shadowMap.type = t
            }
        },
        shadowMapCullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            }
        }
    }),
    Object.defineProperties(ie.prototype, {
        cullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        renderReverseSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            }
        },
        renderSingleSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            }
        }
    }),
    Object.defineProperties(S.prototype, {
        wrapS: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                this.texture.wrapS
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                this.texture.wrapS = t
            }
        },
        wrapT: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                this.texture.wrapT
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                this.texture.wrapT = t
            }
        },
        magFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                this.texture.magFilter
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                this.texture.magFilter = t
            }
        },
        minFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                this.texture.minFilter
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                this.texture.minFilter = t
            }
        },
        anisotropy: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                this.texture.anisotropy
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                this.texture.anisotropy = t
            }
        },
        offset: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                this.texture.offset
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                this.texture.offset = t
            }
        },
        repeat: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                this.texture.repeat
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                this.texture.repeat = t
            }
        },
        format: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                this.texture.format
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                this.texture.format = t
            }
        },
        type: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                this.texture.type
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                this.texture.type = t
            }
        },
        generateMipmaps: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                this.texture.generateMipmaps
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                this.texture.generateMipmaps = t
            }
        }
    }),
    Object.defineProperties(ue.prototype, {
        standing: {
            set: function() {
                console.warn("THREE.WebVRManager: .standing has been removed.")
            }
        }
    }),
    Zi.prototype.load = function(t) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        var e = this;
        return (new Wi).load(t, function(t) {
            e.setBuffer(t)
        }),
        this
    }
    ,
    Qi.prototype.getData = function() {
        return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),
        this.getFrequencyData()
    }
    ,
    qi.prototype.updateCubeMap = function(t, e) {
        return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
        this.update(t, e)
    }
    ,
    t.WebGLRenderTargetCube = i,
    t.WebGLRenderTarget = S,
    t.WebGLRenderer = de,
    t.ShaderLib = qo,
    t.UniformsLib = Xo,
    t.UniformsUtils = Go,
    t.ShaderChunk = Ho,
    t.FogExp2 = pe,
    t.Fog = fe,
    t.Scene = me,
    t.Sprite = ve,
    t.LOD = ye,
    t.SkinnedMesh = _e,
    t.Skeleton = xe,
    t.Bone = be,
    t.Mesh = H,
    t.LineSegments = Me,
    t.LineLoop = Te,
    t.Line = Ee,
    t.Points = Ae,
    t.Group = Re,
    t.VideoTexture = Le,
    t.DataTexture = Mt,
    t.CompressedTexture = Ce,
    t.CubeTexture = k,
    t.CanvasTexture = re,
    t.DepthTexture = Pe,
    t.Texture = d,
    t.CompressedTextureLoader = jn,
    t.DataTextureLoader = Wn,
    t.CubeTextureLoader = qn,
    t.TextureLoader = Yn,
    t.ObjectLoader = Hi,
    t.MaterialLoader = Ui,
    t.BufferGeometryLoader = Di,
    t.DefaultLoadingManager = tc,
    t.LoadingManager = kn,
    t.JSONLoader = zi,
    t.ImageLoader = Xn,
    t.ImageBitmapLoader = Gi,
    t.FontLoader = ji,
    t.FileLoader = Vn,
    t.Loader = Fi,
    t.LoaderUtils = pc,
    t.Cache = $s,
    t.AudioLoader = Wi,
    t.SpotLightShadow = gi,
    t.SpotLight = vi,
    t.PointLight = yi,
    t.RectAreaLight = wi,
    t.HemisphereLight = fi,
    t.DirectionalLightShadow = xi,
    t.DirectionalLight = bi,
    t.AmbientLight = _i,
    t.LightShadow = mi,
    t.Light = pi,
    t.StereoCamera = Xi,
    t.PerspectiveCamera = he,
    t.OrthographicCamera = p,
    t.CubeCamera = qi,
    t.ArrayCamera = le,
    t.Camera = s,
    t.AudioListener = Yi,
    t.PositionalAudio = Ji,
    t.AudioContext = mh,
    t.AudioAnalyser = Qi,
    t.Audio = Zi,
    t.VectorKeyframeTrack = Ii,
    t.StringKeyframeTrack = Ei,
    t.QuaternionKeyframeTrack = Ai,
    t.NumberKeyframeTrack = Li,
    t.ColorKeyframeTrack = Ri,
    t.BooleanKeyframeTrack = Mi,
    t.PropertyMixer = Ki,
    t.PropertyBinding = tr,
    t.KeyframeTrack = Oi,
    t.AnimationUtils = sc,
    t.AnimationObjectGroup = er,
    t.AnimationMixer = ir,
    t.AnimationClip = Bi,
    t.Uniform = rr,
    t.InstancedBufferGeometry = or,
    t.BufferGeometry = C,
    t.Geometry = M,
    t.InterleavedBufferAttribute = ar,
    t.InstancedInterleavedBuffer = cr,
    t.InterleavedBuffer = sr,
    t.InstancedBufferAttribute = hr,
    t.Face3 = E,
    t.Object3D = l,
    t.Raycaster = lr,
    t.Layers = o,
    t.EventDispatcher = e,
    t.Clock = pr,
    t.QuaternionLinearInterpolant = Si,
    t.LinearInterpolant = Pi,
    t.DiscreteInterpolant = Ni,
    t.CubicInterpolant = Ci,
    t.Interpolant = Ti,
    t.Triangle = z,
    t.Math = io,
    t.Spherical = fr,
    t.Cylindrical = mr,
    t.Plane = v,
    t.Frustum = Tt,
    t.Sphere = a,
    t.Ray = D,
    t.Matrix4 = _t,
    t.Matrix3 = g,
    t.Box3 = n,
    t.Box2 = gr,
    t.Line3 = F,
    t.Euler = r,
    t.Vector4 = Et,
    t.Vector3 = wt,
    t.Vector2 = W,
    t.Quaternion = V,
    t.Color = w,
    t.ImmediateRenderObject = vr,
    t.VertexNormalsHelper = yr,
    t.SpotLightHelper = xr,
    t.SkeletonHelper = br,
    t.PointLightHelper = _r,
    t.RectAreaLightHelper = wr,
    t.HemisphereLightHelper = Er,
    t.GridHelper = Mr,
    t.PolarGridHelper = Tr,
    t.FaceNormalsHelper = Sr,
    t.DirectionalLightHelper = Ar,
    t.CameraHelper = Rr,
    t.BoxHelper = Lr,
    t.Box3Helper = Cr,
    t.PlaneHelper = Pr,
    t.ArrowHelper = Nr,
    t.AxesHelper = Or,
    t.Shape = di,
    t.Path = ui,
    t.ShapePath = ki,
    t.Font = Vi,
    t.CurvePath = li,
    t.Curve = Zn,
    t.ShapeUtils = Zs,
    t.WebGLUtils = ce,
    t.WireframeGeometry = Ne,
    t.ParametricGeometry = Oe,
    t.ParametricBufferGeometry = Ie,
    t.TetrahedronGeometry = De,
    t.TetrahedronBufferGeometry = Fe,
    t.OctahedronGeometry = ze,
    t.OctahedronBufferGeometry = He,
    t.IcosahedronGeometry = Ge,
    t.IcosahedronBufferGeometry = ke,
    t.DodecahedronGeometry = Ve,
    t.DodecahedronBufferGeometry = je,
    t.PolyhedronGeometry = Be,
    t.PolyhedronBufferGeometry = Ue,
    t.TubeGeometry = We,
    t.TubeBufferGeometry = Xe,
    t.TorusKnotGeometry = qe,
    t.TorusKnotBufferGeometry = Ye,
    t.TorusGeometry = Ze,
    t.TorusBufferGeometry = Je,
    t.TextGeometry = mn,
    t.TextBufferGeometry = gn,
    t.SphereGeometry = vn,
    t.SphereBufferGeometry = yn,
    t.RingGeometry = xn,
    t.RingBufferGeometry = bn,
    t.PlaneGeometry = N,
    t.PlaneBufferGeometry = O,
    t.LatheGeometry = _n,
    t.LatheBufferGeometry = wn,
    t.ShapeGeometry = En,
    t.ShapeBufferGeometry = Mn,
    t.ExtrudeGeometry = pn,
    t.ExtrudeBufferGeometry = fn,
    t.EdgesGeometry = Sn,
    t.ConeGeometry = Ln,
    t.ConeBufferGeometry = Cn,
    t.CylinderGeometry = An,
    t.CylinderBufferGeometry = Rn,
    t.CircleGeometry = Pn,
    t.CircleBufferGeometry = Nn,
    t.BoxGeometry = R,
    t.BoxBufferGeometry = P,
    t.ShadowMaterial = On,
    t.SpriteMaterial = ge,
    t.RawShaderMaterial = In,
    t.ShaderMaterial = U,
    t.PointsMaterial = Se,
    t.MeshPhysicalMaterial = Un,
    t.MeshStandardMaterial = Bn,
    t.MeshPhongMaterial = Dn,
    t.MeshToonMaterial = Fn,
    t.MeshNormalMaterial = zn,
    t.MeshLambertMaterial = Hn,
    t.MeshDepthMaterial = ee,
    t.MeshDistanceMaterial = ne,
    t.MeshBasicMaterial = B,
    t.LineDashedMaterial = Gn,
    t.LineBasicMaterial = we,
    t.Material = I,
    t.Float64BufferAttribute = _,
    t.Float32BufferAttribute = L,
    t.Uint32BufferAttribute = b,
    t.Int32BufferAttribute = x,
    t.Uint16BufferAttribute = m,
    t.Int16BufferAttribute = f,
    t.Uint8ClampedBufferAttribute = u,
    t.Uint8BufferAttribute = h,
    t.Int8BufferAttribute = c,
    t.BufferAttribute = y,
    t.ArcCurve = Qn,
    t.CatmullRomCurve3 = $n,
    t.CubicBezierCurve = ii,
    t.CubicBezierCurve3 = ri,
    t.EllipseCurve = Jn,
    t.LineCurve = oi,
    t.LineCurve3 = ai,
    t.QuadraticBezierCurve = si,
    t.QuadraticBezierCurve3 = ci,
    t.SplineCurve = hi,
    t.REVISION = "92",
    t.MOUSE = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2
    },
    t.CullFaceNone = 0,
    t.CullFaceBack = 1,
    t.CullFaceFront = 2,
    t.CullFaceFrontBack = 3,
    t.FrontFaceDirectionCW = 0,
    t.FrontFaceDirectionCCW = 1,
    t.BasicShadowMap = 0,
    t.PCFShadowMap = 1,
    t.PCFSoftShadowMap = 2,
    t.FrontSide = 0,
    t.BackSide = 1,
    t.DoubleSide = 2,
    t.FlatShading = 1,
    t.SmoothShading = 2,
    t.NoColors = 0,
    t.FaceColors = 1,
    t.VertexColors = 2,
    t.NoBlending = 0,
    t.NormalBlending = 1,
    t.AdditiveBlending = 2,
    t.SubtractiveBlending = 3,
    t.MultiplyBlending = 4,
    t.CustomBlending = 5,
    t.AddEquation = 100,
    t.SubtractEquation = 101,
    t.ReverseSubtractEquation = 102,
    t.MinEquation = 103,
    t.MaxEquation = 104,
    t.ZeroFactor = 200,
    t.OneFactor = 201,
    t.SrcColorFactor = 202,
    t.OneMinusSrcColorFactor = 203,
    t.SrcAlphaFactor = 204,
    t.OneMinusSrcAlphaFactor = 205,
    t.DstAlphaFactor = 206,
    t.OneMinusDstAlphaFactor = 207,
    t.DstColorFactor = 208,
    t.OneMinusDstColorFactor = 209,
    t.SrcAlphaSaturateFactor = 210,
    t.NeverDepth = 0,
    t.AlwaysDepth = 1,
    t.LessDepth = 2,
    t.LessEqualDepth = 3,
    t.EqualDepth = 4,
    t.GreaterEqualDepth = 5,
    t.GreaterDepth = 6,
    t.NotEqualDepth = 7,
    t.MultiplyOperation = 0,
    t.MixOperation = 1,
    t.AddOperation = 2,
    t.NoToneMapping = 0,
    t.LinearToneMapping = 1,
    t.ReinhardToneMapping = 2,
    t.Uncharted2ToneMapping = 3,
    t.CineonToneMapping = 4,
    t.UVMapping = 300,
    t.CubeReflectionMapping = 301,
    t.CubeRefractionMapping = 302,
    t.EquirectangularReflectionMapping = 303,
    t.EquirectangularRefractionMapping = 304,
    t.SphericalReflectionMapping = 305,
    t.CubeUVReflectionMapping = 306,
    t.CubeUVRefractionMapping = 307,
    t.RepeatWrapping = 1e3,
    t.ClampToEdgeWrapping = 1001,
    t.MirroredRepeatWrapping = 1002,
    t.NearestFilter = 1003,
    t.NearestMipMapNearestFilter = 1004,
    t.NearestMipMapLinearFilter = 1005,
    t.LinearFilter = 1006,
    t.LinearMipMapNearestFilter = 1007,
    t.LinearMipMapLinearFilter = 1008,
    t.UnsignedByteType = 1009,
    t.ByteType = 1010,
    t.ShortType = 1011,
    t.UnsignedShortType = 1012,
    t.IntType = 1013,
    t.UnsignedIntType = 1014,
    t.FloatType = 1015,
    t.HalfFloatType = 1016,
    t.UnsignedShort4444Type = 1017,
    t.UnsignedShort5551Type = 1018,
    t.UnsignedShort565Type = 1019,
    t.UnsignedInt248Type = 1020,
    t.AlphaFormat = 1021,
    t.RGBFormat = 1022,
    t.RGBAFormat = 1023,
    t.LuminanceFormat = 1024,
    t.LuminanceAlphaFormat = 1025,
    t.RGBEFormat = 1023,
    t.DepthFormat = 1026,
    t.DepthStencilFormat = 1027,
    t.RGB_S3TC_DXT1_Format = 33776,
    t.RGBA_S3TC_DXT1_Format = 33777,
    t.RGBA_S3TC_DXT3_Format = 33778,
    t.RGBA_S3TC_DXT5_Format = 33779,
    t.RGB_PVRTC_4BPPV1_Format = 35840,
    t.RGB_PVRTC_2BPPV1_Format = 35841,
    t.RGBA_PVRTC_4BPPV1_Format = 35842,
    t.RGBA_PVRTC_2BPPV1_Format = 35843,
    t.RGB_ETC1_Format = 36196,
    t.RGBA_ASTC_4x4_Format = 37808,
    t.RGBA_ASTC_5x4_Format = 37809,
    t.RGBA_ASTC_5x5_Format = 37810,
    t.RGBA_ASTC_6x5_Format = 37811,
    t.RGBA_ASTC_6x6_Format = 37812,
    t.RGBA_ASTC_8x5_Format = 37813,
    t.RGBA_ASTC_8x6_Format = 37814,
    t.RGBA_ASTC_8x8_Format = 37815,
    t.RGBA_ASTC_10x5_Format = 37816,
    t.RGBA_ASTC_10x6_Format = 37817,
    t.RGBA_ASTC_10x8_Format = 37818,
    t.RGBA_ASTC_10x10_Format = 37819,
    t.RGBA_ASTC_12x10_Format = 37820,
    t.RGBA_ASTC_12x12_Format = 37821,
    t.LoopOnce = 2200,
    t.LoopRepeat = 2201,
    t.LoopPingPong = 2202,
    t.InterpolateDiscrete = 2300,
    t.InterpolateLinear = 2301,
    t.InterpolateSmooth = 2302,
    t.ZeroCurvatureEnding = 2400,
    t.ZeroSlopeEnding = 2401,
    t.WrapAroundEnding = 2402,
    t.TrianglesDrawMode = 0,
    t.TriangleStripDrawMode = 1,
    t.TriangleFanDrawMode = 2,
    t.LinearEncoding = 3e3,
    t.sRGBEncoding = 3001,
    t.GammaEncoding = 3007,
    t.RGBEEncoding = 3002,
    t.LogLuvEncoding = 3003,
    t.RGBM7Encoding = 3004,
    t.RGBM16Encoding = 3005,
    t.RGBDEncoding = 3006,
    t.BasicDepthPacking = 3200,
    t.RGBADepthPacking = 3201,
    t.CubeGeometry = R,
    t.Face4 = function(t, e, n, i, r, o, a) {
        return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."),
        new E(t,e,n,r,o,a)
    }
    ,
    t.LineStrip = 0,
    t.LinePieces = 1,
    t.MeshFaceMaterial = function(t) {
        return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),
        t
    }
    ,
    t.MultiMaterial = function(t) {
        return void 0 === t && (t = []),
        console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),
        t.isMultiMaterial = !0,
        (t.materials = t).clone = function() {
            return t.slice()
        }
        ,
        t
    }
    ,
    t.PointCloud = function(t, e) {
        return console.warn("THREE.PointCloud has been renamed to THREE.Points."),
        new Ae(t,e)
    }
    ,
    t.Particle = function(t) {
        return console.warn("THREE.Particle has been renamed to THREE.Sprite."),
        new ve(t)
    }
    ,
    t.ParticleSystem = function(t, e) {
        return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),
        new Ae(t,e)
    }
    ,
    t.PointCloudMaterial = function(t) {
        return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),
        new Se(t)
    }
    ,
    t.ParticleBasicMaterial = function(t) {
        return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),
        new Se(t)
    }
    ,
    t.ParticleSystemMaterial = function(t) {
        return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),
        new Se(t)
    }
    ,
    t.Vertex = function(t, e, n) {
        return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),
        new wt(t,e,n)
    }
    ,
    t.DynamicBufferAttribute = function(t, e) {
        return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."),
        new y(t,e).setDynamic(!0)
    }
    ,
    t.Int8Attribute = function(t, e) {
        return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),
        new c(t,e)
    }
    ,
    t.Uint8Attribute = function(t, e) {
        return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),
        new h(t,e)
    }
    ,
    t.Uint8ClampedAttribute = function(t, e) {
        return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),
        new u(t,e)
    }
    ,
    t.Int16Attribute = function(t, e) {
        return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),
        new f(t,e)
    }
    ,
    t.Uint16Attribute = function(t, e) {
        return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),
        new m(t,e)
    }
    ,
    t.Int32Attribute = function(t, e) {
        return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),
        new x(t,e)
    }
    ,
    t.Uint32Attribute = function(t, e) {
        return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),
        new b(t,e)
    }
    ,
    t.Float32Attribute = function(t, e) {
        return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),
        new L(t,e)
    }
    ,
    t.Float64Attribute = function(t, e) {
        return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),
        new _(t,e)
    }
    ,
    t.ClosedSplineCurve3 = Ir,
    t.SplineCurve3 = Br,
    t.Spline = Ur,
    t.AxisHelper = function(t) {
        return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),
        new Or(t)
    }
    ,
    t.BoundingBoxHelper = function(t, e) {
        return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),
        new Lr(t,e)
    }
    ,
    t.EdgesHelper = function(t, e) {
        return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),
        new Me(new Sn(t.geometry),new we({
            color: void 0 !== e ? e : 16777215
        }))
    }
    ,
    t.WireframeHelper = function(t, e) {
        return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),
        new Me(new Ne(t.geometry),new we({
            color: void 0 !== e ? e : 16777215
        }))
    }
    ,
    t.XHRLoader = function(t) {
        return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),
        new Vn(t)
    }
    ,
    t.BinaryTextureLoader = function(t) {
        return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),
        new Wn(t)
    }
    ,
    t.GeometryUtils = {
        merge: function(t, e, n) {
            var i;
            console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."),
            e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(),
            i = e.matrix,
            e = e.geometry),
            t.merge(e, i, n)
        },
        center: function(t) {
            return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."),
            t.center()
        }
    },
    t.ImageUtils = {
        crossOrigin: void 0,
        loadTexture: function(t, e, n, i) {
            console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
            var r = new Yn;
            return r.setCrossOrigin(this.crossOrigin),
            t = r.load(t, n, void 0, i),
            e && (t.mapping = e),
            t
        },
        loadTextureCube: function(t, e, n, i) {
            console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
            var r = new qn;
            return r.setCrossOrigin(this.crossOrigin),
            t = r.load(t, n, void 0, i),
            e && (t.mapping = e),
            t
        },
        loadCompressedTexture: function() {
            console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
        },
        loadCompressedTextureCube: function() {
            console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
        }
    },
    t.Projector = function() {
        console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."),
        this.projectVector = function(t, e) {
            console.warn("THREE.Projector: .projectVector() is now vector.project()."),
            t.project(e)
        }
        ,
        this.unprojectVector = function(t, e) {
            console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."),
            t.unproject(e)
        }
        ,
        this.pickingRay = function() {
            console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
        }
    }
    ,
    t.CanvasRenderer = function() {
        console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"),
        this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
        this.clear = function() {}
        ,
        this.render = function() {}
        ,
        this.setClearColor = function() {}
        ,
        this.setSize = function() {}
    }
    ,
    t.SceneUtils = {
        createMultiMaterialObject: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        },
        detach: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        },
        attach: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        }
    },
    t.LensFlare = function() {
        console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
    }
    ,
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
});
var BN = window.BN || {};
BN.functions = BN.functions || {},
Array.from || (Array.from = function(t) {
    "use strict";
    return [].slice.call(t)
}
),
Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector),
BN.functions.triggerEvent = function(t, e) {
    var n;
    window.CustomEvent && "function" == typeof window.CustomEvent ? n = new CustomEvent(t) : (n = document.createEvent("CustomEvent")).initCustomEvent(t, !0, !0, {}),
    e.dispatchEvent(n)
}
,
BN.functions.fadeOut = function(t) {
    var e = 1
      , n = setInterval(function() {
        e <= .1 && clearInterval(n),
        t.style.opacity = e,
        e -= .1
    }, 50)
}
,
BN.functions.forEach = function(t, e) {
    for (var n = 0; n < t.length; n++)
        e(t[n], n)
}
,
BN.functions.addListenerMulti = function(e, t, n) {
    BN.functions.forEach(t.split(" "), function(t) {
        e.addEventListener(t, n, !1)
    })
}
,
BN.functions.getOffsetObj = function(t) {
    return {
        left: t.offsetLeft,
        top: t.offsetTop
    }
}
,
BN.functions.matchChildren = function(t, e) {
    return void 0 !== t.children ? Array.from(t.children).filter(function(t) {
        return t.matches(e)
    }) : null
}
,
BN.functions.extend = function(t) {
    t = t || {};
    for (var e = 1; e < arguments.length; e++) {
        var n = arguments[e];
        if (n)
            for (var i in n)
                n.hasOwnProperty(i) && ("object" == typeof n[i] ? n[i]instanceof Array == 1 ? t[i] = n[i].slice(0) : t[i] = BN.functions.extend(t[i], n[i]) : t[i] = n[i])
    }
    return t
}
,
BN.content = BN.content || [],
BN.itemDesign = BN.itemDesign || {},
BN.itemSecurity = BN.itemSecurity || {},
BN.serie = BN.serie || "es2",
BN.denomination = BN.denomination || "100",
BN.loadRenderization = function() {
    var a = "shared/dist/plugins/banknotes/img";
    function i(t, e) {
        return {
            noteFront: a + "/3d-banknotes/scaled/" + e + "euro_fr_" + t.toUpperCase() + ".png",
            noteBack: a + "/3d-banknotes/scaled/" + e + "euro_re_" + t.toUpperCase() + ".png"
        }
    }
    var s, c, h = {
        ES1: {
            "005": "fragmentShader_ES1.fs",
            "010": "fragmentShader_ES1.fs",
            "020": "fragmentShader_ES1.fs",
            "050": "fragmentShader_ES1.fs",
            100: "fragmentShader_ES1.fs",
            200: "fragmentShader_ES1.fs",
            500: "fragmentShader_ES1.fs"
        },
        ES2: {
            "005": "fragmentShader_ES2_5.fs",
            "010": "fragmentShader_ES2_10.fs",
            "020": "fragmentShader_ES2_20_50.fs",
            "050": "fragmentShader_ES2_20_50.fs",
            100: "fragmentShader_ES2_100_200.fs",
            200: "fragmentShader_ES2_100_200.fs"
        }
    }, l = {
        ES1: {
            "005": "fragmentShader_ES1.fs",
            "010": "fragmentShader_ES1.fs",
            "020": "fragmentShader_ES1.fs",
            "050": "fragmentShader_ES1.fs",
            100: "fragmentShader_ES1.fs",
            200: "fragmentShader_ES1.fs",
            500: "fragmentShader_ES1.fs"
        },
        ES2: {
            "005": "fragmentShader_ES1.fs",
            "010": "fragmentShader_ES1.fs",
            "020": "fragmentShader_back.fs",
            "050": "fragmentShader_back.fs",
            100: "fragmentShader_back.fs",
            200: "fragmentShader_back.fs"
        }
    }, u = {
        ES1: {
            "005": {
                aspectRatio: 1.9333,
                emeraldNumb: 0,
                satCentreX: .92,
                satCentreY: .97,
                satWidth: .0918,
                satHeight: .1716
            },
            "010": {
                aspectRatio: 1.8898,
                emeraldNumb: 0,
                satCentreX: .92,
                satCentreY: .97,
                satWidth: .0918,
                satHeight: .1716
            },
            "020": {
                aspectRatio: 1.8346,
                emeraldNumb: 0,
                satCentreX: .92,
                satCentreY: .97,
                satWidth: .0918,
                satHeight: .1716
            },
            "050": {
                aspectRatio: 1.8,
                emeraldNumb: 0,
                satCentreX: .92,
                satCentreY: .97,
                satWidth: .0918,
                satHeight: .1716
            },
            100: {
                aspectRatio: 1.7687,
                emeraldNumb: 0,
                satCentreX: .92,
                satCentreY: .97,
                satWidth: .0918,
                satHeight: .1716
            },
            200: {
                aspectRatio: 1.8562,
                emeraldNumb: 0,
                satCentreX: .92,
                satCentreY: .97,
                satWidth: .0918,
                satHeight: .1716
            },
            500: {
                aspectRatio: 1.95,
                emeraldNumb: 0,
                satCentreX: .92,
                satCentreY: .97,
                satWidth: .0918,
                satHeight: .1716
            }
        },
        ES2: {
            "005": {
                aspectRatio: 1.9333,
                emeraldNumb: .31,
                satCentreX: .92,
                satCentreY: .97,
                satWidth: .0918,
                satHeight: .1716
            },
            "010": {
                aspectRatio: 1.8898,
                emeraldNumb: .34,
                satCentreX: .92,
                satCentreY: .97,
                satWidth: .0918,
                satHeight: .1716
            },
            "020": {
                aspectRatio: 1.8346,
                emeraldNumb: .35,
                satCentreX: .92,
                satCentreY: .97,
                satWidth: .0918,
                satHeight: .1716
            },
            "050": {
                aspectRatio: 1.8,
                emeraldNumb: .35,
                satCentreX: .92,
                satCentreY: .97,
                satWidth: .0918,
                satHeight: .1716
            },
            100: {
                aspectRatio: 1.9048,
                emeraldNumb: .35,
                satCentreX: .92,
                satCentreY: .97,
                satWidth: .0918,
                satHeight: .1716
            },
            200: {
                aspectRatio: 1.9869,
                emeraldNumb: .35,
                satCentreX: .93,
                satCentreY: .98,
                satWidth: .0918,
                satHeight: .1716
            }
        }
    }, t = i(BN.serie, BN.denomination), d = t.noteFront, p = t.noteBack, r = function() {
        f(l[BN.serie.toUpperCase()][BN.denomination], !0)
    }, o = window.ECB || {};
    function f(t, e) {
        var n, i;
        t = "shared/shader/" + (n = t),
        (i = new XMLHttpRequest).open("GET", t),
        i.onreadystatechange = function() {
            i.readyState === XMLHttpRequest.DONE && 200 === i.status && (o.shaderCache[n] = i.responseText,
            (e ? function() {
                for (var t = BN.serie, e = BN.denomination, n = document.querySelector(".spinny-image"); n.firstChild; )
                    n.removeChild(n.firstChild);
                c && c.destroy();
                var i = {
                    es1: {
                        masksFr: {},
                        masksBa: {}
                    },
                    es2: {
                        masksFr: {
                            uTexBottomLines: a + "/3d-masks/scaled/" + t.toUpperCase() + "-" + e + "-BottomLines.png",
                            uTex_Emerald_Foil: a + "/3d-masks/scaled/" + t.toUpperCase() + "-" + e + "-F-emerald-and-foil.png",
                            uTex_Image_Window: a + "/3d-masks/scaled/" + t.toUpperCase() + "-" + e + "-F-mainImage-and-portraitWindow.png"
                        },
                        masksBa: {
                            uTexRainbow: a + "/3d-masks/scaled/" + t.toUpperCase() + "-" + e + "-R-hologram-portraitWindow.png",
                            uTexBottomLines: a + "/3d-masks/scaled/" + t.toUpperCase() + "-" + e + "-FR-empty.png",
                            uTex_Emerald_Foil: a + "/3d-masks/scaled/" + t.toUpperCase() + "-" + e + "-FR-empty.png",
                            uTex_Image_Window: a + "/3d-masks/scaled/" + t.toUpperCase() + "-" + e + "-FR-empty.png"
                        }
                    }
                }
                  , r = {
                    es2: {
                        masksFr: {
                            uTexEdges_value1: a + "/3d-masks/scaled/" + t.toUpperCase() + "-" + e + "-F-hologram-edges-valueSymbol1.png",
                            uTexEdges_value2: a + "/3d-masks/scaled/" + t.toUpperCase() + "-" + e + "-F-hologram-edges-valueSymbol2.png"
                        },
                        masksBa: {
                            uTexEdges_value1: a + "/3d-masks/scaled/" + t.toUpperCase() + "-" + e + "-FR-empty.png",
                            uTexEdges_value2: a + "/3d-masks/scaled/" + t.toUpperCase() + "-" + e + "-FR-empty.png"
                        }
                    }
                }
                  , o = {
                    es2: {
                        masksFr: {
                            uTexSat: a + "/3d-masks/scaled/" + t.toUpperCase() + "-" + e + "-F-sat.png",
                            uTexSatElement: a + "/3d-masks/scaled/" + t.toUpperCase() + "-" + e + "-F-sat_tex_euro.png"
                        },
                        masksBa: {
                            uTexSat: a + "/3d-masks/scaled/" + t.toUpperCase() + "-" + e + "-FR-empty.png",
                            uTexSatElement: a + "/3d-masks/scaled/" + t.toUpperCase() + "-" + e + "-F-sat_tex_euro.png"
                        }
                    }
                };
                "020" == e || "050" == e ? i = BN.functions.extend(i, r) : "100" != e && "200" != e || (i = BN.functions.extend(i, o)),
                s = document.getElementById("bn-display-" + BN.serie),
                (c = new spinnyer(s,{
                    noteFront: d,
                    noteBack: p,
                    foil: "shared/dist/plugins/banknotes/img/3d-assets/hologram-gradient.png",
                    metal: "shared/dist/plugins/banknotes/img/3d-assets/specular-gradient.png",
                    masksFr: i[t].masksFr,
                    masksBa: i[t].masksBa
                },[[0, 0, -1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], [0, 0, -1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]],u[t.toUpperCase()][e],h[t.toUpperCase()][e],l[t.toUpperCase()][e])) || BN.functions.forEach(document.querySelectorAll(".spinny-image"), function(t) {
                    t.appendChild(s.querySelector(".spinny-image noscript"))
                })
            }
            : r)())
        }
        ,
        i.send()
    }
    o.shaderCache = {};
    return {
        init: function() {
            BN.functions.forEach(document.querySelectorAll(".banknotes-slider .item a"), function(n) {
                n.addEventListener("click", function() {
                    var t = document.querySelector(".spinny-loader");
                    BN.functions.fadeOut(t);
                    var e = BN.serie = n.getAttribute("id").slice(0, 3)
                      , t = BN.denomination = n.getAttribute("id").slice(4, 7);
                    d = i(e, t).noteFront,
                    p = i(e, t).noteBack,
                    f(h[BN.serie.toUpperCase()][BN.denomination])
                })
            })
        }
    }
}(),
BN.loadInteractivity = function() {
    function t() {
        var t = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
        return !(767 < parseInt(t))
    }
    function e(e) {
        BN.functions.forEach(document.querySelectorAll(".bn-tabs-content .bn-tabs"), function(t) {
            e || h >= parseInt(.92 * document.querySelector(".bn-centered-tabs").clientWidth / 2) ? t.classList.add("bn-mobile") : (t.classList.remove("bn-mobile"),
            document.querySelector(".bn-tab-content").classList.remove("hideAccordionContent"))
        })
    }
    function i() {
        document.getElementById(BN.serie + "_designContainer").innerHTML = BN.itemDesign[BN.serie + BN.denomination],
        document.getElementById(BN.serie + "_securityContainer").innerHTML = BN.itemSecurity[BN.serie + BN.denomination],
        BN.functions.forEach(document.querySelectorAll("img[data-src], source[data-src]"), function(t) {
            t.setAttribute("src", t.getAttribute("data-src")),
            t.removeAttribute("data-src")
        }),
        document.addEventListener("emeraldNumberTrigger", l),
        document.addEventListener("portraitHologramTrigger", u),
        document.addEventListener("portraitWindowTrigger", d),
        document.addEventListener("hologramTrigger", p),
        document.addEventListener("glossyStripeTrigger", f),
        document.addEventListener("colorChangingNumberTrigger", m)
    }
    function n(t, e, n) {
        BN.itemDesign[t + e] = Array.from(n).filter(function(t) {
            return -1 < t.getAttribute("id").indexOf(e + "DesignContent")
        })[0].innerHTML,
        BN.itemSecurity[t + e] = Array.from(n).filter(function(t) {
            return -1 < t.getAttribute("id").indexOf(e + "SecurityContent")
        })[0].innerHTML,
        i()
    }
    function r() {
        n(BN.serie, BN.denomination, BN.content[BN.serie]),
        BN.functions.forEach(document.querySelectorAll(".banknotes-slider .item a, .bn-centered-tabs a"), function(t) {
            t.addEventListener("click", function() {
                BN.functions.forEach(document.querySelectorAll(".europaFeature, .firstFeature"), function(t) {
                    t.classList.remove("anim")
                }),
                BN.functions.forEach(document.querySelectorAll("video"), function(t) {
                    t.pause()
                }),
                BN.functions.forEach(document.querySelectorAll(".bn-tabs-content.bn-nested-tabs-content .is-active .detailsContainer .europaFeature"), function(t) {
                    t.removeEventListener("portraitHologramTrigger", u)
                }),
                null == BN.itemDesign[BN.serie + BN.denomination] ? n(BN.serie, BN.denomination, BN.content[BN.serie]) : i()
            })
        })
    }
    function o() {
        document.addEventListener("scroll", function() {
            BN.functions.forEach(document.querySelectorAll(".bn-tabs-content.bn-nested-tabs-content .is-active .detailsContainer .europaFeature, .bn-tabs-content.bn-nested-tabs-content .is-active .detailsContainer .firstFeature"), function(t) {
                var e = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
                document.documentElement.scrollTop + e / 2 > BN.functions.getOffsetObj(t).top && (t.classList.add("anim"),
                t.classList.contains("videoAnim") && BN.functions.triggerEvent(t.getAttribute("data-trigger"), t))
            })
        }),
        BN.functions.forEach(document.querySelectorAll(".bn-accordion"), function(i) {
            i.addEventListener("click", function() {
                i.parentNode.classList.contains("hideAccordionContent") ? i.parentNode.classList.remove("hideAccordionContent") : i.parentNode.classList.contains("is-active") ? i.parentNode.classList.add("hideAccordionContent") : BN.functions.forEach(document.querySelectorAll(".bn-nested-tabs-content .bn-tab-content"), function(t) {
                    t.classList.remove("hideAccordionContent")
                });
                for (var t = i.parentNode; !t.classList.contains("bn-nested-tabs-content"); )
                    t = t.parentNode;
                var e = Array.from(t.children).indexOf(i.parentNode)
                  , n = t.getAttribute("id");
                document.getElementById(n).scrollIntoView({
                    block: "start",
                    behavior: "smooth"
                }),
                BN.functions.triggerEvent("click", document.querySelectorAll(".bn-nested-tabs a")[e])
            })
        }),
        e(t()),
        window.addEventListener("resize", function() {
            e(t())
        })
    }
    function a() {
        var e;
        BN.functions.forEach(document.querySelectorAll(".banknotes-slider .item a"), function(n) {
            n.addEventListener("click", function() {
                var t = n.getAttribute("id").slice(0, 3)
                  , e = n.getAttribute("id").slice(4, 7);
                c && window.history.replaceState(null, null, "#" + t + "-" + e),
                BN.functions.forEach(document.querySelectorAll(".banknotes-slider span.is_selected"), function(t) {
                    t.classList.remove("is_selected")
                }),
                n.querySelector("span").classList.add("is_selected")
            })
        }),
        BN.functions.forEach(document.querySelectorAll(".bn-centered-tabs a"), function(r) {
            r.addEventListener("click", function() {
                for (var t = Array.from(r.parentNode.children).indexOf(r), e = r.getAttribute("id"), n = r.parentNode; !n.classList.contains("bn-tabs"); )
                    n = n.parentNode;
                var i = BN.functions.matchChildren(n, ".bn-centered-tabs")[0];
                BN.functions.forEach(BN.functions.matchChildren(i, "a.is-active"), function(t) {
                    t.classList.remove("is-active")
                }),
                r.classList.add("is-active");
                i = BN.functions.matchChildren(n, ".bn-tabs-content")[0];
                BN.functions.forEach(BN.functions.matchChildren(i, "div.is-active"), function(t) {
                    t.classList.remove("is-active")
                }),
                BN.functions.matchChildren(i, "div:nth-of-type(" + (t + 1) + ")")[0].classList.add("is-active"),
                null != e && (t = "500" != BN.denomination ? BN.denomination : "005",
                BN.functions.triggerEvent("click", document.getElementById(("series1" == e ? "es1" : "es2") + "-" + t)))
            })
        }),
        e = [],
        BN.functions.forEach(document.querySelectorAll(".bn-centered-tabs a span"), function(t) {
            e.push(t.clientWidth),
            void 0 === t.nextSibling && (h = e.reduce(function(t, e) {
                return Math.max(t, e)
            }))
        })
    }
    function s() {
        var t;
        document.location.hash ? (t = document.location.hash.substr(3, 1),
        BN.functions.triggerEvent("click", document.querySelector(document.location.hash)),
        BN.serie = document.location.hash.substr(1, 3),
        BN.denomination = document.location.hash.substr(5, 7),
        "series" + t != document.querySelector(".bn-denominations-container>.bn-tabs>.bn-centered-tabs>.is-active").getAttribute("id") && BN.functions.triggerEvent("click", document.getElementById("series" + t))) : (t = document.querySelector("#" + BN.serie + "-" + BN.denomination)) && BN.functions.triggerEvent("click", t)
    }
    var c = "main" == document.querySelector(".bn-denominations-container").parentElement.localName
      , h = 0
      , l = function() {
        objectFitPolyfill(),
        document.getElementById("ES2EN").currentTime = 0,
        setTimeout(function() {
            document.getElementById("ES2EN").play(),
            document.removeEventListener("emeraldNumberTrigger", l)
        }, 3e3)
    }
      , u = function() {
        objectFitPolyfill(),
        document.getElementById("ES2PH").currentTime = 0,
        setTimeout(function() {
            document.getElementById("ES2PH").play(),
            document.removeEventListener("portraitHologramTrigger", u)
        }, 3e3)
    }
      , d = function() {
        objectFitPolyfill(),
        document.getElementById("ES2PW").currentTime = 0,
        setTimeout(function() {
            document.getElementById("ES2PW").play(),
            document.removeEventListener("portraitWindowTrigger", d)
        }, 3e3)
    }
      , p = function() {
        objectFitPolyfill(),
        document.getElementById("ES1_H").currentTime = 0,
        setTimeout(function() {
            document.getElementById("ES1_H").play(),
            document.removeEventListener("hologramTrigger", p)
        }, 3e3)
    }
      , f = function() {
        objectFitPolyfill(),
        document.getElementById("ES1GS").currentTime = 0,
        setTimeout(function() {
            document.getElementById("ES1GS").play(),
            document.removeEventListener("glossyStripeTrigger", f)
        }, 3e3)
    }
      , m = function() {
        objectFitPolyfill(),
        document.getElementById("ES1CN").currentTime = 0,
        setTimeout(function() {
            document.getElementById("ES1CN").play(),
            document.removeEventListener("colorChangingNumberTrigger", m)
        }, 3e3)
    }
      , g = function(t, e, n) {
        var i, r;
        i = "../html/series/" + t + "_content." + e + ".html",
        (r = new XMLHttpRequest).onreadystatechange = function() {
            r.readyState === XMLHttpRequest.DONE && 200 === r.status ? n(r.responseText) : "en" != e && g(t, "en", n)
        }
        ,
        r.open("GET", i, !1),
        r.setRequestHeader("Content-type", "text/html"),
        r.send()
    };
    return {
        init: function() {
            a(),
            s(),
            c && null != document.querySelector(".bn-denominations-container .bn-nested-tabs") && (function() {
                for (var t = ECB.currentLanguage || "en", e = ["es1", "es2"], n = 0; n < e.length; n++) {
                    var i = e[n];
                    g(i, t, function() {
                        var n = i;
                        return function(t) {
                            var e = document.createElement("div");
                            e.innerHTML = t,
                            BN.content[n] = BN.functions.matchChildren(e, "div")
                        }
                    }())
                }
                r()
            }(),
            o())
        },
        initItem: s
    }
}(),
BN.denominations = function() {
    function t() {
        BN.loadRenderization.init(),
        BN.loadInteractivity.init()
    }
    return {
        init: function() {
            "loading" !== document.readyState ? t() : window.addEventListener("DOMContentLoaded", t)
        }
    }
}();
var ECB = window.ECB || {};
ECB.componentList = ECB.componentList || [],
ECB.componentList = ECB.componentList.concat([BN.denominations]);
BN.denominations.init();
